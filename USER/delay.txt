; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\obj\delay.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\delay.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime -I..\CORE -I..\STM32F10x_FWLIB\inc -I..\USER -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\C++LIB\OnChip\GPIO -I..\C++LIB\ToolBox\Buffer -I..\C++LIB\System -I..\C++LIB\OnChip\IIC -I..\C++LIB\OffChip -I..\C++LIB\System\TaskManager -I..\C++LIB\System\Interrupt -I..\C++LIB\OnChip\SerialPort -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -W --omf_browse=..\obj\delay.crf ..\SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;53     //SYSCLK:系统时钟
;;;54     void delay_init()	 
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56     
;;;57     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;58     	u32 reload;
;;;59     #endif
;;;60     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);	//选择外部时钟  HCLK/8
000002  f06f0004          MVN      r0,#4
000006  f7fffffe          BL       SysTick_CLKSourceConfig
;;;61     	fac_us=SystemCoreClock/8000000;	//为系统时钟的1/8  
00000a  4822              LDR      r0,|L1.148|
00000c  4922              LDR      r1,|L1.152|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  fbb0f0f1          UDIV     r0,r0,r1
000014  b2c1              UXTB     r1,r0
000016  4821              LDR      r0,|L1.156|
;;;62     	 
;;;63     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;64     	reload=SystemCoreClock/8000000;		//每秒钟的计数次数 单位为K	   
;;;65     	reload*=1000000/OS_TICKS_PER_SEC;//根据OS_TICKS_PER_SEC设定溢出时间
;;;66     							//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右	
;;;67     	fac_ms=1000/OS_TICKS_PER_SEC;//代表ucos可以延时的最少单位	   
;;;68     	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
;;;69     	SysTick->LOAD=reload; 	//每1/OS_TICKS_PER_SEC秒中断一次	
;;;70     	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK    
;;;71     #else
;;;72     	fac_ms=(u16)fac_us*1000;//非ucos下,代表每个ms需要的systick时钟数   
000018  eb010241          ADD      r2,r1,r1,LSL #1
00001c  7001              STRB     r1,[r0,#0]            ;61
00001e  ebc211c1          RSB      r1,r2,r1,LSL #7
000022  f64f72ff          MOV      r2,#0xffff
000026  ea0201c1          AND      r1,r2,r1,LSL #3
00002a  8041              STRH     r1,[r0,#2]
;;;73     #endif
;;;74     }								    
00002c  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  delay_us PROC
;;;115    //nus为要延时的us数.		    								   
;;;116    void delay_us(u32 nus)
00002e  491b              LDR      r1,|L1.156|
;;;117    {		
;;;118    	u32 temp;	    	 
;;;119    	SysTick->LOAD=nus*fac_us; //时间加载	  		 
000030  7809              LDRB     r1,[r1,#0]  ; fac_us
000032  4341              MULS     r1,r0,r1
000034  f04f20e0          MOV      r0,#0xe000e000
000038  6141              STR      r1,[r0,#0x14]
;;;120    	SysTick->VAL=0x00;        //清空计数器
00003a  2300              MOVS     r3,#0
00003c  6183              STR      r3,[r0,#0x18]
;;;121    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;          //开始倒数	 
00003e  6901              LDR      r1,[r0,#0x10]
000040  f0410101          ORR      r1,r1,#1
000044  6101              STR      r1,[r0,#0x10]
                  |L1.70|
;;;122    	do
;;;123    	{
;;;124    		temp=SysTick->CTRL;
000046  6901              LDR      r1,[r0,#0x10]
000048  f0110f01          TST      r1,#1
00004c  d002              BEQ      |L1.84|
00004e  f4113f80          TST      r1,#0x10000
000052  d0f8              BEQ      |L1.70|
                  |L1.84|
;;;125    	}
;;;126    	while(temp&0x01&&!(temp&(1<<16)));//等待时间到达   
;;;127    	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;       //关闭计数器
000054  6901              LDR      r1,[r0,#0x10]
000056  f0210101          BIC      r1,r1,#1
00005a  6101              STR      r1,[r0,#0x10]
;;;128    	SysTick->VAL =0X00;       //清空计数器	 
00005c  6183              STR      r3,[r0,#0x18]
;;;129    }
00005e  4770              BX       lr
;;;130    //延时nms
                          ENDP

                  delay_ms PROC
;;;135    //对72M条件下,nms<=1864 
;;;136    void delay_ms(u16 nms)
000060  490e              LDR      r1,|L1.156|
;;;137    {	 		  	  
;;;138    	u32 temp;		   
;;;139    	SysTick->LOAD=(u32)nms*fac_ms;//时间加载(SysTick->LOAD为24bit)
000062  8849              LDRH     r1,[r1,#2]  ; fac_ms
000064  4341              MULS     r1,r0,r1
000066  f04f20e0          MOV      r0,#0xe000e000
00006a  6141              STR      r1,[r0,#0x14]
;;;140    	SysTick->VAL =0x00;           //清空计数器
00006c  2300              MOVS     r3,#0
00006e  6183              STR      r3,[r0,#0x18]
;;;141    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;          //开始倒数  
000070  6901              LDR      r1,[r0,#0x10]
000072  f0410101          ORR      r1,r1,#1
000076  6101              STR      r1,[r0,#0x10]
                  |L1.120|
;;;142    	do
;;;143    	{
;;;144    		temp=SysTick->CTRL;
000078  6901              LDR      r1,[r0,#0x10]
00007a  f0110f01          TST      r1,#1
00007e  d002              BEQ      |L1.134|
000080  f4113f80          TST      r1,#0x10000
000084  d0f8              BEQ      |L1.120|
                  |L1.134|
;;;145    	}
;;;146    	while(temp&0x01&&!(temp&(1<<16)));//等待时间到达   
;;;147    	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;       //关闭计数器
000086  6901              LDR      r1,[r0,#0x10]
000088  f0210101          BIC      r1,r1,#1
00008c  6101              STR      r1,[r0,#0x10]
;;;148    	SysTick->VAL =0X00;       //清空计数器	  	    
00008e  6183              STR      r3,[r0,#0x18]
;;;149    } 
000090  4770              BX       lr
;;;150    #endif
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
                          DCD      SystemCoreClock
                  |L1.152|
                          DCD      0x007a1200
                  |L1.156|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
