; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o..\obj\iic.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\iic.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime -I..\CORE -I..\STM32F10x_FWLIB\inc -I..\USER -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\C++LIB\OnChip\GPIO -I..\C++LIB\ToolBox\Buffer -I..\C++LIB\System -I..\C++LIB\OnChip\IIC -I..\C++LIB\OffChip -I..\C++LIB\System\TaskManager -I..\C++LIB\System\Interrupt -I..\C++LIB\OnChip\SerialPort -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -W --omf_browse=..\obj\iic.crf ..\C++LIB\OnChip\IIC\IIC.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN3IIC8InitGPIOEv PROC ; IIC::InitGPIO()
;;;59     //GPIO Initialization for i2c pin
;;;60     void IIC::InitGPIO()
000000  b538              PUSH     {r3-r5,lr}
;;;61     {
000002  4604              MOV      r4,r0
;;;62     	GPIO_InitTypeDef GPIO_InitStructure;
;;;63     	
;;;64     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);//enable clock for i2c gpio pin
000004  2101              MOVS     r1,#1
000006  2008              MOVS     r0,#8
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;65     	
;;;66     	if(_i2c==I2C1 && _gpio_remap==1)//I2C1 on gpio remap case
00000c  6820              LDR      r0,[r4,#0]
00000e  f1a04180          SUB      r1,r0,#0x40000000
000012  f5b141a8          SUBS     r1,r1,#0x5400
000016  bf04              ITT      EQ
000018  7c20              LDRBEQ   r0,[r4,#0x10]
00001a  2801              CMPEQ    r0,#1
00001c  d107              BNE      |L1.46|
;;;67     	{
;;;68     		RCC_APB2PeriphClockCmd((RCC_APB2Periph_AFIO),ENABLE); //Enable GPIO Alternative Functions
00001e  2101              MOVS     r1,#1
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;69         GPIO_PinRemapConfig(GPIO_Remap_I2C1, ENABLE);//Enable I2C1 pin Remap
000026  2101              MOVS     r1,#1
000028  2002              MOVS     r0,#2
00002a  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.46|
;;;70     	}
;;;71       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//Set GPIO frequency to 50MHz
00002e  2003              MOVS     r0,#3
000030  f88d0002          STRB     r0,[sp,#2]
;;;72       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;  //Select Output open-drain mode
000034  201c              MOVS     r0,#0x1c
000036  f88d0003          STRB     r0,[sp,#3]
;;;73       GPIO_InitStructure.GPIO_Pin = _scl_pin;          //Initialize I2Cx SCL Pin
00003a  8920              LDRH     r0,[r4,#8]
;;;74       GPIO_Init(GPIOB, &GPIO_InitStructure);
00003c  4dfa              LDR      r5,|L1.1064|
00003e  f8ad0000          STRH     r0,[sp,#0]            ;73
000042  4669              MOV      r1,sp
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       GPIO_Init
;;;75       GPIO_InitStructure.GPIO_Pin = _sda_pin;          //Initialize I2Cx SDA Pin
00004a  8960              LDRH     r0,[r4,#0xa]
00004c  f8ad0000          STRH     r0,[sp,#0]
;;;76       GPIO_Init(GPIOB, &GPIO_InitStructure);  
000050  4669              MOV      r1,sp
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       GPIO_Init
;;;77     }
000058  bd38              POP      {r3-r5,pc}
;;;78     
                          ENDP

                  _ZN3IIC14SetDefaultGPIOEv PROC ; IIC::SetDefaultGPIO()
;;;79     //set gpio as default io
;;;80     void IIC::SetDefaultGPIO()
00005a  b538              PUSH     {r3-r5,lr}
;;;81     {
00005c  4604              MOV      r4,r0
;;;82       GPIO_InitTypeDef GPIO_InitStructure;
;;;83       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    //Set GPIO frequency to 50MHz
00005e  2003              MOVS     r0,#3
000060  f88d0002          STRB     r0,[sp,#2]
;;;84       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//Select Input floating mode
000064  2004              MOVS     r0,#4
000066  f88d0003          STRB     r0,[sp,#3]
;;;85       GPIO_InitStructure.GPIO_Pin = _scl_pin;              //Default initialize I2Cx SCL Pin
00006a  8920              LDRH     r0,[r4,#8]
;;;86       GPIO_Init(GPIOB, &GPIO_InitStructure);
00006c  4dee              LDR      r5,|L1.1064|
00006e  f8ad0000          STRH     r0,[sp,#0]            ;85
000072  4669              MOV      r1,sp
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       GPIO_Init
;;;87       GPIO_InitStructure.GPIO_Pin = _sda_pin;              //Default initialize I2Cx SDA Pin
00007a  8960              LDRH     r0,[r4,#0xa]
00007c  f8ad0000          STRH     r0,[sp,#0]
;;;88       GPIO_Init(GPIOB, &GPIO_InitStructure);
000080  4669              MOV      r1,sp
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       GPIO_Init
;;;89     }
000088  bd38              POP      {r3-r5,pc}
;;;90     
                          ENDP

                  _ZN3IIC14Check_Busy_FixEv PROC ; IIC::Check_Busy_Fix()
;;;93     //check the BUSY bit of i2c device, and fix it if BUSY=1
;;;94     void IIC::Check_Busy_Fix()
00008a  e92d47f0          PUSH     {r4-r10,lr}
;;;95     {
;;;96     	u8 Time_out=0;
00008e  2600              MOVS     r6,#0
;;;97     	GPIO_InitTypeDef GPIO_InitStructure;
;;;98     
;;;99     	while(I2C_GetFlagStatus(_i2c, I2C_FLAG_BUSY) && Time_out<20)
;;;100    	{
;;;101    		RCC_APB1PeriphClockCmd(_i2c_rcc,DISABLE);           //disable i2c clock
;;;102    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);//enable gpio clock		
;;;103    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   //Set GPIO frequency to 50MHz
;;;104    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;    //Select Output open-drain mode
;;;105    		GPIO_InitStructure.GPIO_Pin = _scl_pin;             //Initialize I2Cx SCL Pin
;;;106    		GPIO_Init(GPIOB, &GPIO_InitStructure);
000090  4fe5              LDR      r7,|L1.1064|
000092  b082              SUB      sp,sp,#8              ;95
000094  4604              MOV      r4,r0                 ;95
000096  f04f0910          MOV      r9,#0x10              ;104
00009a  4635              MOV      r5,r6                 ;104
00009c  f04f0803          MOV      r8,#3                 ;103
0000a0  f04f0a04          MOV      r10,#4                ;103
                  |L1.164|
0000a4  f44f3100          MOV      r1,#0x20000           ;99
0000a8  6820              LDR      r0,[r4,#0]            ;99
0000aa  f7fffffe          BL       I2C_GetFlagStatus
0000ae  2800              CMP      r0,#0                 ;99
0000b0  bf18              IT       NE                    ;99
0000b2  2e14              CMPNE    r6,#0x14              ;99
;;;107    		GPIO_InitStructure.GPIO_Pin = _sda_pin;             //Initialize I2Cx SDA Pin
;;;108    		GPIO_Init(GPIOB, &GPIO_InitStructure); 
;;;109    		  
;;;110    		//generate STOP command with direct gpio pin
;;;111    		volatile u16 i;
;;;112    		GPIO_ResetBits(GPIOB, _scl_pin);
;;;113    		GPIO_ResetBits(GPIOB, _sda_pin);
;;;114    		for(i=0;i<100;i++);
;;;115    		GPIO_SetBits(GPIOB, _scl_pin);
;;;116    		for(i=0;i<100;i++);
;;;117    		GPIO_SetBits(GPIOB, _sda_pin);
;;;118    		for(i=0;i<100;i++);
;;;119    		
;;;120    		SetDefaultGPIO();//set i2c pin as normal io pin
;;;121    		RCC_APB1PeriphResetCmd(_i2c_rcc,ENABLE); //reset i2c clock
;;;122    		RCC_APB1PeriphResetCmd(_i2c_rcc,DISABLE);//end i2c clock reseting
;;;123    		RCC_APB1PeriphClockCmd(_i2c_rcc,ENABLE); //open i2c clock
;;;124    		++Time_out;
;;;125    	}
;;;126    	
;;;127    }
0000b4  bf24              ITT      CS
0000b6  b002              ADDCS    sp,sp,#8
0000b8  e8bd87f0          POPCS    {r4-r10,pc}
0000bc  2100              MOVS     r1,#0                 ;101
0000be  68e0              LDR      r0,[r4,#0xc]          ;101
0000c0  f7fffffe          BL       RCC_APB1PeriphClockCmd
0000c4  2101              MOVS     r1,#1                 ;102
0000c6  2008              MOVS     r0,#8                 ;102
0000c8  f7fffffe          BL       RCC_APB2PeriphClockCmd
0000cc  f88d8002          STRB     r8,[sp,#2]            ;103
0000d0  f88d9003          STRB     r9,[sp,#3]            ;104
0000d4  8920              LDRH     r0,[r4,#8]            ;105
0000d6  f8ad0000          STRH     r0,[sp,#0]            ;105
0000da  4669              MOV      r1,sp                 ;106
0000dc  4638              MOV      r0,r7                 ;106
0000de  f7fffffe          BL       GPIO_Init
0000e2  8960              LDRH     r0,[r4,#0xa]          ;107
0000e4  f8ad0000          STRH     r0,[sp,#0]            ;107
0000e8  4669              MOV      r1,sp                 ;108
0000ea  4638              MOV      r0,r7                 ;108
0000ec  f7fffffe          BL       GPIO_Init
0000f0  8921              LDRH     r1,[r4,#8]            ;112
0000f2  4638              MOV      r0,r7                 ;112
0000f4  f7fffffe          BL       GPIO_ResetBits
0000f8  8961              LDRH     r1,[r4,#0xa]          ;113
0000fa  4638              MOV      r0,r7                 ;113
0000fc  f7fffffe          BL       GPIO_ResetBits
000100  f8ad5004          STRH     r5,[sp,#4]            ;114
000104  e005              B        |L1.274|
000106  bf00              NOP                            ;114
                  |L1.264|
000108  f8bd0004          LDRH     r0,[sp,#4]            ;114
00010c  1c40              ADDS     r0,r0,#1              ;114
00010e  f8ad0004          STRH     r0,[sp,#4]            ;114
                  |L1.274|
000112  f8bd0004          LDRH     r0,[sp,#4]            ;114
000116  2864              CMP      r0,#0x64              ;114
000118  d3f6              BCC      |L1.264|
00011a  8921              LDRH     r1,[r4,#8]            ;115
00011c  4638              MOV      r0,r7                 ;115
00011e  f7fffffe          BL       GPIO_SetBits
000122  f8ad5004          STRH     r5,[sp,#4]            ;116
000126  e004              B        |L1.306|
                  |L1.296|
000128  f8bd0004          LDRH     r0,[sp,#4]            ;116
00012c  1c40              ADDS     r0,r0,#1              ;116
00012e  f8ad0004          STRH     r0,[sp,#4]            ;116
                  |L1.306|
000132  f8bd0004          LDRH     r0,[sp,#4]            ;116
000136  2864              CMP      r0,#0x64              ;116
000138  d3f6              BCC      |L1.296|
00013a  8961              LDRH     r1,[r4,#0xa]          ;117
00013c  4638              MOV      r0,r7                 ;117
00013e  f7fffffe          BL       GPIO_SetBits
000142  f8ad5004          STRH     r5,[sp,#4]            ;118
000146  e004              B        |L1.338|
                  |L1.328|
000148  f8bd0004          LDRH     r0,[sp,#4]            ;118
00014c  1c40              ADDS     r0,r0,#1              ;118
00014e  f8ad0004          STRH     r0,[sp,#4]            ;118
                  |L1.338|
000152  f8bd0004          LDRH     r0,[sp,#4]            ;118
000156  2864              CMP      r0,#0x64              ;118
000158  d3f6              BCC      |L1.328|
00015a  f88d8006          STRB     r8,[sp,#6]            ;118
00015e  f88da007          STRB     r10,[sp,#7]           ;118
000162  8920              LDRH     r0,[r4,#8]            ;118
000164  f8ad0004          STRH     r0,[sp,#4]            ;118
000168  a901              ADD      r1,sp,#4              ;118
00016a  4638              MOV      r0,r7                 ;118
00016c  f7fffffe          BL       GPIO_Init
000170  8960              LDRH     r0,[r4,#0xa]          ;118
000172  f8ad0004          STRH     r0,[sp,#4]            ;118
000176  a901              ADD      r1,sp,#4              ;118
000178  4638              MOV      r0,r7                 ;118
00017a  f7fffffe          BL       GPIO_Init
00017e  2101              MOVS     r1,#1                 ;121
000180  68e0              LDR      r0,[r4,#0xc]          ;121
000182  f7fffffe          BL       RCC_APB1PeriphResetCmd
000186  2100              MOVS     r1,#0                 ;122
000188  68e0              LDR      r0,[r4,#0xc]          ;122
00018a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00018e  2101              MOVS     r1,#1                 ;123
000190  68e0              LDR      r0,[r4,#0xc]          ;123
000192  f7fffffe          BL       RCC_APB1PeriphClockCmd
000196  1c70              ADDS     r0,r6,#1              ;124
000198  b2c6              UXTB     r6,r0                 ;124
00019a  e783              B        |L1.164|
;;;128    
                          ENDP

                  _ZN3IIC12ClearCommandEv PROC ; IIC::ClearCommand()
;;;223    //clear all i2c commands in queue
;;;224    void IIC::ClearCommand()
00019c  2100              MOVS     r1,#0
00019e  f8a01342          STRH     r1,[r0,#0x342]
0001a2  f8a01344          STRH     r1,[r0,#0x344]
0001a6  f8a01346          STRH     r1,[r0,#0x346]
;;;225    {
;;;226    	_i2c_cmd_queue.Clear();
;;;227    }	
0001aa  4770              BX       lr
;;;228    
                          ENDP

                  _ZN3IIC10InitializeEv PROC ; IIC::Initialize()
;;;128    
;;;129    void IIC::Initialize()
0001ac  b570              PUSH     {r4-r6,lr}
;;;130    {
0001ae  4604              MOV      r4,r0
;;;131    	I2C_InitTypeDef I2C_InitStructure;
;;;132    	NVIC_InitTypeDef NVIC_InitStructure;
;;;133    	
;;;134    	_i2c->CR1 &= ~I2C_CR1_PE; // = I2C_Cmd(_i2c,DISABLE);  disable i2c device
0001b0  6800              LDR      r0,[r0,#0]
0001b2  b086              SUB      sp,sp,#0x18           ;130
0001b4  8801              LDRH     r1,[r0,#0]
0001b6  f0210101          BIC      r1,r1,#1
0001ba  8001              STRH     r1,[r0,#0]
0001bc  2603              MOVS     r6,#3
0001be  f88d6006          STRB     r6,[sp,#6]
0001c2  2004              MOVS     r0,#4
0001c4  f88d0007          STRB     r0,[sp,#7]
0001c8  8920              LDRH     r0,[r4,#8]
0001ca  4d97              LDR      r5,|L1.1064|
0001cc  f8ad0004          STRH     r0,[sp,#4]
0001d0  a901              ADD      r1,sp,#4
0001d2  4628              MOV      r0,r5
0001d4  f7fffffe          BL       GPIO_Init
0001d8  8960              LDRH     r0,[r4,#0xa]
0001da  f8ad0004          STRH     r0,[sp,#4]
0001de  a901              ADD      r1,sp,#4
0001e0  4628              MOV      r0,r5
0001e2  f7fffffe          BL       GPIO_Init
;;;135    	
;;;136    	SetDefaultGPIO();//set i2c pin as normal io pin
;;;137    	RCC_APB1PeriphResetCmd(_i2c_rcc,ENABLE); //reset i2c clock
0001e6  2101              MOVS     r1,#1
0001e8  68e0              LDR      r0,[r4,#0xc]
0001ea  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;138    	RCC_APB1PeriphResetCmd(_i2c_rcc,DISABLE);//end i2c clock reset
0001ee  2100              MOVS     r1,#0
0001f0  68e0              LDR      r0,[r4,#0xc]
0001f2  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;139    	RCC_APB1PeriphClockCmd(_i2c_rcc,DISABLE);//close i2c clock
0001f6  2100              MOVS     r1,#0
0001f8  68e0              LDR      r0,[r4,#0xc]
0001fa  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;140    		
;;;141    	RCC_APB1PeriphResetCmd(_i2c_rcc,ENABLE); //reset i2c clock
0001fe  2101              MOVS     r1,#1
000200  68e0              LDR      r0,[r4,#0xc]
000202  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;142    	RCC_APB1PeriphResetCmd(_i2c_rcc,DISABLE);//end i2c clock reset
000206  2100              MOVS     r1,#0
000208  68e0              LDR      r0,[r4,#0xc]
00020a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;143    	RCC_APB1PeriphClockCmd(_i2c_rcc,ENABLE); //open i2c clock
00020e  2101              MOVS     r1,#1
000210  68e0              LDR      r0,[r4,#0xc]
000212  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;144    	
;;;145    	Check_Busy_Fix(); //check if sda is low, and fix it if ture
000216  4620              MOV      r0,r4
000218  f7fffffe          BL       _ZN3IIC14Check_Busy_FixEv ; IIC::Check_Busy_Fix()
00021c  2101              MOVS     r1,#1
00021e  2008              MOVS     r0,#8
000220  f7fffffe          BL       RCC_APB2PeriphClockCmd
000224  6820              LDR      r0,[r4,#0]
000226  f1a04180          SUB      r1,r0,#0x40000000
00022a  f5b141a8          SUBS     r1,r1,#0x5400
00022e  bf04              ITT      EQ
000230  7c20              LDRBEQ   r0,[r4,#0x10]
000232  2801              CMPEQ    r0,#1
000234  d107              BNE      |L1.582|
000236  2101              MOVS     r1,#1
000238  4608              MOV      r0,r1
00023a  f7fffffe          BL       RCC_APB2PeriphClockCmd
00023e  2101              MOVS     r1,#1
000240  2002              MOVS     r0,#2
000242  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.582|
000246  f88d6006          STRB     r6,[sp,#6]
00024a  201c              MOVS     r0,#0x1c
00024c  f88d0007          STRB     r0,[sp,#7]
000250  8920              LDRH     r0,[r4,#8]
000252  f8ad0004          STRH     r0,[sp,#4]
000256  a901              ADD      r1,sp,#4
000258  4628              MOV      r0,r5
00025a  f7fffffe          BL       GPIO_Init
00025e  8960              LDRH     r0,[r4,#0xa]
000260  f8ad0004          STRH     r0,[sp,#4]
000264  a901              ADD      r1,sp,#4
000266  4628              MOV      r0,r5
000268  f7fffffe          BL       GPIO_Init
;;;146    	
;;;147    	InitGPIO(); //inilitialze gpio for i2c pin
;;;148    	
;;;149    	//_i2c->CR1 |= I2C_CR1_PE;// = I2C_Cmd(I2C,ENABLE);   enable i2c device
;;;150    		
;;;151    	I2C_InitStructure.I2C_ClockSpeed          = _i2c_speed;                  //Initialize the I2C_ClockSpeed member
00026c  6860              LDR      r0,[r4,#4]
;;;152    	I2C_InitStructure.I2C_Mode                = I2C_Mode_I2C;                //Initialize the I2C_Mode member
00026e  2500              MOVS     r5,#0
000270  9002              STR      r0,[sp,#8]
000272  f8ad500c          STRH     r5,[sp,#0xc]
;;;153    	I2C_InitStructure.I2C_DutyCycle           = I2C_DutyCycle_2;             //Initialize the I2C_DutyCycle member
000276  f64b70ff          MOV      r0,#0xbfff
00027a  f8ad000e          STRH     r0,[sp,#0xe]
;;;154    	I2C_InitStructure.I2C_OwnAddress1         = 0;                           //Initialize the I2C_OwnAddress1 member
00027e  f8ad5010          STRH     r5,[sp,#0x10]
;;;155    	I2C_InitStructure.I2C_Ack                 = I2C_Ack_Enable;              //Initialize the I2C_Ack member
000282  f44f6080          MOV      r0,#0x400
000286  f8ad0012          STRH     r0,[sp,#0x12]
;;;156    	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;//Initialize the I2C_AcknowledgedAddress member
00028a  0100              LSLS     r0,r0,#4
00028c  f8ad0014          STRH     r0,[sp,#0x14]
;;;157    	I2C_Init(_i2c,&I2C_InitStructure); //initialize i2c device
000290  a902              ADD      r1,sp,#8
000292  6820              LDR      r0,[r4,#0]
000294  f7fffffe          BL       I2C_Init
;;;158    	
;;;159    	//interrupt initialize
;;;160    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  //group 2
000298  f44f60a0          MOV      r0,#0x500
00029c  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;161    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  //Enable the IRQ channel
0002a0  2601              MOVS     r6,#1
0002a2  f88d6003          STRB     r6,[sp,#3]
;;;162    	
;;;163    	// Configure NVIC for I2Cx EVT Interrupt
;;;164    	NVIC_InitStructure.NVIC_IRQChannel = _evt_irqn;
0002a6  7e20              LDRB     r0,[r4,#0x18]
0002a8  f88d0000          STRB     r0,[sp,#0]
;;;165    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = _evt_preprio;
0002ac  7ee0              LDRB     r0,[r4,#0x1b]
0002ae  f88d0001          STRB     r0,[sp,#1]
;;;166    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = _evt_subprio;
0002b2  7ea0              LDRB     r0,[r4,#0x1a]
0002b4  f88d0002          STRB     r0,[sp,#2]
;;;167    	NVIC_Init(&NVIC_InitStructure);
0002b8  4668              MOV      r0,sp
0002ba  f7fffffe          BL       NVIC_Init
;;;168    	_i2c->CR2 |= I2C_CR2_ITEVTEN;//enable i2c event interrupt
0002be  6820              LDR      r0,[r4,#0]
0002c0  8881              LDRH     r1,[r0,#4]
0002c2  f4417100          ORR      r1,r1,#0x200
0002c6  8081              STRH     r1,[r0,#4]
;;;169    	
;;;170    	// Configure NVIC for I2Cx ERR Interrupt
;;;171    	NVIC_InitStructure.NVIC_IRQChannel = _err_irqn;
0002c8  7e60              LDRB     r0,[r4,#0x19]
0002ca  f88d0000          STRB     r0,[sp,#0]
;;;172    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = _err_preprio;
0002ce  7f60              LDRB     r0,[r4,#0x1d]
0002d0  f88d0001          STRB     r0,[sp,#1]
;;;173    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = _err_subprio;
0002d4  7f20              LDRB     r0,[r4,#0x1c]
0002d6  f88d0002          STRB     r0,[sp,#2]
;;;174    	NVIC_Init(&NVIC_InitStructure);
0002da  4668              MOV      r0,sp
0002dc  f7fffffe          BL       NVIC_Init
;;;175    	_i2c->CR2 |= I2C_CR2_ITERREN;//enable i2c error interrupt
0002e0  6820              LDR      r0,[r4,#0]
0002e2  8881              LDRH     r1,[r0,#4]
0002e4  f4417180          ORR      r1,r1,#0x100
0002e8  8081              STRH     r1,[r0,#4]
;;;176    	_i2c->CR2 |= I2C_IT_BUF;     //enable i2c buffer interrupt
0002ea  6820              LDR      r0,[r4,#0]
0002ec  8881              LDRH     r1,[r0,#4]
0002ee  f4416180          ORR      r1,r1,#0x400
0002f2  8081              STRH     r1,[r0,#4]
0002f4  f8a45342          STRH     r5,[r4,#0x342]
0002f8  f8a45344          STRH     r5,[r4,#0x344]
0002fc  f8a45346          STRH     r5,[r4,#0x346]
;;;177    	
;;;178    	ClearCommand();
;;;179    	_healthy = true;
000300  7466              STRB     r6,[r4,#0x11]
;;;180    }
000302  b006              ADD      sp,sp,#0x18
000304  bd70              POP      {r4-r6,pc}
;;;181    
                          ENDP

                  _ZN3IICC2EP11I2C_TypeDefjh                  ; Alternate entry point ; IIC::IIC__sub_object(I2C_TypeDef*, unsigned, unsigned char)
                  _ZN3IICC1EP11I2C_TypeDefjh PROC ; IIC::IIC(I2C_TypeDef*, unsigned, unsigned char)
;;;7      ///@param remap: gpio remap flag
;;;8      IIC::IIC(I2C_TypeDef* i2c, u32 speed, u8 remap)
;;;9      {
;;;10     	_i2c = i2c;          //i2c device
;;;11     	_i2c_speed = speed;  //speed of i2c bus
;;;12     	_gpio_remap = remap; //remap flag for i2c gpio pin
;;;13     	_evt_irq_cnt = 0;
;;;14     	
;;;15     	//set i2c pin, rcc, irq
;;;16     	if(_i2c==I2C1) //I2C1
;;;17     	{
;;;18     		if(_gpio_remap==1) //remap gpio pin for i2c pin
;;;19     		{
;;;20     			_scl_pin = GPIO_Pin_8; //SCL pin
;;;21     			_sda_pin = GPIO_Pin_9; //SDA pin
;;;22     		}
;;;23     		else if(_gpio_remap==0) //not remap gpio pin
;;;24     		{
;;;25     			_scl_pin = GPIO_Pin_6; //SCL pin
;;;26     			_sda_pin = GPIO_Pin_7; //SDA pin
;;;27     		}
;;;28     		_i2c_rcc = RCC_APB1Periph_I2C1; //i2c clock
;;;29     		_evt_irqn = I2C1_EV_IRQn;   //i2c event IRQn
;;;30     		_err_irqn = I2C1_ER_IRQn;   //i2c error IRQn
;;;31     		
;;;32     		#ifdef USE_I2C1
;;;33     		pI2C1 = (I2C *)this;
;;;34     		#endif
;;;35     	}
;;;36     	else if(_i2c==I2C2)//I2C2
;;;37     	{
;;;38     		_scl_pin = GPIO_Pin_10; //SCL pin
;;;39     		_sda_pin = GPIO_Pin_11; //SDA pin
;;;40     		_i2c_rcc = RCC_APB1Periph_I2C2; //i2c clock
;;;41     		_evt_irqn = I2C2_EV_IRQn;   //i2c event IRQn
;;;42     		_err_irqn = I2C2_ER_IRQn;   //i2c error IRQn
;;;43     		
;;;44     		#ifdef USE_I2C2
;;;45     		pI2C2 = this;
;;;46     		#endif
;;;47     	}
;;;48     	//interrupt priority
;;;49     	_evt_subprio = 0;    //i2c event interrupt sub priority
;;;50     	_evt_preprio = 1;    //i2c event interrupt preemption priority
;;;51     	_err_subprio = 0;    //i2c error interrupt sub priority
;;;52     	_err_preprio = 0;    //i2c error interrupt preemption priority
;;;53     	
;;;54     	Initialize();
;;;55     }
;;;56     
000306  b510              PUSH     {r4,lr}
000308  4604              MOV      r4,r0
00030a  3020              ADDS     r0,r0,#0x20
00030c  f04f0c32          MOV      r12,#0x32
000310  f8a0c320          STRH     r12,[r0,#0x320]
000314  f04f0c00          MOV      r12,#0
000318  f8a0c322          STRH     r12,[r0,#0x322]
00031c  f8a0c324          STRH     r12,[r0,#0x324]
000320  f8a0c326          STRH     r12,[r0,#0x326]
000324  e9c41200          STRD     r1,r2,[r4,#0]
000328  7423              STRB     r3,[r4,#0x10]
00032a  f1a14080          SUB      r0,r1,#0x40000000
00032e  f8c4c014          STR      r12,[r4,#0x14]
000332  f5b040a8          SUBS     r0,r0,#0x5400
000336  d003              BEQ      |L1.832|
000338  f5b06080          SUBS     r0,r0,#0x400
00033c  d017              BEQ      |L1.878|
00033e  e021              B        |L1.900|
                  |L1.832|
000340  2b01              CMP      r3,#1
000342  d001              BEQ      |L1.840|
000344  b12b              CBZ      r3,|L1.850|
000346  e008              B        |L1.858|
                  |L1.840|
000348  f44f7080          MOV      r0,#0x100
00034c  8120              STRH     r0,[r4,#8]
00034e  0040              LSLS     r0,r0,#1
000350  e002              B        |L1.856|
                  |L1.850|
000352  2040              MOVS     r0,#0x40
000354  8120              STRH     r0,[r4,#8]
000356  2080              MOVS     r0,#0x80
                  |L1.856|
000358  8160              STRH     r0,[r4,#0xa]
                  |L1.858|
00035a  f44f1000          MOV      r0,#0x200000
00035e  60e0              STR      r0,[r4,#0xc]
000360  201f              MOVS     r0,#0x1f
000362  7620              STRB     r0,[r4,#0x18]
000364  2020              MOVS     r0,#0x20
000366  7660              STRB     r0,[r4,#0x19]
000368  4830              LDR      r0,|L1.1068|
00036a  6004              STR      r4,[r0,#0]  ; pI2C1
00036c  e00a              B        |L1.900|
                  |L1.878|
00036e  f44f6080          MOV      r0,#0x400
000372  8120              STRH     r0,[r4,#8]
000374  0040              LSLS     r0,r0,#1
000376  8160              STRH     r0,[r4,#0xa]
000378  02c0              LSLS     r0,r0,#11
00037a  60e0              STR      r0,[r4,#0xc]
00037c  2021              MOVS     r0,#0x21
00037e  7620              STRB     r0,[r4,#0x18]
000380  2022              MOVS     r0,#0x22
000382  7660              STRB     r0,[r4,#0x19]
                  |L1.900|
000384  f884c01a          STRB     r12,[r4,#0x1a]
000388  2001              MOVS     r0,#1
00038a  76e0              STRB     r0,[r4,#0x1b]
00038c  f884c01c          STRB     r12,[r4,#0x1c]
000390  f884c01d          STRB     r12,[r4,#0x1d]
000394  4620              MOV      r0,r4
000396  f7fffffe          BL       _ZN3IIC10InitializeEv ; IIC::Initialize()
00039a  4620              MOV      r0,r4
00039c  bd10              POP      {r4,pc}
                          ENDP

                  _ZN3IIC16StartNextCommandEv PROC ; IIC::StartNextCommand()
;;;189    //get one i2c command from i2c command queue
;;;190    bool IIC::StartNextCommand()
00039e  2200              MOVS     r2,#0
0003a0  6142              STR      r2,[r0,#0x14]
0003a2  f8b0c342          LDRH     r12,[r0,#0x342]
;;;191    {
;;;192    	_evt_irq_cnt = 0;   //reset event interrupt counter
;;;193    	if(_i2c_cmd_queue.Get(_current_cmd))//get next i2c command
0003a6  f1000120          ADD      r1,r0,#0x20
0003aa  f5007352          ADD      r3,r0,#0x348
0003ae  f1bc0f00          CMP      r12,#0
;;;194    	{
;;;195    		_i2c_tx_cnt = 0; //clear tx counter
;;;196    		_i2c_rx_cnt = 0; //clear rx counter
;;;197    		if(_current_cmd.cmdType == OUT2IN) //ist transmit, then turn to receive
;;;198    			_i2c_direction = I2C_Direction_Transmitter;
;;;199    		else  //IN2OUT: 1st receive, then turn to transmit
;;;200    			_i2c_direction = I2C_Direction_Receiver;
;;;201    		
;;;202    		I2C_GenerateSTART(_i2c,ENABLE); //to generate I2C Start signal
;;;203    		return true;
;;;204    	}
;;;205    	return false; 
0003b2  bf04              ITT      EQ
0003b4  2000              MOVEQ    r0,#0
;;;206    }
0003b6  4770              BXEQ     lr
0003b8  b570              PUSH     {r4-r6,lr}            ;191
0003ba  f8b1c324          LDRH     r12,[r1,#0x324]       ;191
0003be  eb01140c          ADD      r4,r1,r12,LSL #4      ;191
0003c2  f10c0c01          ADD      r12,r12,#1            ;191
0003c6  f8a1c324          STRH     r12,[r1,#0x324]       ;191
0003ca  e8941070          LDM      r4,{r4-r6,r12}        ;191
0003ce  e8831070          STM      r3,{r4-r6,r12}        ;191
0003d2  f8b13324          LDRH     r3,[r1,#0x324]        ;191
0003d6  f8b1c320          LDRH     r12,[r1,#0x320]       ;191
0003da  4563              CMP      r3,r12                ;191
0003dc  bf28              IT       CS                    ;191
0003de  f8a12324          STRHCS   r2,[r1,#0x324]        ;191
0003e2  f8b13322          LDRH     r3,[r1,#0x322]        ;191
0003e6  1e5b              SUBS     r3,r3,#1              ;191
0003e8  f8a13322          STRH     r3,[r1,#0x322]        ;191
0003ec  f8802359          STRB     r2,[r0,#0x359]        ;195
0003f0  f880235a          STRB     r2,[r0,#0x35a]        ;196
0003f4  f8903348          LDRB     r3,[r0,#0x348]        ;197
0003f8  2101              MOVS     r1,#1                 ;197
0003fa  2b01              CMP      r3,#1                 ;197
0003fc  bf0c              ITE      EQ                    ;198
0003fe  f8802358          STRBEQ   r2,[r0,#0x358]        ;198
000402  f8801358          STRBNE   r1,[r0,#0x358]        ;200
000406  6800              LDR      r0,[r0,#0]            ;202
000408  2101              MOVS     r1,#1                 ;202
00040a  f7fffffe          BL       I2C_GenerateSTART
00040e  2001              MOVS     r0,#1                 ;203
000410  bd70              POP      {r4-r6,pc}
;;;207    
                          ENDP

                  _ZN3IIC5ResetEv PROC ; IIC::Reset()
;;;182    //software reset i2c bus
;;;183    void IIC::Reset()
000412  6801              LDR      r1,[r0,#0]
;;;184    {
;;;185    	_i2c->CR1 |= I2C_CR1_SWRST;  //set reset bit
000414  880a              LDRH     r2,[r1,#0]
000416  f4424200          ORR      r2,r2,#0x8000
00041a  800a              STRH     r2,[r1,#0]
;;;186    	_i2c->CR1 &= ~I2C_CR1_SWRST; //clear reset bit
00041c  6800              LDR      r0,[r0,#0]
00041e  8801              LDRH     r1,[r0,#0]
000420  f4214100          BIC      r1,r1,#0x8000
000424  8001              STRH     r1,[r0,#0]
;;;187    }
000426  4770              BX       lr
                  |L1.1064|
                          DCD      0x40010c00
                  |L1.1068|
                          DCD      pI2C1
                          ENDP

                  _ZN3IIC10AddCommandEh12IIC_CMD_TypePhhS1_h PROC ; IIC::AddCommand(unsigned char, IIC_CMD_Type, unsigned char*, unsigned char, unsigned char*, unsigned char)
;;;210    //add one i2c command to command queue
;;;211    bool IIC::AddCommand(u8 slaveAddr, IIC_CMD_Type cmdType, u8 *pTxData, u8 txNum, u8 *pRxData, u8 rxNum)
000430  b4f0              PUSH     {r4-r7}
;;;212    {
000432  b084              SUB      sp,sp,#0x10
;;;213    	IIC_Command cmd;
000434  466f              MOV      r7,sp
000436  e9dd6408          LDRD     r6,r4,[sp,#0x20]      ;212
;;;214    	cmd.slaveAddr = slaveAddr;  //slave i2c address
00043a  f8ddc028          LDR      r12,[sp,#0x28]
;;;215    	cmd.cmdType = cmdType;      //i2c command type	
;;;216    	cmd.outDataLen = txNum;	    //number of bytes send to slave
;;;217    	cmd.inDataLen = rxNum;      //number of bytes to recieve from slave
00043e  f88dc00c          STRB     r12,[sp,#0xc]
000442  f88d1001          STRB     r1,[sp,#1]            ;214
;;;218    	cmd.pDataIn = pRxData;		  //ponter to receive data from slave
;;;219    	for(u8 i=0; i<txNum; i++)   //data send to slave
000446  f1a60c01          SUB      r12,r6,#1
00044a  f88d2000          STRB     r2,[sp,#0]            ;215
00044e  f88d6007          STRB     r6,[sp,#7]            ;216
000452  9402              STR      r4,[sp,#8]
000454  f1bc0f00          CMP      r12,#0
000458  dd17              BLE      |L1.1162|
00045a  1e59              SUBS     r1,r3,#1
00045c  1c7a              ADDS     r2,r7,#1
;;;220    		cmd.DataOut[i] = pTxData[i];
;;;221    	return _i2c_cmd_queue.Put(cmd); //add to command queue
;;;222    }
00045e  f0160f01          TST      r6,#1
000462  d104              BNE      |L1.1134|
000464  f8114f01          LDRB     r4,[r1,#1]!           ;220
000468  f88d4002          STRB     r4,[sp,#2]            ;220
00046c  1c52              ADDS     r2,r2,#1              ;220
                  |L1.1134|
00046e  784c              LDRB     r4,[r1,#1]
000470  ea5f0c6c          ASRS     r12,r12,#1            ;219
000474  d009              BEQ      |L1.1162|
000476  bf00              NOP      
                  |L1.1144|
000478  f8115f02          LDRB     r5,[r1,#2]!
00047c  7054              STRB     r4,[r2,#1]            ;220
00047e  784c              LDRB     r4,[r1,#1]            ;220
000480  f8025f02          STRB     r5,[r2,#2]!           ;220
000484  f1bc0c01          SUBS     r12,r12,#1            ;220
000488  d1f6              BNE      |L1.1144|
                  |L1.1162|
00048a  1e71              SUBS     r1,r6,#1              ;220
00048c  d402              BMI      |L1.1172|
00048e  5c5a              LDRB     r2,[r3,r1]            ;220
000490  4439              ADD      r1,r1,r7              ;220
000492  708a              STRB     r2,[r1,#2]            ;220
                  |L1.1172|
000494  f8b01342          LDRH     r1,[r0,#0x342]        ;220
000498  f8b02340          LDRH     r2,[r0,#0x340]        ;220
00049c  3020              ADDS     r0,r0,#0x20           ;220
00049e  4291              CMP      r1,r2                 ;220
0004a0  bf21              ITTTT    CS                    ;220
0004a2  2000              MOVCS    r0,#0                 ;220
0004a4  b004              ADDCS    sp,sp,#0x10
0004a6  bcf0              POPCS    {r4-r7}
0004a8  4770              BXCS     lr
0004aa  f8b01326          LDRH     r1,[r0,#0x326]
0004ae  eb001201          ADD      r2,r0,r1,LSL #4
0004b2  1c49              ADDS     r1,r1,#1
0004b4  f8a01326          STRH     r1,[r0,#0x326]
0004b8  e89d101a          LDM      sp,{r1,r3,r4,r12}
0004bc  e882101a          STM      r2,{r1,r3,r4,r12}
0004c0  f8b01326          LDRH     r1,[r0,#0x326]
0004c4  f8b02320          LDRH     r2,[r0,#0x320]
0004c8  4291              CMP      r1,r2
0004ca  bf24              ITT      CS
0004cc  2100              MOVCS    r1,#0
0004ce  f8a01326          STRHCS   r1,[r0,#0x326]
0004d2  f8b01322          LDRH     r1,[r0,#0x322]
0004d6  1c49              ADDS     r1,r1,#1
0004d8  f8a01322          STRH     r1,[r0,#0x322]
0004dc  b004              ADD      sp,sp,#0x10
0004de  2001              MOVS     r0,#1
0004e0  bcf0              POP      {r4-r7}
0004e2  4770              BX       lr
;;;223    //clear all i2c commands in queue
                          ENDP

                  _ZN3IIC8EventIRQEv PROC ; IIC::EventIRQ()
;;;229    //i2c event interrupt handler
;;;230    void IIC::EventIRQ(void)
0004e4  b570              PUSH     {r4-r6,lr}
;;;231    {
0004e6  4604              MOV      r4,r0
;;;232    	u32 I2C_Status = I2C_GetLastEvent(_i2c);
0004e8  6800              LDR      r0,[r0,#0]
0004ea  f7fffffe          BL       I2C_GetLastEvent
;;;233    	switch(I2C_Status)
0004ee  4a5a              LDR      r2,|L1.1624|
0004f0  2500              MOVS     r5,#0
0004f2  1a81              SUBS     r1,r0,r2
0004f4  4290              CMP      r0,r2
0004f6  d02e              BEQ      |L1.1366|
0004f8  dc0a              BGT      |L1.1296|
0004fa  f46f3140          MVN      r1,#0x30000
0004fe  1840              ADDS     r0,r0,r1
000500  d012              BEQ      |L1.1320|
000502  2801              CMP      r0,#1
;;;234    	{
;;;235    		//after I2C_GenerateSTART(), need to send slave address and write/read bit
;;;236    		case I2C_EVENT_MASTER_MODE_SELECT:
;;;237    			I2C_AcknowledgeConfig(_i2c,ENABLE);
;;;238    			I2C_Send7bitAddress(_i2c, _current_cmd.slaveAddr, _i2c_direction);
;;;239          _i2c_tx_cnt = 0;
;;;240    			_i2c_rx_cnt = 0;
;;;241    			break;
;;;242    		
;;;243    		//after I2C_Send7bitAddress(addr+write), need to send data to slave
;;;244    		case I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED:
;;;245    			I2C_SendData(_i2c,_current_cmd.DataOut[_i2c_tx_cnt++]);//send one byte data
;;;246    			break;
;;;247    		//after I2C_Send7bitAddress(addr+read)
;;;248    		case I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED:
;;;249    			if(_current_cmd.inDataLen == 1) //if only read one byte data
000504  bf04              ITT      EQ
000506  f8940354          LDRBEQ   r0,[r4,#0x354]
00050a  2801              CMPEQ    r0,#1
00050c  d01c              BEQ      |L1.1352|
00050e  e077              B        |L1.1536|
                  |L1.1296|
000510  f5a12080          SUB      r0,r1,#0x40000        ;233
000514  3842              SUBS     r0,r0,#0x42           ;233
000516  f204314a          ADD      r1,r4,#0x34a          ;245
00051a  bf08              IT       EQ                    ;245
00051c  f8940359          LDRBEQ   r0,[r4,#0x359]        ;245
000520  d067              BEQ      |L1.1522|
000522  2802              CMP      r0,#2                 ;233
000524  d047              BEQ      |L1.1462|
000526  e06b              B        |L1.1536|
                  |L1.1320|
000528  2101              MOVS     r1,#1                 ;237
00052a  6820              LDR      r0,[r4,#0]            ;237
00052c  f7fffffe          BL       I2C_AcknowledgeConfig
000530  f8942358          LDRB     r2,[r4,#0x358]        ;238
000534  f8941349          LDRB     r1,[r4,#0x349]        ;238
000538  6820              LDR      r0,[r4,#0]            ;238
00053a  f7fffffe          BL       I2C_Send7bitAddress
00053e  f8845359          STRB     r5,[r4,#0x359]        ;239
000542  f884535a          STRB     r5,[r4,#0x35a]        ;240
000546  e05b              B        |L1.1536|
                  |L1.1352|
;;;250    			{
;;;251    				I2C_AcknowledgeConfig(_i2c,DISABLE); //NO ACK
000548  2100              MOVS     r1,#0
00054a  6820              LDR      r0,[r4,#0]
00054c  f7fffffe          BL       I2C_AcknowledgeConfig
;;;252    				I2C_GenerateSTOP(_i2c,ENABLE);       //generate STOP signal
000550  2101              MOVS     r1,#1
000552  6820              LDR      r0,[r4,#0]
000554  e018              B        |L1.1416|
                  |L1.1366|
;;;253    			}
;;;254    			break;
;;;255    			
;;;256    		//Receive mode, and new byte arrived, need to receive data
;;;257    		case I2C_EVENT_MASTER_BYTE_RECEIVED:
;;;258    			_current_cmd.pDataIn[_i2c_rx_cnt++] = I2C_ReceiveData(_i2c); //receive one byte data
000556  6820              LDR      r0,[r4,#0]
000558  f7fffffe          BL       I2C_ReceiveData
00055c  4601              MOV      r1,r0
00055e  f894035a          LDRB     r0,[r4,#0x35a]
000562  f8d43350          LDR      r3,[r4,#0x350]
000566  1c42              ADDS     r2,r0,#1
000568  f884235a          STRB     r2,[r4,#0x35a]
00056c  5419              STRB     r1,[r3,r0]
;;;259    			if(_i2c_rx_cnt == _current_cmd.inDataLen-1)//only one byte data left to receive
00056e  f8940354          LDRB     r0,[r4,#0x354]
000572  f894135a          LDRB     r1,[r4,#0x35a]
000576  1e42              SUBS     r2,r0,#1
000578  4291              CMP      r1,r2
00057a  d108              BNE      |L1.1422|
;;;260    			{
;;;261    				I2C_AcknowledgeConfig(_i2c,DISABLE); //NO ACK
00057c  2100              MOVS     r1,#0
00057e  6820              LDR      r0,[r4,#0]
000580  f7fffffe          BL       I2C_AcknowledgeConfig
;;;262    				I2C_GenerateSTOP(I2C2,ENABLE);		   //generate STOP signal
000584  2101              MOVS     r1,#1
000586  4835              LDR      r0,|L1.1628|
                  |L1.1416|
000588  f7fffffe          BL       I2C_GenerateSTOP
00058c  e038              B        |L1.1536|
                  |L1.1422|
;;;263    			}
;;;264    			else if(_i2c_rx_cnt == _current_cmd.inDataLen)//all bytes of data is received
00058e  4281              CMP      r1,r0
000590  d136              BNE      |L1.1536|
;;;265    			{
;;;266    				//1st in then out, and need to send data
;;;267    				if(_current_cmd.cmdType==IN2OUT && _current_cmd.outDataLen>0)//need to switch to transmit mode
000592  f8940348          LDRB     r0,[r4,#0x348]
000596  2802              CMP      r0,#2
000598  d109              BNE      |L1.1454|
00059a  f894034f          LDRB     r0,[r4,#0x34f]
00059e  b130              CBZ      r0,|L1.1454|
;;;268    				{
;;;269    					_i2c_direction = I2C_Direction_Transmitter; //switch to transmit mode
0005a0  f8845358          STRB     r5,[r4,#0x358]
;;;270    					I2C_GenerateSTART(_i2c,ENABLE);         //generate START signal
0005a4  2101              MOVS     r1,#1
0005a6  6820              LDR      r0,[r4,#0]
0005a8  f7fffffe          BL       I2C_GenerateSTART
0005ac  e028              B        |L1.1536|
                  |L1.1454|
;;;271    				}
;;;272    				else //OUT2IN, current i2c command is complete
;;;273    				{
;;;274    					StartNextCommand(); //perform next i2c command
0005ae  4620              MOV      r0,r4
0005b0  f7fffffe          BL       _ZN3IIC16StartNextCommandEv ; IIC::StartNextCommand()
0005b4  e024              B        |L1.1536|
                  |L1.1462|
;;;275    				}
;;;276    			}
;;;277    			break;
;;;278    		
;;;279    		//transmit mode, and one byte transmit completed
;;;280    		case I2C_EVENT_MASTER_BYTE_TRANSMITTED:
;;;281    			if(_i2c_tx_cnt >= _current_cmd.outDataLen)//data transmit is completed
0005b6  f8940359          LDRB     r0,[r4,#0x359]
0005ba  f894234f          LDRB     r2,[r4,#0x34f]
0005be  4290              CMP      r0,r2
0005c0  d317              BCC      |L1.1522|
;;;282    			{
;;;283    				//current command is completed
;;;284    				if(_current_cmd.cmdType == IN2OUT)
0005c2  f8940348          LDRB     r0,[r4,#0x348]
0005c6  2802              CMP      r0,#2
;;;285    				{
;;;286    					I2C_GenerateSTOP(_i2c,ENABLE);
;;;287    					StartNextCommand(); //switch to next command
;;;288    				}
;;;289    				else  //cmdType == OUT2IN
;;;290    				{
;;;291    					if(_current_cmd.inDataLen==0)//no data to read
0005c8  bf1c              ITT      NE
0005ca  f8940354          LDRBNE   r0,[r4,#0x354]
0005ce  2800              CMPNE    r0,#0
0005d0  d007              BEQ      |L1.1506|
;;;292    					{
;;;293    						I2C_GenerateSTOP(_i2c,ENABLE);
;;;294    						StartNextCommand(); //switch to next command
;;;295    					}
;;;296    					else //need to read data from slave
;;;297    					{
;;;298    						_i2c_direction = I2C_Direction_Receiver;	//switch to receiver mode
0005d2  2001              MOVS     r0,#1
0005d4  f8840358          STRB     r0,[r4,#0x358]
;;;299    						I2C_GenerateSTART(_i2c,ENABLE);    //generate start signal
0005d8  2101              MOVS     r1,#1
0005da  6820              LDR      r0,[r4,#0]
0005dc  f7fffffe          BL       I2C_GenerateSTART
0005e0  e00e              B        |L1.1536|
                  |L1.1506|
0005e2  2101              MOVS     r1,#1                 ;286
0005e4  6820              LDR      r0,[r4,#0]            ;286
0005e6  f7fffffe          BL       I2C_GenerateSTOP
0005ea  4620              MOV      r0,r4                 ;287
0005ec  f7fffffe          BL       _ZN3IIC16StartNextCommandEv ; IIC::StartNextCommand()
0005f0  e006              B        |L1.1536|
                  |L1.1522|
;;;300    					}
;;;301    				}
;;;302    			}
;;;303    			else//still have data need to transmit
;;;304    			{
;;;305    				I2C_SendData(_i2c, _current_cmd.DataOut[_i2c_tx_cnt++]);//·¢ËÍÊý¾Ý
0005f2  1c42              ADDS     r2,r0,#1
0005f4  f8842359          STRB     r2,[r4,#0x359]
0005f8  5c41              LDRB     r1,[r0,r1]
0005fa  6820              LDR      r0,[r4,#0]
0005fc  f7fffffe          BL       I2C_SendData
                  |L1.1536|
;;;306    			}
;;;307    			break;
;;;308    	}
;;;309    	//event irq dead detect
;;;310    	if(++_evt_irq_cnt>50)
000600  6960              LDR      r0,[r4,#0x14]
000602  1c40              ADDS     r0,r0,#1
000604  6160              STR      r0,[r4,#0x14]
000606  2832              CMP      r0,#0x32
;;;311    	{
;;;312    		_healthy = false;
;;;313    		Reset();
;;;314    	}
;;;315    }	
000608  bf98              IT       LS
00060a  bd70              POPLS    {r4-r6,pc}
00060c  7465              STRB     r5,[r4,#0x11]         ;312
00060e  6820              LDR      r0,[r4,#0]            ;312
000610  8801              LDRH     r1,[r0,#0]            ;312
000612  f4414100          ORR      r1,r1,#0x8000         ;312
000616  8001              STRH     r1,[r0,#0]            ;312
000618  6820              LDR      r0,[r4,#0]            ;312
00061a  8801              LDRH     r1,[r0,#0]            ;312
00061c  f4214100          BIC      r1,r1,#0x8000         ;312
000620  8001              STRH     r1,[r0,#0]            ;312
000622  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP

                  _ZN3IIC8ErrorIRQEv PROC ; IIC::ErrorIRQ()
;;;317    //i2c error interrupt handler
;;;318    void IIC::ErrorIRQ()     
000624  6801              LDR      r1,[r0,#0]
;;;319    {
;;;320    	//_i2c->SR1 = ~((uint16_t)0x0F00);
;;;321    	//Reset();
;;;322    	_i2c->CR1 |= I2C_CR1_SWRST;  //set reset bit
000626  880a              LDRH     r2,[r1,#0]
000628  f4424200          ORR      r2,r2,#0x8000
00062c  800a              STRH     r2,[r1,#0]
;;;323    	_i2c->CR1 &= ~I2C_CR1_SWRST; //clear reset bit
00062e  6801              LDR      r1,[r0,#0]
000630  880a              LDRH     r2,[r1,#0]
000632  f4224200          BIC      r2,r2,#0x8000
000636  800a              STRH     r2,[r1,#0]
;;;324    	
;;;325    	_healthy = false;
000638  2100              MOVS     r1,#0
00063a  7441              STRB     r1,[r0,#0x11]
;;;326    	//SPI1->CR1 = 1;
;;;327    	//for(u32 i=0;i<10000;i++) ;
;;;328    	//USART1->DR = 'X';  //I dont know why,
;;;329    }
00063c  4770              BX       lr
;;;330    //check if i2c is work correctly
                          ENDP

                  _ZN3IIC16IsWorkingAndFreeEv PROC ; IIC::IsWorkingAndFree()
;;;331    bool IIC::IsWorkingAndFree()
00063e  b510              PUSH     {r4,lr}
;;;332    {
;;;333    	return (_healthy && (I2C_GetLastEvent(_i2c)==0));
000640  7c41              LDRB     r1,[r0,#0x11]
000642  b131              CBZ      r1,|L1.1618|
000644  6800              LDR      r0,[r0,#0]
000646  f7fffffe          BL       I2C_GetLastEvent
00064a  2800              CMP      r0,#0
00064c  bf04              ITT      EQ
00064e  2001              MOVEQ    r0,#1
;;;334    }
000650  bd10              POPEQ    {r4,pc}
                  |L1.1618|
000652  2000              MOVS     r0,#0                 ;333
000654  bd10              POP      {r4,pc}
;;;335    
                          ENDP

000656  0000              DCW      0x0000
                  |L1.1624|
                          DCD      0x00030040
                  |L1.1628|
                          DCD      0x40005800

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001
