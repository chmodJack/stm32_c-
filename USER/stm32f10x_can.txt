; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\obj\stm32f10x_can.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\stm32f10x_can.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime -I..\CORE -I..\STM32F10x_FWLIB\inc -I..\USER -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\C++LIB\OnChip\GPIO -I..\C++LIB\ToolBox\Buffer -I..\C++LIB\System -I..\C++LIB\OnChip\IIC -I..\C++LIB\OffChip -I..\C++LIB\System\TaskManager -I..\C++LIB\System\Interrupt -I..\C++LIB\OnChip\SerialPort -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -W --omf_browse=..\obj\stm32f10x_can.crf ..\STM32F10x_FWLIB\src\stm32f10x_can.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;121      */
;;;122    void CAN_DeInit(CAN_TypeDef* CANx)
000000  f1a04180          SUB      r1,r0,#0x40000000
;;;123    {
000004  b510              PUSH     {r4,lr}
;;;124      /* Check the parameters */
;;;125      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;126     
;;;127      if (CANx == CAN1)
000006  f5b141c8          SUBS     r1,r1,#0x6400
;;;128      {
;;;129        /* Enable CAN1 reset state */
;;;130        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
;;;131        /* Release CAN1 from reset state */
;;;132        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
;;;133      }
;;;134      else
;;;135      {  
;;;136        /* Enable CAN2 reset state */
;;;137        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00000a  f04f0101          MOV      r1,#1
00000e  d009              BEQ      |L1.36|
000010  0688              LSLS     r0,r1,#26
000012  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;138        /* Release CAN2 from reset state */
;;;139        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
000016  e8bd4010          POP      {r4,lr}
00001a  2100              MOVS     r1,#0
00001c  f04f6080          MOV      r0,#0x4000000
000020  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.36|
000024  f04f7000          MOV      r0,#0x2000000         ;130
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
00002c  e8bd4010          POP      {r4,lr}               ;132
000030  2100              MOVS     r1,#0                 ;132
000032  f04f7000          MOV      r0,#0x2000000         ;132
000036  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;140      }
;;;141    }
;;;142    
                          ENDP

                  CAN_Init PROC
;;;153      */
;;;154    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
00003a  6802              LDR      r2,[r0,#0]
;;;155    {
;;;156      uint8_t InitStatus = CAN_InitStatus_Failed;
;;;157      uint32_t wait_ack = 0x00000000;
00003c  2300              MOVS     r3,#0
;;;158      /* Check the parameters */
;;;159      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;160      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;161      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;162      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;163      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;164      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;165      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;166      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;167      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;168      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;169      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;170      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;171    
;;;172      /* Exit from sleep mode */
;;;173      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
00003e  f0220202          BIC      r2,r2,#2
000042  6002              STR      r2,[r0,#0]
;;;174    
;;;175      /* Request initialisation */
;;;176      CANx->MCR |= CAN_MCR_INRQ ;
000044  6802              LDR      r2,[r0,#0]
000046  f0420201          ORR      r2,r2,#1
00004a  6002              STR      r2,[r0,#0]
;;;177    
;;;178      /* Wait the acknowledge */
;;;179      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
;;;180      {
;;;181        wait_ack++;
00004c  f64f72ff          MOV      r2,#0xffff
                  |L1.80|
000050  f8d0c004          LDR      r12,[r0,#4]
000054  f01c0f01          TST      r12,#1
000058  d103              BNE      |L1.98|
00005a  4293              CMP      r3,r2
00005c  bf18              IT       NE
00005e  1c5b              ADDNE    r3,r3,#1
000060  d1f6              BNE      |L1.80|
                  |L1.98|
;;;182      }
;;;183    
;;;184      /* Check acknowledge */
;;;185      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
000062  6843              LDR      r3,[r0,#4]
000064  f0130f01          TST      r3,#1
000068  d059              BEQ      |L1.286|
;;;186      {
;;;187        InitStatus = CAN_InitStatus_Failed;
;;;188      }
;;;189      else 
;;;190      {
;;;191        /* Set the time triggered communication mode */
;;;192        if (CAN_InitStruct->CAN_TTCM == ENABLE)
00006a  798b              LDRB     r3,[r1,#6]
00006c  2b01              CMP      r3,#1
;;;193        {
;;;194          CANx->MCR |= CAN_MCR_TTCM;
;;;195        }
;;;196        else
;;;197        {
;;;198          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
00006e  6803              LDR      r3,[r0,#0]
000070  bf0c              ITE      EQ                    ;194
000072  f0430380          ORREQ    r3,r3,#0x80           ;194
000076  f0230380          BICNE    r3,r3,#0x80
00007a  6003              STR      r3,[r0,#0]
;;;199        }
;;;200    
;;;201        /* Set the automatic bus-off management */
;;;202        if (CAN_InitStruct->CAN_ABOM == ENABLE)
00007c  79cb              LDRB     r3,[r1,#7]
00007e  2b01              CMP      r3,#1
;;;203        {
;;;204          CANx->MCR |= CAN_MCR_ABOM;
;;;205        }
;;;206        else
;;;207        {
;;;208          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000080  6803              LDR      r3,[r0,#0]
000082  bf0c              ITE      EQ                    ;204
000084  f0430340          ORREQ    r3,r3,#0x40           ;204
000088  f0230340          BICNE    r3,r3,#0x40
00008c  6003              STR      r3,[r0,#0]
;;;209        }
;;;210    
;;;211        /* Set the automatic wake-up mode */
;;;212        if (CAN_InitStruct->CAN_AWUM == ENABLE)
00008e  7a0b              LDRB     r3,[r1,#8]
000090  2b01              CMP      r3,#1
;;;213        {
;;;214          CANx->MCR |= CAN_MCR_AWUM;
;;;215        }
;;;216        else
;;;217        {
;;;218          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
000092  6803              LDR      r3,[r0,#0]
000094  bf0c              ITE      EQ                    ;214
000096  f0430320          ORREQ    r3,r3,#0x20           ;214
00009a  f0230320          BICNE    r3,r3,#0x20
00009e  6003              STR      r3,[r0,#0]
;;;219        }
;;;220    
;;;221        /* Set the no automatic retransmission */
;;;222        if (CAN_InitStruct->CAN_NART == ENABLE)
0000a0  7a4b              LDRB     r3,[r1,#9]
0000a2  2b01              CMP      r3,#1
;;;223        {
;;;224          CANx->MCR |= CAN_MCR_NART;
;;;225        }
;;;226        else
;;;227        {
;;;228          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
0000a4  6803              LDR      r3,[r0,#0]
0000a6  bf0c              ITE      EQ                    ;224
0000a8  f0430310          ORREQ    r3,r3,#0x10           ;224
0000ac  f0230310          BICNE    r3,r3,#0x10
0000b0  6003              STR      r3,[r0,#0]
;;;229        }
;;;230    
;;;231        /* Set the receive FIFO locked mode */
;;;232        if (CAN_InitStruct->CAN_RFLM == ENABLE)
0000b2  7a8b              LDRB     r3,[r1,#0xa]
0000b4  2b01              CMP      r3,#1
;;;233        {
;;;234          CANx->MCR |= CAN_MCR_RFLM;
;;;235        }
;;;236        else
;;;237        {
;;;238          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
0000b6  6803              LDR      r3,[r0,#0]
0000b8  bf0c              ITE      EQ                    ;234
0000ba  f0430308          ORREQ    r3,r3,#8              ;234
0000be  f0230308          BICNE    r3,r3,#8
0000c2  6003              STR      r3,[r0,#0]
;;;239        }
;;;240    
;;;241        /* Set the transmit FIFO priority */
;;;242        if (CAN_InitStruct->CAN_TXFP == ENABLE)
0000c4  7acb              LDRB     r3,[r1,#0xb]
0000c6  2b01              CMP      r3,#1
;;;243        {
;;;244          CANx->MCR |= CAN_MCR_TXFP;
;;;245        }
;;;246        else
;;;247        {
;;;248          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
0000c8  6803              LDR      r3,[r0,#0]
0000ca  bf0c              ITE      EQ                    ;244
0000cc  f0430304          ORREQ    r3,r3,#4              ;244
0000d0  f0230304          BICNE    r3,r3,#4
0000d4  6003              STR      r3,[r0,#0]
;;;249        }
;;;250    
;;;251        /* Set the bit timing register */
;;;252        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
0000d6  788b              LDRB     r3,[r1,#2]
0000d8  f891c003          LDRB     r12,[r1,#3]
0000dc  079b              LSLS     r3,r3,#30
0000de  ea43630c          ORR      r3,r3,r12,LSL #24
0000e2  f891c004          LDRB     r12,[r1,#4]
0000e6  ea43430c          ORR      r3,r3,r12,LSL #16
0000ea  f891c005          LDRB     r12,[r1,#5]
0000ee  8809              LDRH     r1,[r1,#0]
0000f0  ea43530c          ORR      r3,r3,r12,LSL #20
0000f4  1e49              SUBS     r1,r1,#1
0000f6  4319              ORRS     r1,r1,r3
0000f8  61c1              STR      r1,[r0,#0x1c]
;;;253                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;254                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;255                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;256                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;257    
;;;258        /* Request leave initialisation */
;;;259        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
0000fa  6801              LDR      r1,[r0,#0]
0000fc  f0210101          BIC      r1,r1,#1
000100  6001              STR      r1,[r0,#0]
;;;260    
;;;261       /* Wait the acknowledge */
;;;262       wait_ack = 0;
000102  2100              MOVS     r1,#0
                  |L1.260|
;;;263    
;;;264       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
;;;265       {
;;;266         wait_ack++;
000104  6843              LDR      r3,[r0,#4]
000106  f0130f01          TST      r3,#1
00010a  bf1c              ITT      NE
00010c  4291              CMPNE    r1,r2
00010e  1c49              ADDNE    r1,r1,#1
000110  d1f8              BNE      |L1.260|
;;;267       }
;;;268    
;;;269        /* ...and check acknowledged */
;;;270        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
000112  6840              LDR      r0,[r0,#4]
000114  f0100f01          TST      r0,#1
;;;271        {
;;;272          InitStatus = CAN_InitStatus_Failed;
;;;273        }
;;;274        else
;;;275        {
;;;276          InitStatus = CAN_InitStatus_Success ;
000118  bf04              ITT      EQ
00011a  2001              MOVEQ    r0,#1
;;;277        }
;;;278      }
;;;279    
;;;280      /* At this step, return the status of initialization */
;;;281      return InitStatus;
;;;282    }
00011c  4770              BXEQ     lr
                  |L1.286|
00011e  2000              MOVS     r0,#0                 ;187
000120  4770              BX       lr
;;;283    
                          ENDP

                  CAN_FilterInit PROC
;;;291      */
;;;292    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000122  b430              PUSH     {r4,r5}
;;;293    {
;;;294      uint32_t filter_number_bit_pos = 0;
;;;295      /* Check the parameters */
;;;296      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;297      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;298      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;299      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;300      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;301    
;;;302      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
000124  7a81              LDRB     r1,[r0,#0xa]
;;;303    
;;;304      /* Initialisation mode for the filter */
;;;305      CAN1->FMR |= FMR_FINIT;
000126  4bff              LDR      r3,|L1.1316|
000128  2201              MOVS     r2,#1                 ;302
00012a  fa02f101          LSL      r1,r2,r1              ;302
00012e  681a              LDR      r2,[r3,#0]
000130  f0420201          ORR      r2,r2,#1
000134  601a              STR      r2,[r3,#0]
;;;306    
;;;307      /* Filter Deactivation */
;;;308      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000136  f8dfc3f0          LDR      r12,|L1.1320|
00013a  f8dc2000          LDR      r2,[r12,#0]
00013e  438a              BICS     r2,r2,r1
000140  f8cc2000          STR      r2,[r12,#0]
;;;309    
;;;310      /* Filter Scale */
;;;311      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
000144  7b04              LDRB     r4,[r0,#0xc]
;;;312      {
;;;313        /* 16-bit scale for the filter */
;;;314        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
000146  4af9              LDR      r2,|L1.1324|
000148  b9d4              CBNZ     r4,|L1.384|
00014a  6814              LDR      r4,[r2,#0]
00014c  438c              BICS     r4,r4,r1
00014e  6014              STR      r4,[r2,#0]
;;;315    
;;;316        /* First 16-bit identifier and First 16-bit mask */
;;;317        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;318        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000150  8844              LDRH     r4,[r0,#2]
000152  88c5              LDRH     r5,[r0,#6]
000154  ea444405          ORR      r4,r4,r5,LSL #16
000158  7a85              LDRB     r5,[r0,#0xa]
00015a  00ed              LSLS     r5,r5,#3
00015c  f1054580          ADD      r5,r5,#0x40000000
000160  f50545c0          ADD      r5,r5,#0x6000
000164  f8c54640          STR      r4,[r5,#0x640]
;;;319        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;320            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;321    
;;;322        /* Second 16-bit identifier and Second 16-bit mask */
;;;323        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;324        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
000168  8804              LDRH     r4,[r0,#0]
00016a  8885              LDRH     r5,[r0,#4]
00016c  ea444405          ORR      r4,r4,r5,LSL #16
000170  7a85              LDRB     r5,[r0,#0xa]
000172  00ed              LSLS     r5,r5,#3
000174  f1054580          ADD      r5,r5,#0x40000000
000178  f50545c0          ADD      r5,r5,#0x6000
00017c  f8c54644          STR      r4,[r5,#0x644]
                  |L1.384|
;;;325        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;326            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;327      }
;;;328    
;;;329      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
000180  7b04              LDRB     r4,[r0,#0xc]
000182  2c01              CMP      r4,#1
000184  d118              BNE      |L1.440|
;;;330      {
;;;331        /* 32-bit scale for the filter */
;;;332        CAN1->FS1R |= filter_number_bit_pos;
000186  6814              LDR      r4,[r2,#0]
000188  430c              ORRS     r4,r4,r1
00018a  6014              STR      r4,[r2,#0]
;;;333        /* 32-bit identifier or First 32-bit identifier */
;;;334        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00018c  7a84              LDRB     r4,[r0,#0xa]
00018e  6802              LDR      r2,[r0,#0]
000190  00e4              LSLS     r4,r4,#3
000192  f1044480          ADD      r4,r4,#0x40000000
000196  f50444c0          ADD      r4,r4,#0x6000
00019a  ea4f4232          ROR      r2,r2,#16
00019e  f8c42640          STR      r2,[r4,#0x640]
;;;335        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;336            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;337        /* 32-bit mask or Second 32-bit identifier */
;;;338        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
0001a2  7a84              LDRB     r4,[r0,#0xa]
0001a4  6842              LDR      r2,[r0,#4]
0001a6  00e4              LSLS     r4,r4,#3
0001a8  f1044480          ADD      r4,r4,#0x40000000
0001ac  f50444c0          ADD      r4,r4,#0x6000
0001b0  ea4f4232          ROR      r2,r2,#16
0001b4  f8c42644          STR      r2,[r4,#0x644]
                  |L1.440|
;;;339        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;340            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;341      }
;;;342    
;;;343      /* Filter Mode */
;;;344      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
0001b8  7ac4              LDRB     r4,[r0,#0xb]
;;;345      {
;;;346        /*Id/Mask mode for the filter*/
;;;347        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
0001ba  4add              LDR      r2,|L1.1328|
0001bc  2c00              CMP      r4,#0                 ;344
;;;348      }
;;;349      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;350      {
;;;351        /*Identifier list mode for the filter*/
;;;352        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
0001be  6814              LDR      r4,[r2,#0]
0001c0  bf0c              ITE      EQ                    ;347
0001c2  438c              BICEQ    r4,r4,r1              ;347
0001c4  430c              ORRNE    r4,r4,r1
0001c6  6014              STR      r4,[r2,#0]
;;;353      }
;;;354    
;;;355      /* Filter FIFO assignment */
;;;356      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
0001c8  8904              LDRH     r4,[r0,#8]
;;;357      {
;;;358        /* FIFO 0 assignation for the filter */
;;;359        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
0001ca  4ada              LDR      r2,|L1.1332|
0001cc  b914              CBNZ     r4,|L1.468|
0001ce  6814              LDR      r4,[r2,#0]
0001d0  438c              BICS     r4,r4,r1
0001d2  6014              STR      r4,[r2,#0]
                  |L1.468|
;;;360      }
;;;361    
;;;362      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
0001d4  8904              LDRH     r4,[r0,#8]
0001d6  2c01              CMP      r4,#1
0001d8  d102              BNE      |L1.480|
;;;363      {
;;;364        /* FIFO 1 assignation for the filter */
;;;365        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0001da  6814              LDR      r4,[r2,#0]
0001dc  430c              ORRS     r4,r4,r1
0001de  6014              STR      r4,[r2,#0]
                  |L1.480|
;;;366      }
;;;367      
;;;368      /* Filter activation */
;;;369      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0001e0  7b40              LDRB     r0,[r0,#0xd]
0001e2  2801              CMP      r0,#1
0001e4  d104              BNE      |L1.496|
;;;370      {
;;;371        CAN1->FA1R |= filter_number_bit_pos;
0001e6  f8dc0000          LDR      r0,[r12,#0]
0001ea  4308              ORRS     r0,r0,r1
0001ec  f8cc0000          STR      r0,[r12,#0]
                  |L1.496|
;;;372      }
;;;373    
;;;374      /* Leave the initialisation mode for the filter */
;;;375      CAN1->FMR &= ~FMR_FINIT;
0001f0  6818              LDR      r0,[r3,#0]
0001f2  f0200001          BIC      r0,r0,#1
0001f6  6018              STR      r0,[r3,#0]
;;;376    }
0001f8  bc30              POP      {r4,r5}
0001fa  4770              BX       lr
;;;377    
                          ENDP

                  CAN_StructInit PROC
;;;383      */
;;;384    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
0001fc  2100              MOVS     r1,#0
;;;385    {
;;;386      /* Reset CAN init structure parameters values */
;;;387      
;;;388      /* Initialize the time triggered communication mode */
;;;389      CAN_InitStruct->CAN_TTCM = DISABLE;
0001fe  7181              STRB     r1,[r0,#6]
;;;390      
;;;391      /* Initialize the automatic bus-off management */
;;;392      CAN_InitStruct->CAN_ABOM = DISABLE;
000200  71c1              STRB     r1,[r0,#7]
;;;393      
;;;394      /* Initialize the automatic wake-up mode */
;;;395      CAN_InitStruct->CAN_AWUM = DISABLE;
000202  7201              STRB     r1,[r0,#8]
;;;396      
;;;397      /* Initialize the no automatic retransmission */
;;;398      CAN_InitStruct->CAN_NART = DISABLE;
000204  7241              STRB     r1,[r0,#9]
;;;399      
;;;400      /* Initialize the receive FIFO locked mode */
;;;401      CAN_InitStruct->CAN_RFLM = DISABLE;
000206  7281              STRB     r1,[r0,#0xa]
;;;402      
;;;403      /* Initialize the transmit FIFO priority */
;;;404      CAN_InitStruct->CAN_TXFP = DISABLE;
000208  72c1              STRB     r1,[r0,#0xb]
;;;405      
;;;406      /* Initialize the CAN_Mode member */
;;;407      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00020a  7081              STRB     r1,[r0,#2]
;;;408      
;;;409      /* Initialize the CAN_SJW member */
;;;410      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
00020c  70c1              STRB     r1,[r0,#3]
;;;411      
;;;412      /* Initialize the CAN_BS1 member */
;;;413      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
00020e  2103              MOVS     r1,#3
000210  7101              STRB     r1,[r0,#4]
;;;414      
;;;415      /* Initialize the CAN_BS2 member */
;;;416      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000212  2102              MOVS     r1,#2
000214  7141              STRB     r1,[r0,#5]
;;;417      
;;;418      /* Initialize the CAN_Prescaler member */
;;;419      CAN_InitStruct->CAN_Prescaler = 1;
000216  2101              MOVS     r1,#1
000218  8001              STRH     r1,[r0,#0]
;;;420    }
00021a  4770              BX       lr
;;;421    
                          ENDP

                  CAN_SlaveStartBank PROC
;;;427      */
;;;428    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
00021c  49c1              LDR      r1,|L1.1316|
;;;429    {
;;;430      /* Check the parameters */
;;;431      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;432      
;;;433      /* Enter Initialisation mode for the filter */
;;;434      CAN1->FMR |= FMR_FINIT;
00021e  680a              LDR      r2,[r1,#0]
000220  f0420201          ORR      r2,r2,#1
000224  600a              STR      r2,[r1,#0]
;;;435      
;;;436      /* Select the start slave bank */
;;;437      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
000226  680a              LDR      r2,[r1,#0]
000228  f4227287          BIC      r2,r2,#0x10e
00022c  f4225278          BIC      r2,r2,#0x3e00
000230  600a              STR      r2,[r1,#0]
;;;438      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000232  680a              LDR      r2,[r1,#0]
000234  ea422000          ORR      r0,r2,r0,LSL #8
000238  6008              STR      r0,[r1,#0]
;;;439      
;;;440      /* Leave Initialisation mode for the filter */
;;;441      CAN1->FMR &= ~FMR_FINIT;
00023a  6808              LDR      r0,[r1,#0]
00023c  f0200001          BIC      r0,r0,#1
000240  6008              STR      r0,[r1,#0]
;;;442    }
000242  4770              BX       lr
;;;443    
                          ENDP

                  CAN_DBGFreeze PROC
;;;450      */
;;;451    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000244  2900              CMP      r1,#0
;;;452    {
;;;453      /* Check the parameters */
;;;454      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;455      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;456      
;;;457      if (NewState != DISABLE)
;;;458      {
;;;459        /* Enable Debug Freeze  */
;;;460        CANx->MCR |= MCR_DBF;
;;;461      }
;;;462      else
;;;463      {
;;;464        /* Disable Debug Freeze */
;;;465        CANx->MCR &= ~MCR_DBF;
000246  6801              LDR      r1,[r0,#0]
000248  bf14              ITE      NE                    ;460
00024a  f4413180          ORRNE    r1,r1,#0x10000        ;460
00024e  f4213180          BICEQ    r1,r1,#0x10000
000252  6001              STR      r1,[r0,#0]            ;460
;;;466      }
;;;467    }
000254  4770              BX       lr
;;;468    
                          ENDP

                  CAN_TTComModeCmd PROC
;;;480      */
;;;481    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
000256  2900              CMP      r1,#0
;;;482    {
;;;483      /* Check the parameters */
;;;484      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;485      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;486      if (NewState != DISABLE)
;;;487      {
;;;488        /* Enable the TTCM mode */
;;;489        CANx->MCR |= CAN_MCR_TTCM;
;;;490    
;;;491        /* Set TGT bits */
;;;492        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
;;;493        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
;;;494        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
;;;495      }
;;;496      else
;;;497      {
;;;498        /* Disable the TTCM mode */
;;;499        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
000258  6801              LDR      r1,[r0,#0]
00025a  d013              BEQ      |L1.644|
00025c  f0410180          ORR      r1,r1,#0x80           ;489
000260  6001              STR      r1,[r0,#0]            ;489
000262  f8d01184          LDR      r1,[r0,#0x184]        ;492
000266  f4417180          ORR      r1,r1,#0x100          ;492
00026a  f8c01184          STR      r1,[r0,#0x184]        ;492
00026e  f8d01194          LDR      r1,[r0,#0x194]        ;493
000272  f4417180          ORR      r1,r1,#0x100          ;493
000276  f8c01194          STR      r1,[r0,#0x194]        ;493
00027a  f8d011a4          LDR      r1,[r0,#0x1a4]        ;494
00027e  f4417180          ORR      r1,r1,#0x100          ;494
000282  e012              B        |L1.682|
                  |L1.644|
000284  f0210180          BIC      r1,r1,#0x80
000288  6001              STR      r1,[r0,#0]
;;;500    
;;;501        /* Reset TGT bits */
;;;502        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
00028a  f8d01184          LDR      r1,[r0,#0x184]
00028e  f4217180          BIC      r1,r1,#0x100
000292  f8c01184          STR      r1,[r0,#0x184]
;;;503        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
000296  f8d01194          LDR      r1,[r0,#0x194]
00029a  f4217180          BIC      r1,r1,#0x100
00029e  f8c01194          STR      r1,[r0,#0x194]
;;;504        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
0002a2  f8d011a4          LDR      r1,[r0,#0x1a4]
0002a6  f4217180          BIC      r1,r1,#0x100
                  |L1.682|
0002aa  f8c011a4          STR      r1,[r0,#0x1a4]        ;494
;;;505      }
;;;506    }
0002ae  4770              BX       lr
;;;507    /**
                          ENDP

                  CAN_Transmit PROC
;;;514      */
;;;515    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
0002b0  b410              PUSH     {r4}
;;;516    {
0002b2  4602              MOV      r2,r0
;;;517      uint8_t transmit_mailbox = 0;
0002b4  2000              MOVS     r0,#0
;;;518      /* Check the parameters */
;;;519      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;520      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;521      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;522      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;523    
;;;524      /* Select one empty transmit mailbox */
;;;525      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
0002b6  6893              LDR      r3,[r2,#8]
0002b8  f0136f80          TST      r3,#0x4000000
0002bc  d03f              BEQ      |L1.830|
;;;526      {
;;;527        transmit_mailbox = 0;
;;;528      }
;;;529      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
;;;530      {
;;;531        transmit_mailbox = 1;
;;;532      }
;;;533      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
;;;534      {
;;;535        transmit_mailbox = 2;
;;;536      }
;;;537      else
;;;538      {
;;;539        transmit_mailbox = CAN_TxStatus_NoMailBox;
;;;540      }
;;;541    
;;;542      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
;;;543      {
;;;544        /* Set up the Id */
;;;545        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
0002be  bf00              NOP      
                  |L1.704|
0002c0  eb021200          ADD      r2,r2,r0,LSL #4
0002c4  f8d23180          LDR      r3,[r2,#0x180]
0002c8  f0030301          AND      r3,r3,#1
0002cc  f8c23180          STR      r3,[r2,#0x180]
;;;546        if (TxMessage->IDE == CAN_Id_Standard)
0002d0  7a0b              LDRB     r3,[r1,#8]
0002d2  2b00              CMP      r3,#0
0002d4  d042              BEQ      |L1.860|
;;;547        {
;;;548          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;549          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
;;;550                                                      TxMessage->RTR);
;;;551        }
;;;552        else
;;;553        {
;;;554          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;555          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
0002d6  f8d2c180          LDR      r12,[r2,#0x180]
0002da  684c              LDR      r4,[r1,#4]
0002dc  ea4c0303          ORR      r3,r12,r3
0002e0  f891c009          LDRB     r12,[r1,#9]
0002e4  ea4c0cc4          ORR      r12,r12,r4,LSL #3
0002e8  ea43030c          ORR      r3,r3,r12
                  |L1.748|
0002ec  f8c23180          STR      r3,[r2,#0x180]
;;;556                                                      TxMessage->IDE | \
;;;557                                                      TxMessage->RTR);
;;;558        }
;;;559        
;;;560        /* Set up the DLC */
;;;561        TxMessage->DLC &= (uint8_t)0x0000000F;
0002f0  7a8b              LDRB     r3,[r1,#0xa]
0002f2  f003030f          AND      r3,r3,#0xf
0002f6  728b              STRB     r3,[r1,#0xa]
;;;562        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
0002f8  f8d23184          LDR      r3,[r2,#0x184]
0002fc  f023030f          BIC      r3,r3,#0xf
000300  f8c23184          STR      r3,[r2,#0x184]
;;;563        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
000304  f8d23184          LDR      r3,[r2,#0x184]
000308  f891c00a          LDRB     r12,[r1,#0xa]
00030c  ea43030c          ORR      r3,r3,r12
000310  f8c23184          STR      r3,[r2,#0x184]
;;;564    
;;;565        /* Set up the data field */
;;;566        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
000314  7acb              LDRB     r3,[r1,#0xb]
000316  f8d1c00c          LDR      r12,[r1,#0xc]
00031a  ea43230c          ORR      r3,r3,r12,LSL #8
00031e  f8c23188          STR      r3,[r2,#0x188]
;;;567                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;568                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;569                                                 ((uint32_t)TxMessage->Data[0]));
;;;570        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
000322  7bcb              LDRB     r3,[r1,#0xf]
000324  6909              LDR      r1,[r1,#0x10]
000326  ea432101          ORR      r1,r3,r1,LSL #8
00032a  f8c2118c          STR      r1,[r2,#0x18c]
;;;571                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;572                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;573                                                 ((uint32_t)TxMessage->Data[4]));
;;;574        /* Request transmission */
;;;575        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00032e  f8d21180          LDR      r1,[r2,#0x180]
000332  f0410101          ORR      r1,r1,#1
000336  f8c21180          STR      r1,[r2,#0x180]
;;;576      }
;;;577      return transmit_mailbox;
;;;578    }
00033a  bc10              POP      {r4}
00033c  4770              BX       lr
                  |L1.830|
00033e  6890              LDR      r0,[r2,#8]            ;529
000340  f0106f00          TST      r0,#0x8000000         ;529
000344  bf18              IT       NE                    ;531
000346  2001              MOVNE    r0,#1                 ;531
000348  d1ba              BNE      |L1.704|
00034a  6890              LDR      r0,[r2,#8]            ;533
00034c  f0105f80          TST      r0,#0x10000000        ;533
000350  bf14              ITE      NE                    ;535
000352  2002              MOVNE    r0,#2                 ;535
000354  2004              MOVEQ    r0,#4                 ;539
000356  d1b3              BNE      |L1.704|
000358  bc10              POP      {r4}
00035a  4770              BX       lr
                  |L1.860|
00035c  f8d23180          LDR      r3,[r2,#0x180]        ;549
000360  f891c009          LDRB     r12,[r1,#9]           ;549
000364  ea43030c          ORR      r3,r3,r12             ;549
000368  f8b1c000          LDRH     r12,[r1,#0]           ;549
00036c  ea43534c          ORR      r3,r3,r12,LSL #21     ;549
000370  e7bc              B        |L1.748|
;;;579    
                          ENDP

                  CAN_TransmitStatus PROC
;;;588      */
;;;589    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000372  4a71              LDR      r2,|L1.1336|
;;;590    {
;;;591      uint32_t state = 0;
;;;592    
;;;593      /* Check the parameters */
;;;594      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;595      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;596     
;;;597      switch (TransmitMailbox)
000374  2900              CMP      r1,#0
;;;598      {
;;;599        case (CAN_TXMAILBOX_0): 
;;;600          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
000376  bf04              ITT      EQ
000378  6880              LDREQ    r0,[r0,#8]
00037a  4970              LDREQ    r1,|L1.1340|
00037c  d007              BEQ      |L1.910|
00037e  2901              CMP      r1,#1                 ;597
;;;601          break;
;;;602        case (CAN_TXMAILBOX_1): 
;;;603          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
000380  bf04              ITT      EQ
000382  6880              LDREQ    r0,[r0,#8]
000384  496e              LDREQ    r1,|L1.1344|
000386  d002              BEQ      |L1.910|
000388  2902              CMP      r1,#2                 ;597
00038a  d002              BEQ      |L1.914|
00038c  e022              B        |L1.980|
                  |L1.910|
00038e  4008              ANDS     r0,r0,r1              ;600
000390  e002              B        |L1.920|
                  |L1.914|
;;;604          break;
;;;605        case (CAN_TXMAILBOX_2): 
;;;606          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
000392  6880              LDR      r0,[r0,#8]
000394  496b              LDR      r1,|L1.1348|
000396  4008              ANDS     r0,r0,r1
                  |L1.920|
;;;607          break;
;;;608        default:
;;;609          state = CAN_TxStatus_Failed;
;;;610          break;
;;;611      }
;;;612      switch (state)
000398  f1a06100          SUB      r1,r0,#0x8000000
00039c  f5a17180          SUB      r1,r1,#0x100
0003a0  4290              CMP      r0,r2
0003a2  d015              BEQ      |L1.976|
0003a4  dc08              BGT      |L1.952|
0003a6  b1a8              CBZ      r0,|L1.980|
0003a8  f06f6180          MVN      r1,#0x4000000
0003ac  1840              ADDS     r0,r0,r1
;;;613      {
;;;614          /* transmit pending  */
;;;615        case (0x0): state = CAN_TxStatus_Pending;
;;;616          break;
;;;617          /* transmit failed  */
;;;618         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
;;;619          break;
;;;620         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
;;;621          break;
;;;622         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
;;;623          break;
;;;624          /* transmit succeeded  */
;;;625        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
;;;626          break;
;;;627        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
;;;628          break;
;;;629        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
;;;630          break;
;;;631        default: state = CAN_TxStatus_Failed;
;;;632          break;
;;;633      }
;;;634      return (uint8_t) state;
;;;635    }
0003ae  bf08              IT       EQ
0003b0  4770              BXEQ     lr
0003b2  2802              CMP      r0,#2                 ;612
0003b4  d010              BEQ      |L1.984|
0003b6  e00b              B        |L1.976|
                  |L1.952|
0003b8  f5b17f00          CMP      r1,#0x200             ;612
0003bc  d00c              BEQ      |L1.984|
0003be  f1a16000          SUB      r0,r1,#0x8000000      ;612
0003c2  f5b0407f          SUBS     r0,r0,#0xff00         ;612
0003c6  bf08              IT       EQ
0003c8  4770              BXEQ     lr
0003ca  f5b03f00          CMP      r0,#0x20000           ;612
0003ce  d003              BEQ      |L1.984|
                  |L1.976|
0003d0  2000              MOVS     r0,#0                 ;631
0003d2  4770              BX       lr
                  |L1.980|
0003d4  2002              MOVS     r0,#2                 ;615
0003d6  4770              BX       lr
                  |L1.984|
0003d8  2001              MOVS     r0,#1                 ;629
0003da  4770              BX       lr
;;;636    
                          ENDP

                  CAN_CancelTransmit PROC
;;;642      */
;;;643    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
0003dc  b169              CBZ      r1,|L1.1018|
;;;644    {
;;;645      /* Check the parameters */
;;;646      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;647      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;648      /* abort transmission */
;;;649      switch (Mailbox)
0003de  2901              CMP      r1,#1
;;;650      {
;;;651        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
;;;652          break;
;;;653        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
0003e0  bf04              ITT      EQ
0003e2  6881              LDREQ    r1,[r0,#8]
0003e4  f4414100          ORREQ    r1,r1,#0x8000
0003e8  d005              BEQ      |L1.1014|
0003ea  2902              CMP      r1,#2                 ;649
;;;654          break;
;;;655        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
0003ec  bf06              ITTE     EQ
0003ee  6881              LDREQ    r1,[r0,#8]
0003f0  f4410100          ORREQ    r1,r1,#0x800000
;;;656          break;
;;;657        default:
;;;658          break;
;;;659      }
;;;660    }
0003f4  4770              BXNE     lr
                  |L1.1014|
0003f6  6081              STR      r1,[r0,#8]            ;655
0003f8  4770              BX       lr
                  |L1.1018|
0003fa  6881              LDR      r1,[r0,#8]            ;651
0003fc  f0410180          ORR      r1,r1,#0x80           ;651
000400  6081              STR      r1,[r0,#8]            ;651
000402  4770              BX       lr
;;;661    
                          ENDP

                  CAN_Receive PROC
;;;670      */
;;;671    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000404  eb001301          ADD      r3,r0,r1,LSL #4
;;;672    {
;;;673      /* Check the parameters */
;;;674      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;675      assert_param(IS_CAN_FIFO(FIFONumber));
;;;676      /* Get the Id */
;;;677      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000408  f8d3c1b0          LDR      r12,[r3,#0x1b0]
00040c  f01c0c04          ANDS     r12,r12,#4
000410  f882c008          STRB     r12,[r2,#8]
;;;678      if (RxMessage->IDE == CAN_Id_Standard)
;;;679      {
;;;680        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
;;;681      }
;;;682      else
;;;683      {
;;;684        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000414  f8d3c1b0          LDR      r12,[r3,#0x1b0]
000418  bf07              ITTEE    EQ                    ;680
00041a  ea4f5c5c          LSREQ    r12,r12,#21           ;680
00041e  f8c2c000          STREQ    r12,[r2,#0]           ;680
000422  ea4f0cdc          LSRNE    r12,r12,#3
000426  f8c2c004          STRNE    r12,[r2,#4]
;;;685      }
;;;686      
;;;687      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
00042a  f8d3c1b0          LDR      r12,[r3,#0x1b0]
00042e  f00c0c02          AND      r12,r12,#2
000432  f882c009          STRB     r12,[r2,#9]
;;;688      /* Get the DLC */
;;;689      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000436  f8d3c1b4          LDR      r12,[r3,#0x1b4]
00043a  f00c0c0f          AND      r12,r12,#0xf
00043e  f882c00a          STRB     r12,[r2,#0xa]
;;;690      /* Get the FMI */
;;;691      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
000442  f8d3c1b4          LDR      r12,[r3,#0x1b4]
000446  ea4f2c1c          LSR      r12,r12,#8
00044a  f882c013          STRB     r12,[r2,#0x13]
;;;692      /* Get the data field */
;;;693      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
00044e  f8d3c1b8          LDR      r12,[r3,#0x1b8]
000452  f882c00b          STRB     r12,[r2,#0xb]
;;;694      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
000456  f8d3c1b8          LDR      r12,[r3,#0x1b8]
00045a  ea4f2c1c          LSR      r12,r12,#8
00045e  f882c00c          STRB     r12,[r2,#0xc]
;;;695      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
000462  f8d3c1b8          LDR      r12,[r3,#0x1b8]
000466  ea4f4c1c          LSR      r12,r12,#16
00046a  f882c00d          STRB     r12,[r2,#0xd]
;;;696      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
00046e  f8d3c1b8          LDR      r12,[r3,#0x1b8]
000472  ea4f6c1c          LSR      r12,r12,#24
000476  f882c00e          STRB     r12,[r2,#0xe]
;;;697      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
00047a  f8d3c1bc          LDR      r12,[r3,#0x1bc]
00047e  f882c00f          STRB     r12,[r2,#0xf]
;;;698      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
000482  f8d3c1bc          LDR      r12,[r3,#0x1bc]
000486  ea4f2c1c          LSR      r12,r12,#8
00048a  f882c010          STRB     r12,[r2,#0x10]
;;;699      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
00048e  f8d3c1bc          LDR      r12,[r3,#0x1bc]
000492  ea4f4c1c          LSR      r12,r12,#16
000496  f882c011          STRB     r12,[r2,#0x11]
;;;700      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
00049a  f8d331bc          LDR      r3,[r3,#0x1bc]
00049e  0e1b              LSRS     r3,r3,#24
0004a0  7493              STRB     r3,[r2,#0x12]
0004a2  b121              CBZ      r1,|L1.1198|
;;;701      /* Release the FIFO */
;;;702      /* Release FIFO0 */
;;;703      if (FIFONumber == CAN_FIFO0)
;;;704      {
;;;705        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;706      }
;;;707      /* Release FIFO1 */
;;;708      else /* FIFONumber == CAN_FIFO1 */
;;;709      {
;;;710        CANx->RF1R |= CAN_RF1R_RFOM1;
0004a4  6901              LDR      r1,[r0,#0x10]
0004a6  f0410120          ORR      r1,r1,#0x20
0004aa  6101              STR      r1,[r0,#0x10]
;;;711      }
;;;712    }
0004ac  4770              BX       lr
                  |L1.1198|
0004ae  68c1              LDR      r1,[r0,#0xc]          ;705
0004b0  f0410120          ORR      r1,r1,#0x20           ;705
0004b4  60c1              STR      r1,[r0,#0xc]          ;705
0004b6  4770              BX       lr
;;;713    
                          ENDP

                  CAN_FIFORelease PROC
;;;719      */
;;;720    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
0004b8  b121              CBZ      r1,|L1.1220|
;;;721    {
;;;722      /* Check the parameters */
;;;723      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;724      assert_param(IS_CAN_FIFO(FIFONumber));
;;;725      /* Release FIFO0 */
;;;726      if (FIFONumber == CAN_FIFO0)
;;;727      {
;;;728        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;729      }
;;;730      /* Release FIFO1 */
;;;731      else /* FIFONumber == CAN_FIFO1 */
;;;732      {
;;;733        CANx->RF1R |= CAN_RF1R_RFOM1;
0004ba  6901              LDR      r1,[r0,#0x10]
0004bc  f0410120          ORR      r1,r1,#0x20
0004c0  6101              STR      r1,[r0,#0x10]
;;;734      }
;;;735    }
0004c2  4770              BX       lr
                  |L1.1220|
0004c4  68c1              LDR      r1,[r0,#0xc]          ;728
0004c6  f0410120          ORR      r1,r1,#0x20           ;728
0004ca  60c1              STR      r1,[r0,#0xc]          ;728
0004cc  4770              BX       lr
;;;736    
                          ENDP

                  CAN_MessagePending PROC
;;;742      */
;;;743    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
0004ce  4602              MOV      r2,r0
;;;744    {
;;;745      uint8_t message_pending=0;
0004d0  2000              MOVS     r0,#0
;;;746      /* Check the parameters */
;;;747      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;748      assert_param(IS_CAN_FIFO(FIFONumber));
;;;749      if (FIFONumber == CAN_FIFO0)
0004d2  2900              CMP      r1,#0
;;;750      {
;;;751        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
0004d4  bf08              IT       EQ
0004d6  68d0              LDREQ    r0,[r2,#0xc]
0004d8  d003              BEQ      |L1.1250|
;;;752      }
;;;753      else if (FIFONumber == CAN_FIFO1)
0004da  2901              CMP      r1,#1
;;;754      {
;;;755        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
0004dc  bf0c              ITE      EQ
0004de  6910              LDREQ    r0,[r2,#0x10]
;;;756      }
;;;757      else
;;;758      {
;;;759        message_pending = 0;
;;;760      }
;;;761      return message_pending;
;;;762    }
0004e0  4770              BXNE     lr
                  |L1.1250|
0004e2  f0000003          AND      r0,r0,#3              ;751
0004e6  4770              BX       lr
;;;763    
                          ENDP

                  CAN_OperatingModeRequest PROC
;;;773      */
;;;774    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
0004e8  2300              MOVS     r3,#0
;;;775    {
;;;776      uint8_t status = CAN_ModeStatus_Failed;
;;;777      
;;;778      /* Timeout for INAK or also for SLAK bits*/
;;;779      uint32_t timeout = INAK_TIMEOUT; 
0004ea  f64f72ff          MOV      r2,#0xffff
0004ee  b121              CBZ      r1,|L1.1274|
;;;780    
;;;781      /* Check the parameters */
;;;782      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;783      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
;;;784    
;;;785      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
;;;786      {
;;;787        /* Request initialisation */
;;;788        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
;;;789    
;;;790        /* Wait the acknowledge */
;;;791        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
;;;792        {
;;;793          timeout--;
;;;794        }
;;;795        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
;;;796        {
;;;797          status = CAN_ModeStatus_Failed;
;;;798        }
;;;799        else
;;;800        {
;;;801          status = CAN_ModeStatus_Success;
;;;802        }
;;;803      }
;;;804      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
0004f0  2901              CMP      r1,#1
0004f2  d029              BEQ      |L1.1352|
;;;805      {
;;;806        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;807        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
;;;808    
;;;809        /* Wait the acknowledge */
;;;810        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
;;;811        {
;;;812          timeout--;
;;;813        }
;;;814        if ((CANx->MSR & CAN_MODE_MASK) != 0)
;;;815        {
;;;816          status = CAN_ModeStatus_Failed;
;;;817        }
;;;818        else
;;;819        {
;;;820          status = CAN_ModeStatus_Success;
;;;821        }
;;;822      }
;;;823      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
0004f4  2902              CMP      r1,#2
0004f6  d037              BEQ      |L1.1384|
0004f8  e04c              B        |L1.1428|
                  |L1.1274|
0004fa  6801              LDR      r1,[r0,#0]            ;788
0004fc  f0210102          BIC      r1,r1,#2              ;788
000500  f0410101          ORR      r1,r1,#1              ;788
000504  6001              STR      r1,[r0,#0]            ;788
                  |L1.1286|
000506  6841              LDR      r1,[r0,#4]            ;793
000508  f0010103          AND      r1,r1,#3              ;793
00050c  2901              CMP      r1,#1                 ;793
00050e  bf1c              ITT      NE                    ;793
000510  2a00              CMPNE    r2,#0                 ;793
000512  1e52              SUBNE    r2,r2,#1              ;793
000514  d1f7              BNE      |L1.1286|
000516  6840              LDR      r0,[r0,#4]            ;795
000518  f0000003          AND      r0,r0,#3              ;795
00051c  2801              CMP      r0,#1                 ;795
00051e  d136              BNE      |L1.1422|
000520  e037              B        |L1.1426|
000522  0000              DCW      0x0000
                  |L1.1316|
                          DCD      0x40006600
                  |L1.1320|
                          DCD      0x4000661c
                  |L1.1324|
                          DCD      0x4000660c
                  |L1.1328|
                          DCD      0x40006604
                  |L1.1332|
                          DCD      0x40006614
                  |L1.1336|
                          DCD      0x08000100
                  |L1.1340|
                          DCD      0x04000003
                  |L1.1344|
                          DCD      0x08000300
                  |L1.1348|
                          DCD      0x10030000
                  |L1.1352|
000548  6801              LDR      r1,[r0,#0]            ;807
00054a  f0210103          BIC      r1,r1,#3              ;807
00054e  6001              STR      r1,[r0,#0]            ;807
                  |L1.1360|
000550  6841              LDR      r1,[r0,#4]            ;812
000552  f0110f03          TST      r1,#3                 ;812
000556  bf1c              ITT      NE                    ;812
000558  2a00              CMPNE    r2,#0                 ;812
00055a  1e52              SUBNE    r2,r2,#1              ;812
00055c  d1f8              BNE      |L1.1360|
00055e  6840              LDR      r0,[r0,#4]            ;814
000560  f0100f03          TST      r0,#3                 ;814
000564  d113              BNE      |L1.1422|
000566  e014              B        |L1.1426|
                  |L1.1384|
;;;824      {
;;;825        /* Request Sleep mode */
;;;826        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000568  6801              LDR      r1,[r0,#0]
00056a  f0210101          BIC      r1,r1,#1
00056e  f0410102          ORR      r1,r1,#2
000572  6001              STR      r1,[r0,#0]
                  |L1.1396|
;;;827    
;;;828        /* Wait the acknowledge */
;;;829        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
;;;830        {
;;;831          timeout--;
000574  6841              LDR      r1,[r0,#4]
000576  f0010103          AND      r1,r1,#3
00057a  2902              CMP      r1,#2
00057c  bf1c              ITT      NE
00057e  2a00              CMPNE    r2,#0
000580  1e52              SUBNE    r2,r2,#1
000582  d1f7              BNE      |L1.1396|
;;;832        }
;;;833        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
000584  6840              LDR      r0,[r0,#4]
000586  f0000003          AND      r0,r0,#3
00058a  2802              CMP      r0,#2
00058c  d001              BEQ      |L1.1426|
                  |L1.1422|
;;;834        {
;;;835          status = CAN_ModeStatus_Failed;
00058e  2300              MOVS     r3,#0
000590  e000              B        |L1.1428|
                  |L1.1426|
;;;836        }
;;;837        else
;;;838        {
;;;839          status = CAN_ModeStatus_Success;
000592  2301              MOVS     r3,#1
                  |L1.1428|
;;;840        }
;;;841      }
;;;842      else
;;;843      {
;;;844        status = CAN_ModeStatus_Failed;
;;;845      }
;;;846    
;;;847      return  (uint8_t) status;
000594  4618              MOV      r0,r3
;;;848    }
000596  4770              BX       lr
;;;849    
                          ENDP

                  CAN_Sleep PROC
;;;855      */
;;;856    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000598  6802              LDR      r2,[r0,#0]
;;;857    {
;;;858      uint8_t sleepstatus = CAN_Sleep_Failed;
00059a  2100              MOVS     r1,#0
;;;859      
;;;860      /* Check the parameters */
;;;861      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;862        
;;;863      /* Request Sleep mode */
;;;864       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00059c  f0220201          BIC      r2,r2,#1
0005a0  f0420202          ORR      r2,r2,#2
0005a4  6002              STR      r2,[r0,#0]
;;;865       
;;;866      /* Sleep mode status */
;;;867      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
0005a6  6840              LDR      r0,[r0,#4]
0005a8  f0000003          AND      r0,r0,#3
0005ac  2802              CMP      r0,#2
;;;868      {
;;;869        /* Sleep mode not entered */
;;;870        sleepstatus =  CAN_Sleep_Ok;
0005ae  bf08              IT       EQ
0005b0  2101              MOVEQ    r1,#1
;;;871      }
;;;872      /* return sleep mode status */
;;;873       return (uint8_t)sleepstatus;
0005b2  4608              MOV      r0,r1
;;;874    }
0005b4  4770              BX       lr
;;;875    
                          ENDP

                  CAN_WakeUp PROC
;;;881      */
;;;882    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
0005b6  6802              LDR      r2,[r0,#0]
;;;883    {
;;;884      uint32_t wait_slak = SLAK_TIMEOUT;
0005b8  f64f71ff          MOV      r1,#0xffff
;;;885      uint8_t wakeupstatus = CAN_WakeUp_Failed;
0005bc  2300              MOVS     r3,#0
;;;886      
;;;887      /* Check the parameters */
;;;888      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;889        
;;;890      /* Wake up request */
;;;891      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
0005be  f0220202          BIC      r2,r2,#2
0005c2  6002              STR      r2,[r0,#0]
                  |L1.1476|
;;;892        
;;;893      /* Sleep mode status */
;;;894      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
;;;895      {
;;;896       wait_slak--;
0005c4  6842              LDR      r2,[r0,#4]
0005c6  f0120f02          TST      r2,#2
0005ca  bf1c              ITT      NE
0005cc  2900              CMPNE    r1,#0
0005ce  1e49              SUBNE    r1,r1,#1
0005d0  d1f8              BNE      |L1.1476|
;;;897      }
;;;898      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
0005d2  6840              LDR      r0,[r0,#4]
0005d4  f0100f02          TST      r0,#2
;;;899      {
;;;900       /* wake up done : Sleep mode exited */
;;;901        wakeupstatus = CAN_WakeUp_Ok;
0005d8  bf08              IT       EQ
0005da  2301              MOVEQ    r3,#1
;;;902      }
;;;903      /* return wakeup status */
;;;904      return (uint8_t)wakeupstatus;
0005dc  4618              MOV      r0,r3
;;;905    }
0005de  4770              BX       lr
;;;906    
                          ENDP

                  CAN_GetLastErrorCode PROC
;;;921     
;;;922    uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
0005e0  6980              LDR      r0,[r0,#0x18]
;;;923    {
;;;924      uint8_t errorcode=0;
;;;925      
;;;926      /* Check the parameters */
;;;927      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;928      
;;;929      /* Get the error code*/
;;;930      errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
0005e2  f3c01002          UBFX     r0,r0,#4,#3
0005e6  0100              LSLS     r0,r0,#4
;;;931      
;;;932      /* Return the error code*/
;;;933      return errorcode;
;;;934    }
0005e8  4770              BX       lr
;;;935    /**
                          ENDP

                  CAN_GetReceiveErrorCounter PROC
;;;945      */
;;;946    uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
0005ea  6980              LDR      r0,[r0,#0x18]
;;;947    {
;;;948      uint8_t counter=0;
;;;949      
;;;950      /* Check the parameters */
;;;951      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;952      
;;;953      /* Get the Receive Error Counter*/
;;;954      counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
0005ec  0e00              LSRS     r0,r0,#24
;;;955      
;;;956      /* Return the Receive Error Counter*/
;;;957      return counter;
;;;958    }
0005ee  4770              BX       lr
;;;959    
                          ENDP

                  CAN_GetLSBTransmitErrorCounter PROC
;;;965      */
;;;966    uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
0005f0  6980              LDR      r0,[r0,#0x18]
;;;967    {
;;;968      uint8_t counter=0;
;;;969      
;;;970      /* Check the parameters */
;;;971      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;972      
;;;973      /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;974      counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
0005f2  f3c04007          UBFX     r0,r0,#16,#8
;;;975      
;;;976      /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;977      return counter;
;;;978    }
0005f6  4770              BX       lr
;;;979    
                          ENDP

                  CAN_ITConfig PROC
;;;1002     */
;;;1003   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
0005f8  2a00              CMP      r2,#0
;;;1004   {
;;;1005     /* Check the parameters */
;;;1006     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1007     assert_param(IS_CAN_IT(CAN_IT));
;;;1008     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1009   
;;;1010     if (NewState != DISABLE)
;;;1011     {
;;;1012       /* Enable the selected CANx interrupt */
;;;1013       CANx->IER |= CAN_IT;
;;;1014     }
;;;1015     else
;;;1016     {
;;;1017       /* Disable the selected CANx interrupt */
;;;1018       CANx->IER &= ~CAN_IT;
0005fa  6942              LDR      r2,[r0,#0x14]
0005fc  bf14              ITE      NE                    ;1013
0005fe  4311              ORRNE    r1,r1,r2              ;1013
000600  ea220101          BICEQ    r1,r2,r1
000604  6141              STR      r1,[r0,#0x14]         ;1013
;;;1019     }
;;;1020   }
000606  4770              BX       lr
;;;1021   /**
                          ENDP

                  CAN_GetFlagStatus PROC
;;;1042     */
;;;1043   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000608  4603              MOV      r3,r0
;;;1044   {
;;;1045     FlagStatus bitstatus = RESET;
00060a  2000              MOVS     r0,#0
;;;1046     
;;;1047     /* Check the parameters */
;;;1048     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1049     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;1050     
;;;1051   
;;;1052     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
00060c  f4110f70          TST      r1,#0xf00000
;;;1053     { 
;;;1054       /* Check the status of the specified CAN flag */
;;;1055       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000610  f3c10213          UBFX     r2,r1,#0,#20
000614  d005              BEQ      |L1.1570|
000616  6999              LDR      r1,[r3,#0x18]
000618  4211              TST      r1,r2
;;;1056       { 
;;;1057         /* CAN_FLAG is set */
;;;1058         bitstatus = SET;
;;;1059       }
;;;1060       else
;;;1061       { 
;;;1062         /* CAN_FLAG is reset */
;;;1063         bitstatus = RESET;
;;;1064       }
;;;1065     }
;;;1066     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
;;;1067     { 
;;;1068       /* Check the status of the specified CAN flag */
;;;1069       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1070       { 
;;;1071         /* CAN_FLAG is set */
;;;1072         bitstatus = SET;
;;;1073       }
;;;1074       else
;;;1075       { 
;;;1076         /* CAN_FLAG is reset */
;;;1077         bitstatus = RESET;
;;;1078       }
;;;1079     }
;;;1080     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
;;;1081     { 
;;;1082       /* Check the status of the specified CAN flag */
;;;1083       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1084       { 
;;;1085         /* CAN_FLAG is set */
;;;1086         bitstatus = SET;
;;;1087       }
;;;1088       else
;;;1089       { 
;;;1090         /* CAN_FLAG is reset */
;;;1091         bitstatus = RESET;
;;;1092       }
;;;1093     }
;;;1094     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
;;;1095     { 
;;;1096       /* Check the status of the specified CAN flag */
;;;1097       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1098       { 
;;;1099         /* CAN_FLAG is set */
;;;1100         bitstatus = SET;
;;;1101       }
;;;1102       else
;;;1103       { 
;;;1104         /* CAN_FLAG is reset */
;;;1105         bitstatus = RESET;
;;;1106       }
;;;1107     }
;;;1108     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1109     { 
;;;1110       /* Check the status of the specified CAN flag */
;;;1111       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1112       { 
;;;1113         /* CAN_FLAG is set */
;;;1114         bitstatus = SET;
;;;1115       }
;;;1116       else
;;;1117       { 
;;;1118         /* CAN_FLAG is reset */
;;;1119         bitstatus = RESET;
;;;1120       }
;;;1121     }
;;;1122     /* Return the CAN_FLAG status */
;;;1123     return  bitstatus;
;;;1124   }
00061a  bf08              IT       EQ
00061c  4770              BXEQ     lr
                  |L1.1566|
00061e  2001              MOVS     r0,#1                 ;1058
000620  4770              BX       lr
                  |L1.1570|
000622  f0117f80          TST      r1,#0x1000000         ;1066
000626  d004              BEQ      |L1.1586|
000628  6859              LDR      r1,[r3,#4]            ;1069
00062a  4211              TST      r1,r2                 ;1069
00062c  bf08              IT       EQ
00062e  4770              BXEQ     lr
000630  e7f5              B        |L1.1566|
                  |L1.1586|
000632  f0116f00          TST      r1,#0x8000000         ;1080
000636  d004              BEQ      |L1.1602|
000638  6899              LDR      r1,[r3,#8]            ;1083
00063a  4211              TST      r1,r2                 ;1083
00063c  bf08              IT       EQ
00063e  4770              BXEQ     lr
000640  e7ed              B        |L1.1566|
                  |L1.1602|
000642  f0117f00          TST      r1,#0x2000000         ;1094
000646  d004              BEQ      |L1.1618|
000648  68d9              LDR      r1,[r3,#0xc]          ;1097
00064a  4211              TST      r1,r2                 ;1097
00064c  bf08              IT       EQ
00064e  4770              BXEQ     lr
000650  e7e5              B        |L1.1566|
                  |L1.1618|
000652  6919              LDR      r1,[r3,#0x10]         ;1111
000654  4211              TST      r1,r2                 ;1111
000656  d1e2              BNE      |L1.1566|
000658  4770              BX       lr
;;;1125   
                          ENDP

                  CAN_ClearFlag PROC
;;;1142     */
;;;1143   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
00065a  4a75              LDR      r2,|L1.2096|
;;;1144   {
;;;1145     uint32_t flagtmp=0;
;;;1146     /* Check the parameters */
;;;1147     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1148     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;1149     
;;;1150     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
00065c  4291              CMP      r1,r2
;;;1151     {
;;;1152       /* Clear the selected CAN flags */
;;;1153       CANx->ESR = (uint32_t)RESET;
00065e  bf02              ITTT     EQ
000660  2100              MOVEQ    r1,#0
000662  6181              STREQ    r1,[r0,#0x18]
;;;1154     }
;;;1155     else /* MSR or TSR or RF0R or RF1R */
;;;1156     {
;;;1157       flagtmp = CAN_FLAG & 0x000FFFFF;
;;;1158   
;;;1159       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
;;;1160       {
;;;1161         /* Receive Flags */
;;;1162         CANx->RF0R = (uint32_t)(flagtmp);
;;;1163       }
;;;1164       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
;;;1165       {
;;;1166         /* Receive Flags */
;;;1167         CANx->RF1R = (uint32_t)(flagtmp);
;;;1168       }
;;;1169       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
;;;1170       {
;;;1171         /* Transmit Flags */
;;;1172         CANx->TSR = (uint32_t)(flagtmp);
;;;1173       }
;;;1174       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1175       {
;;;1176         /* Operating mode Flags */
;;;1177         CANx->MSR = (uint32_t)(flagtmp);
;;;1178       }
;;;1179     }
;;;1180   }
000664  4770              BXEQ     lr
000666  f3c10213          UBFX     r2,r1,#0,#20          ;1157
00066a  f0117f00          TST      r1,#0x2000000         ;1159
00066e  bf1c              ITT      NE                    ;1162
000670  60c2              STRNE    r2,[r0,#0xc]          ;1162
000672  4770              BXNE     lr
000674  f0116f80          TST      r1,#0x4000000         ;1164
000678  bf1c              ITT      NE                    ;1167
00067a  6102              STRNE    r2,[r0,#0x10]         ;1167
00067c  4770              BXNE     lr
00067e  f0116f00          TST      r1,#0x8000000         ;1169
000682  bf14              ITE      NE                    ;1172
000684  6082              STRNE    r2,[r0,#8]            ;1172
000686  6042              STREQ    r2,[r0,#4]            ;1177
000688  4770              BX       lr
;;;1181   
                          ENDP

                  CAN_GetITStatus PROC
;;;1202     */
;;;1203   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
00068a  4602              MOV      r2,r0
;;;1204   {
;;;1205     ITStatus itstatus = RESET;
00068c  2000              MOVS     r0,#0
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1208     assert_param(IS_CAN_IT(CAN_IT));
;;;1209     
;;;1210     /* check the enable interrupt bit */
;;;1211    if((CANx->IER & CAN_IT) != RESET)
00068e  6953              LDR      r3,[r2,#0x14]
000690  420b              TST      r3,r1
;;;1212    {
;;;1213      /* in case the Interrupt is enabled, .... */
;;;1214       switch (CAN_IT)
;;;1215       {
;;;1216         case CAN_IT_TME:
;;;1217                  /* Check CAN_TSR_RQCPx bits */
;;;1218   	             itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
;;;1219   	      break;
;;;1220         case CAN_IT_FMP0:
;;;1221                  /* Check CAN_RF0R_FMP0 bit */
;;;1222   	             itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
;;;1223   	      break;
;;;1224         case CAN_IT_FF0:
;;;1225                  /* Check CAN_RF0R_FULL0 bit */
;;;1226                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
;;;1227   	      break;
;;;1228         case CAN_IT_FOV0:
;;;1229                  /* Check CAN_RF0R_FOVR0 bit */
;;;1230                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
;;;1231   	      break;
;;;1232         case CAN_IT_FMP1:
;;;1233                  /* Check CAN_RF1R_FMP1 bit */
;;;1234                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
;;;1235   	      break;
;;;1236         case CAN_IT_FF1:
;;;1237                  /* Check CAN_RF1R_FULL1 bit */
;;;1238   	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
;;;1239   	      break;
;;;1240         case CAN_IT_FOV1:
;;;1241                  /* Check CAN_RF1R_FOVR1 bit */
;;;1242   	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
;;;1243   	      break;
;;;1244         case CAN_IT_WKU:
;;;1245                  /* Check CAN_MSR_WKUI bit */
;;;1246                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
;;;1247   	      break;
;;;1248         case CAN_IT_SLK:
;;;1249                  /* Check CAN_MSR_SLAKI bit */
;;;1250   	             itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
;;;1251   	      break;
;;;1252         case CAN_IT_EWG:
;;;1253                  /* Check CAN_ESR_EWGF bit */
;;;1254   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
;;;1255   	      break;
;;;1256         case CAN_IT_EPV:
;;;1257                  /* Check CAN_ESR_EPVF bit */
;;;1258   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
;;;1259   	      break;
;;;1260         case CAN_IT_BOF:
;;;1261                  /* Check CAN_ESR_BOFF bit */
;;;1262   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
;;;1263   	      break;
;;;1264         case CAN_IT_LEC:
;;;1265                  /* Check CAN_ESR_LEC bit */
;;;1266   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
;;;1267   	      break;
;;;1268         case CAN_IT_ERR:
;;;1269                  /* Check CAN_MSR_ERRI bit */ 
;;;1270                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
;;;1271   	      break;
;;;1272         default :
;;;1273                  /* in case of error, return RESET */
;;;1274                 itstatus = RESET;
;;;1275                 break;
;;;1276       }
;;;1277     }
;;;1278     else
;;;1279     {
;;;1280      /* in case the Interrupt is not enabled, return RESET */
;;;1281       itstatus  = RESET;
;;;1282     }
;;;1283     
;;;1284     /* Return the CAN_IT status */
;;;1285     return  itstatus;
;;;1286   }
000692  bf08              IT       EQ
000694  4770              BXEQ     lr
000696  f5b17f80          CMP      r1,#0x100             ;1214
00069a  d064              BEQ      |L1.1894|
00069c  dc1c              BGT      |L1.1752|
00069e  2908              CMP      r1,#8                 ;1214
0006a0  d049              BEQ      |L1.1846|
0006a2  dc0c              BGT      |L1.1726|
0006a4  2901              CMP      r1,#1                 ;1214
0006a6  d038              BEQ      |L1.1818|
0006a8  2902              CMP      r1,#2                 ;1214
0006aa  d03e              BEQ      |L1.1834|
0006ac  2904              CMP      r1,#4                 ;1214
0006ae  bf18              IT       NE
0006b0  4770              BXNE     lr
0006b2  68d1              LDR      r1,[r2,#0xc]          ;1226
0006b4  2000              MOVS     r0,#0                 ;1226
0006b6  f0110f08          TST      r1,#8                 ;1226
0006ba  d134              BNE      |L1.1830|
0006bc  4770              BX       lr
                  |L1.1726|
0006be  2910              CMP      r1,#0x10              ;1214
0006c0  d03f              BEQ      |L1.1858|
0006c2  2920              CMP      r1,#0x20              ;1214
0006c4  d043              BEQ      |L1.1870|
0006c6  2940              CMP      r1,#0x40              ;1214
0006c8  bf18              IT       NE
0006ca  4770              BXNE     lr
0006cc  6911              LDR      r1,[r2,#0x10]         ;1242
0006ce  2000              MOVS     r0,#0                 ;1242
0006d0  f0110f10          TST      r1,#0x10              ;1242
0006d4  d127              BNE      |L1.1830|
0006d6  4770              BX       lr
                  |L1.1752|
0006d8  f5b14f00          CMP      r1,#0x8000            ;1214
0006dc  d055              BEQ      |L1.1930|
0006de  dc0f              BGT      |L1.1792|
0006e0  f5b17f00          CMP      r1,#0x200             ;1214
0006e4  d045              BEQ      |L1.1906|
0006e6  f5b16f80          CMP      r1,#0x400             ;1214
0006ea  d048              BEQ      |L1.1918|
0006ec  f5b16f00          CMP      r1,#0x800             ;1214
0006f0  bf18              IT       NE
0006f2  4770              BXNE     lr
0006f4  6991              LDR      r1,[r2,#0x18]         ;1266
0006f6  2000              MOVS     r0,#0                 ;1266
0006f8  f0110f70          TST      r1,#0x70              ;1266
0006fc  d113              BNE      |L1.1830|
0006fe  4770              BX       lr
                  |L1.1792|
000700  f5b13f80          CMP      r1,#0x10000           ;1214
000704  d029              BEQ      |L1.1882|
000706  f5b13f00          CMP      r1,#0x20000           ;1214
00070a  bf18              IT       NE
00070c  4770              BXNE     lr
00070e  6851              LDR      r1,[r2,#4]            ;1250
000710  2000              MOVS     r0,#0                 ;1250
000712  f0110f10          TST      r1,#0x10              ;1250
000716  d106              BNE      |L1.1830|
000718  4770              BX       lr
                  |L1.1818|
00071a  6891              LDR      r1,[r2,#8]            ;1218
00071c  4a45              LDR      r2,|L1.2100|
00071e  2000              MOVS     r0,#0                 ;1218
000720  4211              TST      r1,r2                 ;1218
000722  bf08              IT       EQ
000724  4770              BXEQ     lr
                  |L1.1830|
000726  2001              MOVS     r0,#1
000728  4770              BX       lr
                  |L1.1834|
00072a  68d1              LDR      r1,[r2,#0xc]          ;1222
00072c  2000              MOVS     r0,#0                 ;1222
00072e  f0110f03          TST      r1,#3                 ;1222
000732  d1f8              BNE      |L1.1830|
000734  4770              BX       lr
                  |L1.1846|
000736  68d1              LDR      r1,[r2,#0xc]          ;1230
000738  2000              MOVS     r0,#0                 ;1230
00073a  f0110f10          TST      r1,#0x10              ;1230
00073e  d1f2              BNE      |L1.1830|
000740  4770              BX       lr
                  |L1.1858|
000742  6911              LDR      r1,[r2,#0x10]         ;1234
000744  2000              MOVS     r0,#0                 ;1234
000746  f0110f03          TST      r1,#3                 ;1234
00074a  d1ec              BNE      |L1.1830|
00074c  4770              BX       lr
                  |L1.1870|
00074e  6911              LDR      r1,[r2,#0x10]         ;1238
000750  2000              MOVS     r0,#0                 ;1238
000752  f0110f08          TST      r1,#8                 ;1238
000756  d1e6              BNE      |L1.1830|
000758  4770              BX       lr
                  |L1.1882|
00075a  6851              LDR      r1,[r2,#4]            ;1246
00075c  2000              MOVS     r0,#0                 ;1246
00075e  f0110f08          TST      r1,#8                 ;1246
000762  d1e0              BNE      |L1.1830|
000764  4770              BX       lr
                  |L1.1894|
000766  6991              LDR      r1,[r2,#0x18]         ;1254
000768  2000              MOVS     r0,#0                 ;1254
00076a  f0110f01          TST      r1,#1                 ;1254
00076e  d1da              BNE      |L1.1830|
000770  4770              BX       lr
                  |L1.1906|
000772  6991              LDR      r1,[r2,#0x18]         ;1258
000774  2000              MOVS     r0,#0                 ;1258
000776  f0110f02          TST      r1,#2                 ;1258
00077a  d1d4              BNE      |L1.1830|
00077c  4770              BX       lr
                  |L1.1918|
00077e  6991              LDR      r1,[r2,#0x18]         ;1262
000780  2000              MOVS     r0,#0                 ;1262
000782  f0110f04          TST      r1,#4                 ;1262
000786  d1ce              BNE      |L1.1830|
000788  4770              BX       lr
                  |L1.1930|
00078a  6851              LDR      r1,[r2,#4]            ;1270
00078c  2000              MOVS     r0,#0                 ;1270
00078e  f0110f04          TST      r1,#4                 ;1270
000792  d1c8              BNE      |L1.1830|
000794  4770              BX       lr
;;;1287   
                          ENDP

                  CAN_ClearITPendingBit PROC
;;;1305     */
;;;1306   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000796  b410              PUSH     {r4}
;;;1307   {
;;;1308     /* Check the parameters */
;;;1309     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1310     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1311   
;;;1312     switch (CAN_IT)
;;;1313     {
;;;1314         case CAN_IT_TME:
;;;1315                 /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1316   	      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
;;;1317   	      break;
;;;1318         case CAN_IT_FF0:
;;;1319                 /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1320   	      CANx->RF0R = CAN_RF0R_FULL0; 
000798  2308              MOVS     r3,#8
;;;1321   	      break;
;;;1322         case CAN_IT_FOV0:
;;;1323                 /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1324   	      CANx->RF0R = CAN_RF0R_FOVR0; 
;;;1325   	      break;
;;;1326         case CAN_IT_FF1:
;;;1327                 /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1328   	      CANx->RF1R = CAN_RF1R_FULL1;  
;;;1329   	      break;
;;;1330         case CAN_IT_FOV1:
;;;1331                 /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1332   	      CANx->RF1R = CAN_RF1R_FOVR1; 
;;;1333   	      break;
;;;1334         case CAN_IT_WKU:
;;;1335                 /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1336   	      CANx->MSR = CAN_MSR_WKUI;  
;;;1337   	      break;
;;;1338         case CAN_IT_SLK:
;;;1339                 /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1340   	      CANx->MSR = CAN_MSR_SLAKI;   
;;;1341   	      break;
;;;1342         case CAN_IT_EWG:
;;;1343                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1344   	      CANx->MSR = CAN_MSR_ERRI;
00079a  2204              MOVS     r2,#4
00079c  f04f0c10          MOV      r12,#0x10             ;1324
0007a0  f5b17f00          CMP      r1,#0x200             ;1312
0007a4  d040              BEQ      |L1.2088|
0007a6  dc21              BGT      |L1.2028|
0007a8  2920              CMP      r1,#0x20              ;1312
0007aa  bf02              ITTT     EQ                    ;1328
0007ac  6103              STREQ    r3,[r0,#0x10]         ;1328
;;;1345                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1346                           of the CAN Bus status*/ 
;;;1347   	      break;
;;;1348         case CAN_IT_EPV:
;;;1349                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1350   	      CANx->MSR = CAN_MSR_ERRI; 
;;;1351                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1352                           of the CAN Bus status*/
;;;1353   	      break;
;;;1354         case CAN_IT_BOF:
;;;1355                 /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1356   	      CANx->MSR = CAN_MSR_ERRI; 
;;;1357                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1358                           of the CAN Bus status*/
;;;1359   	      break;
;;;1360         case CAN_IT_LEC:
;;;1361                 /*  Clear LEC bits */
;;;1362   	      CANx->ESR = RESET; 
;;;1363                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1364   	      CANx->MSR = CAN_MSR_ERRI; 
;;;1365   	      break;
;;;1366         case CAN_IT_ERR:
;;;1367                 /*Clear LEC bits */
;;;1368   	      CANx->ESR = RESET; 
;;;1369                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1370   	      CANx->MSR = CAN_MSR_ERRI; 
;;;1371   	      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending 
;;;1372                     of the CAN Bus status*/
;;;1373   	      break;
;;;1374         default :
;;;1375   	      break;
;;;1376      }
;;;1377   }
0007ae  bc10              POPEQ    {r4}
0007b0  4770              BXEQ     lr
0007b2  dc10              BGT      |L1.2006|
0007b4  2901              CMP      r1,#1                 ;1312
0007b6  bf01              ITTTT    EQ                    ;1316
0007b8  491e              LDREQ    r1,|L1.2100|
0007ba  6081              STREQ    r1,[r0,#8]            ;1316
0007bc  bc10              POPEQ    {r4}
0007be  4770              BXEQ     lr
0007c0  2904              CMP      r1,#4                 ;1312
0007c2  bf02              ITTT     EQ                    ;1320
0007c4  60c3              STREQ    r3,[r0,#0xc]          ;1320
0007c6  bc10              POPEQ    {r4}
0007c8  4770              BXEQ     lr
0007ca  2908              CMP      r1,#8                 ;1312
0007cc  bf08              IT       EQ                    ;1324
0007ce  f8c0c00c          STREQ    r12,[r0,#0xc]         ;1324
0007d2  bc10              POP      {r4}
0007d4  4770              BX       lr
                  |L1.2006|
0007d6  2940              CMP      r1,#0x40              ;1312
0007d8  bf02              ITTT     EQ                    ;1332
0007da  f8c0c010          STREQ    r12,[r0,#0x10]        ;1332
0007de  bc10              POPEQ    {r4}
0007e0  4770              BXEQ     lr
0007e2  f5b17f80          CMP      r1,#0x100             ;1312
0007e6  d01f              BEQ      |L1.2088|
0007e8  bc10              POP      {r4}
0007ea  4770              BX       lr
                  |L1.2028|
0007ec  2400              MOVS     r4,#0
0007ee  f5b14f00          CMP      r1,#0x8000            ;1312
0007f2  d008              BEQ      |L1.2054|
0007f4  dc0b              BGT      |L1.2062|
0007f6  f5b16f80          CMP      r1,#0x400             ;1312
0007fa  d015              BEQ      |L1.2088|
0007fc  f5b16f00          CMP      r1,#0x800             ;1312
000800  bf1c              ITT      NE
000802  bc10              POPNE    {r4}
000804  4770              BXNE     lr
                  |L1.2054|
000806  6184              STR      r4,[r0,#0x18]         ;1368
000808  6042              STR      r2,[r0,#4]            ;1370
00080a  bc10              POP      {r4}
00080c  4770              BX       lr
                  |L1.2062|
00080e  f5b13f80          CMP      r1,#0x10000           ;1312
000812  bf02              ITTT     EQ                    ;1336
000814  6043              STREQ    r3,[r0,#4]            ;1336
000816  bc10              POPEQ    {r4}
000818  4770              BXEQ     lr
00081a  f5b13f00          CMP      r1,#0x20000           ;1312
00081e  bf08              IT       EQ                    ;1340
000820  f8c0c004          STREQ    r12,[r0,#4]           ;1340
000824  bc10              POP      {r4}
000826  4770              BX       lr
                  |L1.2088|
000828  6042              STR      r2,[r0,#4]            ;1356
00082a  bc10              POP      {r4}
00082c  4770              BX       lr
;;;1378   
                          ENDP

00082e  0000              DCW      0x0000
                  |L1.2096|
                          DCD      0x30f00070
                  |L1.2100|
                          DCD      0x00010101
