; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\obj\stm32f10x_rtc.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\stm32f10x_rtc.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime -I..\CORE -I..\STM32F10x_FWLIB\inc -I..\USER -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\C++LIB\OnChip\GPIO -I..\C++LIB\ToolBox\Buffer -I..\C++LIB\System -I..\C++LIB\OnChip\IIC -I..\C++LIB\OffChip -I..\C++LIB\System\TaskManager -I..\C++LIB\System\Interrupt -I..\C++LIB\OnChip\SerialPort -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -W --omf_browse=..\obj\stm32f10x_rtc.crf ..\STM32F10x_FWLIB\src\stm32f10x_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;89       */
;;;90     void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
000000  4a40              LDR      r2,|L1.260|
;;;91     {
;;;92       /* Check the parameters */
;;;93       assert_param(IS_RTC_IT(RTC_IT));  
;;;94       assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;95       
;;;96       if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;97       {
;;;98         RTC->CRH |= RTC_IT;
;;;99       }
;;;100      else
;;;101      {
;;;102        RTC->CRH &= (uint16_t)~RTC_IT;
000004  8811              LDRH     r1,[r2,#0]
000006  bf14              ITE      NE                    ;98
000008  4308              ORRNE    r0,r0,r1              ;98
00000a  ea210000          BICEQ    r0,r1,r0
00000e  8010              STRH     r0,[r2,#0]            ;98
;;;103      }
;;;104    }
000010  4770              BX       lr
;;;105    
                          ENDP

                  RTC_EnterConfigMode PROC
;;;110      */
;;;111    void RTC_EnterConfigMode(void)
000012  483d              LDR      r0,|L1.264|
;;;112    {
;;;113      /* Set the CNF flag to enter in the Configuration Mode */
;;;114      RTC->CRL |= RTC_CRL_CNF;
000014  8801              LDRH     r1,[r0,#0]
000016  f0410110          ORR      r1,r1,#0x10
00001a  8001              STRH     r1,[r0,#0]
;;;115    }
00001c  4770              BX       lr
;;;116    
                          ENDP

                  RTC_ExitConfigMode PROC
;;;121      */
;;;122    void RTC_ExitConfigMode(void)
00001e  483a              LDR      r0,|L1.264|
;;;123    {
;;;124      /* Reset the CNF flag to exit from the Configuration Mode */
;;;125      RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
000020  8801              LDRH     r1,[r0,#0]
000022  f0210110          BIC      r1,r1,#0x10
000026  8001              STRH     r1,[r0,#0]
;;;126    }
000028  4770              BX       lr
;;;127    
                          ENDP

                  RTC_GetCounter PROC
;;;132      */
;;;133    uint32_t RTC_GetCounter(void)
00002a  4838              LDR      r0,|L1.268|
;;;134    {
;;;135      uint16_t tmp = 0;
;;;136      tmp = RTC->CNTL;
00002c  8800              LDRH     r0,[r0,#0]
;;;137      return (((uint32_t)RTC->CNTH << 16 ) | tmp) ;
00002e  4938              LDR      r1,|L1.272|
000030  8809              LDRH     r1,[r1,#0]
000032  ea404001          ORR      r0,r0,r1,LSL #16
;;;138    }
000036  4770              BX       lr
;;;139    
                          ENDP

                  RTC_SetCounter PROC
;;;144      */
;;;145    void RTC_SetCounter(uint32_t CounterValue)
000038  4933              LDR      r1,|L1.264|
00003a  880a              LDRH     r2,[r1,#0]
00003c  f0420210          ORR      r2,r2,#0x10
000040  800a              STRH     r2,[r1,#0]
;;;146    { 
;;;147      RTC_EnterConfigMode();
;;;148      /* Set RTC COUNTER MSB word */
;;;149      RTC->CNTH = CounterValue >> 16;
000042  4b33              LDR      r3,|L1.272|
000044  0c02              LSRS     r2,r0,#16
000046  801a              STRH     r2,[r3,#0]
;;;150      /* Set RTC COUNTER LSB word */
;;;151      RTC->CNTL = (CounterValue & RTC_LSB_MASK);
000048  1d1a              ADDS     r2,r3,#4
00004a  8010              STRH     r0,[r2,#0]
00004c  8808              LDRH     r0,[r1,#0]
00004e  f0200010          BIC      r0,r0,#0x10
000052  8008              STRH     r0,[r1,#0]
;;;152      RTC_ExitConfigMode();
;;;153    }
000054  4770              BX       lr
;;;154    
                          ENDP

                  RTC_SetPrescaler PROC
;;;159      */
;;;160    void RTC_SetPrescaler(uint32_t PrescalerValue)
000056  492c              LDR      r1,|L1.264|
000058  880a              LDRH     r2,[r1,#0]
00005a  f0420210          ORR      r2,r2,#0x10
00005e  800a              STRH     r2,[r1,#0]
;;;161    {
;;;162      /* Check the parameters */
;;;163      assert_param(IS_RTC_PRESCALER(PrescalerValue));
;;;164      
;;;165      RTC_EnterConfigMode();
;;;166      /* Set RTC PRESCALER MSB word */
;;;167      RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
000060  1d0b              ADDS     r3,r1,#4
000062  f3c04203          UBFX     r2,r0,#16,#4
000066  801a              STRH     r2,[r3,#0]
;;;168      /* Set RTC PRESCALER LSB word */
;;;169      RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
000068  1d1a              ADDS     r2,r3,#4
00006a  8010              STRH     r0,[r2,#0]
00006c  8808              LDRH     r0,[r1,#0]
00006e  f0200010          BIC      r0,r0,#0x10
000072  8008              STRH     r0,[r1,#0]
;;;170      RTC_ExitConfigMode();
;;;171    }
000074  4770              BX       lr
;;;172    
                          ENDP

                  RTC_SetAlarm PROC
;;;177      */
;;;178    void RTC_SetAlarm(uint32_t AlarmValue)
000076  4924              LDR      r1,|L1.264|
000078  880a              LDRH     r2,[r1,#0]
00007a  f0420210          ORR      r2,r2,#0x10
00007e  800a              STRH     r2,[r1,#0]
;;;179    {  
;;;180      RTC_EnterConfigMode();
;;;181      /* Set the ALARM MSB word */
;;;182      RTC->ALRH = AlarmValue >> 16;
000080  4b24              LDR      r3,|L1.276|
000082  0c02              LSRS     r2,r0,#16
000084  801a              STRH     r2,[r3,#0]
;;;183      /* Set the ALARM LSB word */
;;;184      RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
000086  1d1a              ADDS     r2,r3,#4
000088  8010              STRH     r0,[r2,#0]
00008a  8808              LDRH     r0,[r1,#0]
00008c  f0200010          BIC      r0,r0,#0x10
000090  8008              STRH     r0,[r1,#0]
;;;185      RTC_ExitConfigMode();
;;;186    }
000092  4770              BX       lr
;;;187    
                          ENDP

                  RTC_GetDivider PROC
;;;192      */
;;;193    uint32_t RTC_GetDivider(void)
000094  4820              LDR      r0,|L1.280|
;;;194    {
;;;195      uint32_t tmp = 0x00;
;;;196      tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
000096  8800              LDRH     r0,[r0,#0]
;;;197      tmp |= RTC->DIVL;
000098  4920              LDR      r1,|L1.284|
00009a  0700              LSLS     r0,r0,#28             ;196
00009c  8809              LDRH     r1,[r1,#0]
00009e  ea413010          ORR      r0,r1,r0,LSR #12
;;;198      return tmp;
;;;199    }
0000a2  4770              BX       lr
;;;200    
                          ENDP

                  RTC_WaitForLastTask PROC
;;;206      */
;;;207    void RTC_WaitForLastTask(void)
0000a4  4818              LDR      r0,|L1.264|
                  |L1.166|
;;;208    {
;;;209      /* Loop until RTOFF flag is set */
;;;210      while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
0000a6  8801              LDRH     r1,[r0,#0]
0000a8  f0110f20          TST      r1,#0x20
0000ac  d0fb              BEQ      |L1.166|
;;;211      {
;;;212      }
;;;213    }
0000ae  4770              BX       lr
;;;214    
                          ENDP

                  RTC_WaitForSynchro PROC
;;;222      */
;;;223    void RTC_WaitForSynchro(void)
0000b0  4815              LDR      r0,|L1.264|
;;;224    {
;;;225      /* Clear RSF flag */
;;;226      RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
0000b2  8801              LDRH     r1,[r0,#0]
0000b4  f0210108          BIC      r1,r1,#8
0000b8  8001              STRH     r1,[r0,#0]
                  |L1.186|
;;;227      /* Loop until RSF flag is set */
;;;228      while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
0000ba  8801              LDRH     r1,[r0,#0]
0000bc  f0110f08          TST      r1,#8
0000c0  d0fb              BEQ      |L1.186|
;;;229      {
;;;230      }
;;;231    }
0000c2  4770              BX       lr
;;;232    
                          ENDP

                  RTC_GetFlagStatus PROC
;;;243      */
;;;244    FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
0000c4  4a10              LDR      r2,|L1.264|
;;;245    {
0000c6  4601              MOV      r1,r0
;;;246      FlagStatus bitstatus = RESET;
0000c8  2000              MOVS     r0,#0
;;;247      
;;;248      /* Check the parameters */
;;;249      assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
;;;250      
;;;251      if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
0000ca  8812              LDRH     r2,[r2,#0]
0000cc  420a              TST      r2,r1
;;;252      {
;;;253        bitstatus = SET;
0000ce  bf18              IT       NE
0000d0  2001              MOVNE    r0,#1
;;;254      }
;;;255      else
;;;256      {
;;;257        bitstatus = RESET;
;;;258      }
;;;259      return bitstatus;
;;;260    }
0000d2  4770              BX       lr
;;;261    
                          ENDP

                  RTC_ClearFlag PROC
;;;272      */
;;;273    void RTC_ClearFlag(uint16_t RTC_FLAG)
0000d4  490c              LDR      r1,|L1.264|
;;;274    {
;;;275      /* Check the parameters */
;;;276      assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
;;;277        
;;;278      /* Clear the corresponding RTC flag */
;;;279      RTC->CRL &= (uint16_t)~RTC_FLAG;
0000d6  880a              LDRH     r2,[r1,#0]
0000d8  ea220000          BIC      r0,r2,r0
0000dc  8008              STRH     r0,[r1,#0]
;;;280    }
0000de  4770              BX       lr
;;;281    
                          ENDP

                  RTC_GetITStatus PROC
;;;290      */
;;;291    ITStatus RTC_GetITStatus(uint16_t RTC_IT)
0000e0  4909              LDR      r1,|L1.264|
;;;292    {
;;;293      ITStatus bitstatus = RESET;
;;;294      /* Check the parameters */
;;;295      assert_param(IS_RTC_GET_IT(RTC_IT)); 
;;;296      
;;;297      bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
0000e2  8809              LDRH     r1,[r1,#0]
0000e4  b2c2              UXTB     r2,r0
0000e6  4011              ANDS     r1,r1,r2
;;;298      if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
0000e8  4a06              LDR      r2,|L1.260|
0000ea  8812              LDRH     r2,[r2,#0]
0000ec  4202              TST      r2,r0
0000ee  bf16              ITET     NE
0000f0  2900              CMPNE    r1,#0
;;;299      {
;;;300        bitstatus = SET;
;;;301      }
;;;302      else
;;;303      {
;;;304        bitstatus = RESET;
0000f2  2000              MOVEQ    r0,#0
0000f4  2001              MOVNE    r0,#1                 ;300
;;;305      }
;;;306      return bitstatus;
;;;307    }
0000f6  4770              BX       lr
;;;308    
                          ENDP

                  RTC_ClearITPendingBit PROC
;;;317      */
;;;318    void RTC_ClearITPendingBit(uint16_t RTC_IT)
0000f8  4903              LDR      r1,|L1.264|
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_RTC_IT(RTC_IT));  
;;;322      
;;;323      /* Clear the corresponding RTC pending bit */
;;;324      RTC->CRL &= (uint16_t)~RTC_IT;
0000fa  880a              LDRH     r2,[r1,#0]
0000fc  ea220000          BIC      r0,r2,r0
000100  8008              STRH     r0,[r1,#0]
;;;325    }
000102  4770              BX       lr
;;;326    
                          ENDP

                  |L1.260|
                          DCD      0x40002800
                  |L1.264|
                          DCD      0x40002804
                  |L1.268|
                          DCD      0x4000281c
                  |L1.272|
                          DCD      0x40002818
                  |L1.276|
                          DCD      0x40002820
                  |L1.280|
                          DCD      0x40002810
                  |L1.284|
                          DCD      0x40002814
