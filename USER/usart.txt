; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o..\obj\usart.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime -I..\CORE -I..\STM32F10x_FWLIB\inc -I..\USER -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\C++LIB\OnChip\GPIO -I..\C++LIB\ToolBox\Buffer -I..\C++LIB\System -I..\C++LIB\OnChip\IIC -I..\C++LIB\OffChip -I..\C++LIB\System\TaskManager -I..\C++LIB\System\Interrupt -I..\C++LIB\OnChip\SerialPort -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -W --omf_browse=..\obj\usart.crf ..\C++LIB\OnChip\SerialPort\USART.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN5USART8InitGPIOEv PROC ; USART::InitGPIO()
;;;104    
;;;105    void USART::InitGPIO()
000000  b538              PUSH     {r3-r5,lr}
;;;106    {
000002  4604              MOV      r4,r0
;;;107    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | mGPIORcc, ENABLE);
000004  6a00              LDR      r0,[r0,#0x20]
000006  2101              MOVS     r1,#1
000008  f0400001          ORR      r0,r0,#1
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;108    	if(mUSARTx==USART1)  RCC_APB2PeriphClockCmd(mUSARTRcc, ENABLE);
000010  4dfe              LDR      r5,|L1.1036|
000012  69e0              LDR      r0,[r4,#0x1c]
;;;109    	else    	           RCC_APB1PeriphClockCmd(mUSARTRcc, ENABLE);
000014  f04f0101          MOV      r1,#1
000018  42a8              CMP      r0,r5                 ;108
00001a  6a60              LDR      r0,[r4,#0x24]         ;108
00001c  d102              BNE      |L1.36|
00001e  f7fffffe          BL       RCC_APB2PeriphClockCmd
000022  e001              B        |L1.40|
                  |L1.36|
000024  f7fffffe          BL       RCC_APB1PeriphClockCmd
                  |L1.40|
;;;110    	if(mRemap)
000028  f8940028          LDRB     r0,[r4,#0x28]
00002c  b1d0              CBZ      r0,|L1.100|
;;;111    	{
;;;112    		if(mUSARTx==USART1) GPIO_PinRemapConfig(GPIO_Remap_USART1, ENABLE);
00002e  69e0              LDR      r0,[r4,#0x1c]
000030  42a8              CMP      r0,r5
000032  d103              BNE      |L1.60|
000034  2101              MOVS     r1,#1
000036  2004              MOVS     r0,#4
000038  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.60|
;;;113    		if(mUSARTx==USART2) GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);
00003c  69e0              LDR      r0,[r4,#0x1c]
00003e  f1a04180          SUB      r1,r0,#0x40000000
000042  f5b14188          SUBS     r1,r1,#0x4400
000046  d103              BNE      |L1.80|
000048  2101              MOVS     r1,#1
00004a  2008              MOVS     r0,#8
00004c  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.80|
;;;114    		if(mUSARTx==USART3) GPIO_PinRemapConfig(GPIO_PartialRemap_USART3, ENABLE);
000050  69e0              LDR      r0,[r4,#0x1c]
000052  f1a04180          SUB      r1,r0,#0x40000000
000056  f5b14190          SUBS     r1,r1,#0x4800
00005a  d103              BNE      |L1.100|
00005c  2101              MOVS     r1,#1
00005e  48ec              LDR      r0,|L1.1040|
000060  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.100|
;;;115    	}
;;;116    	GPIO_InitTypeDef GPIO_InitStructure;//
;;;117    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000064  2003              MOVS     r0,#3
000066  f88d0002          STRB     r0,[sp,#2]
;;;118    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;       //
00006a  2018              MOVS     r0,#0x18
00006c  f88d0003          STRB     r0,[sp,#3]
;;;119    	GPIO_InitStructure.GPIO_Pin   = mTxPin;                //Tx
000070  8a60              LDRH     r0,[r4,#0x12]
000072  f8ad0000          STRH     r0,[sp,#0]
;;;120    	GPIO_Init(mPort, &GPIO_InitStructure); 
000076  4669              MOV      r1,sp
000078  69a0              LDR      r0,[r4,#0x18]
00007a  f7fffffe          BL       GPIO_Init
;;;121    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING; //in floating
00007e  2004              MOVS     r0,#4
000080  f88d0003          STRB     r0,[sp,#3]
;;;122    	GPIO_InitStructure.GPIO_Pin   = mRxPin;                //Rx
000084  8aa0              LDRH     r0,[r4,#0x14]
000086  f8ad0000          STRH     r0,[sp,#0]
;;;123    	GPIO_Init(mPort, &GPIO_InitStructure); 
00008a  4669              MOV      r1,sp
00008c  69a0              LDR      r0,[r4,#0x18]
00008e  f7fffffe          BL       GPIO_Init
;;;124    }
000092  bd38              POP      {r3-r5,pc}
;;;125    
                          ENDP

                  _ZN5USART9InitUSARTEv PROC ; USART::InitUSART()
;;;150    
;;;151    void USART::InitUSART()
000094  b510              PUSH     {r4,lr}
;;;152    {
000096  b084              SUB      sp,sp,#0x10
000098  4604              MOV      r4,r0
;;;153    	USART_InitTypeDef USART_InitStructure;                       //
;;;154    	USART_InitStructure.USART_BaudRate            = mBaudrate;  
00009a  6880              LDR      r0,[r0,#8]
;;;155    	USART_InitStructure.USART_WordLength          = mWordLen;
00009c  9000              STR      r0,[sp,#0]
00009e  89e0              LDRH     r0,[r4,#0xe]
0000a0  f8ad0004          STRH     r0,[sp,#4]
;;;156    	USART_InitStructure.USART_StopBits            = mStopBits;
0000a4  8a20              LDRH     r0,[r4,#0x10]
0000a6  f8ad0006          STRH     r0,[sp,#6]
;;;157    	USART_InitStructure.USART_Parity              = mParity ;
0000aa  89a0              LDRH     r0,[r4,#0xc]
0000ac  f8ad0008          STRH     r0,[sp,#8]
;;;158    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000b0  2000              MOVS     r0,#0
0000b2  f8ad000c          STRH     r0,[sp,#0xc]
;;;159    	USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;
0000b6  200c              MOVS     r0,#0xc
0000b8  f8ad000a          STRH     r0,[sp,#0xa]
;;;160    	
;;;161    	USART_Init(mUSARTx, &USART_InitStructure); 
0000bc  4669              MOV      r1,sp
0000be  69e0              LDR      r0,[r4,#0x1c]
0000c0  f7fffffe          BL       USART_Init
;;;162    	
;;;163    	USART_Cmd(mUSARTx, ENABLE);
0000c4  2101              MOVS     r1,#1
0000c6  69e0              LDR      r0,[r4,#0x1c]
0000c8  f7fffffe          BL       USART_Cmd
;;;164    	
;;;165    	USART_ITConfig(mUSARTx, USART_IT_RXNE, ENABLE);
0000cc  2201              MOVS     r2,#1
0000ce  f2405125          MOV      r1,#0x525
0000d2  69e0              LDR      r0,[r4,#0x1c]
0000d4  f7fffffe          BL       USART_ITConfig
;;;166    	
;;;167    #ifndef USE_USART_DMA	
;;;168    	USART_ITConfig(mUSARTx, USART_IT_TC, DISABLE);
;;;169    #endif	
;;;170    	USART_ClearFlag(mUSARTx, USART_FLAG_TC);      //clear TC flag to make sure the first byte can be send correctly
0000d8  2140              MOVS     r1,#0x40
0000da  69e0              LDR      r0,[r4,#0x1c]
0000dc  f7fffffe          BL       USART_ClearFlag
;;;171    }
0000e0  b004              ADD      sp,sp,#0x10
0000e2  bd10              POP      {r4,pc}
;;;172    
                          ENDP

                  _ZN5USART8InitNVICEv PROC ; USART::InitNVIC()
;;;125    
;;;126    void USART::InitNVIC()
0000e4  b538              PUSH     {r3-r5,lr}
;;;127    {
0000e6  4604              MOV      r4,r0
;;;128    	switch(mPriGroup)
0000e8  f890002b          LDRB     r0,[r0,#0x2b]
0000ec  2805              CMP      r0,#5
0000ee  d227              BCS      |L1.320|
0000f0  e8dff000          TBB      [pc,r0]
0000f4  03062326          DCB      0x03,0x06,0x23,0x26
0000f8  2900              DCB      0x29,0x00
;;;129    	{
;;;130    		case 0:	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);	break;
0000fa  f44f60e0          MOV      r0,#0x700
0000fe  e001              B        |L1.260|
;;;131    		case 1:	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);	break;
000100  f44f60c0          MOV      r0,#0x600
                  |L1.260|
000104  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;132    		case 2:	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	break;
;;;133    		case 3:	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);	break;
;;;134    		case 4:	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);	break;
;;;135    		default:NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);	break;
;;;136    	}
;;;137    	NVIC_InitTypeDef NVIC_InitStructure;
;;;138    	NVIC_InitStructure.NVIC_IRQChannel                   = mIRQn;   //USART IRQn
000108  7da0              LDRB     r0,[r4,#0x16]
00010a  f88d0000          STRB     r0,[sp,#0]
;;;139    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = mPrePri; //preemption priority
00010e  f8940029          LDRB     r0,[r4,#0x29]
000112  f88d0001          STRB     r0,[sp,#1]
;;;140    	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = mSubPri; //sub priority
000116  f894002a          LDRB     r0,[r4,#0x2a]
00011a  f88d0002          STRB     r0,[sp,#2]
;;;141    	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;  //enable interrup
00011e  2001              MOVS     r0,#1
000120  f88d0003          STRB     r0,[sp,#3]
;;;142    	NVIC_Init(&NVIC_InitStructure);                                 //initialize irq
000124  4668              MOV      r0,sp
000126  f7fffffe          BL       NVIC_Init
;;;143    #ifdef USE_USART_DMA
;;;144    	NVIC_InitStructure.NVIC_IRQChannel                   = mDMAIRQn;//DMA IRQ
00012a  f89401d2          LDRB     r0,[r4,#0x1d2]
00012e  f88d0000          STRB     r0,[sp,#0]
;;;145    	NVIC_Init(&NVIC_InitStructure);
000132  4668              MOV      r0,sp
000134  f7fffffe          BL       NVIC_Init
;;;146    //	mDMATxCh->CCR |= DMA_IT_TC;  //Enable DMA TX Channel TCIT 
;;;147    //	mDMATxCh->CCR |= DMA_IT_TE;  //Enable DMA TX Channel TEIT
;;;148    #endif
;;;149    }
000138  bd38              POP      {r3-r5,pc}
00013a  f44f60a0          MOV      r0,#0x500             ;132
00013e  e7e1              B        |L1.260|
                  |L1.320|
000140  f44f6080          MOV      r0,#0x400             ;133
000144  e7de              B        |L1.260|
000146  f44f7040          MOV      r0,#0x300             ;134
00014a  e7db              B        |L1.260|
;;;150    
                          ENDP

                  _ZN5USART7InitDMAEv PROC ; USART::InitDMA()
;;;413    #ifdef USE_USART_DMA
;;;414    void USART::InitDMA()
00014c  b510              PUSH     {r4,lr}
;;;415    {
00014e  4604              MOV      r4,r0
;;;416    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);                   //enable DMA clock
000150  2101              MOVS     r1,#1
000152  b08c              SUB      sp,sp,#0x30           ;415
000154  4608              MOV      r0,r1
000156  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;417    	
;;;418    	DMA_DeInit(mDMATxCh);
00015a  f8d401d4          LDR      r0,[r4,#0x1d4]
00015e  f7fffffe          BL       DMA_DeInit
;;;419    	
;;;420    	DMA_InitTypeDef DMA_InitStructure;
;;;421    	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&mUSARTx->DR;	       //DMA Tx data target address
000162  69e0              LDR      r0,[r4,#0x1c]
;;;422    	DMA_InitStructure.DMA_MemoryBaseAddr     = (u32)mDMATxBuf;           //DMA data source address
;;;423    	DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralDST;	   //DMA data direction: from memory to peripheral
;;;424    	DMA_InitStructure.DMA_BufferSize         = 0;                        //data size to send with DMA
;;;425    	DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;//peripheral address not increase
;;;426    	DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;	   //memory address increase
000164  2180              MOVS     r1,#0x80
000166  1d00              ADDS     r0,r0,#4              ;421
000168  9000              STR      r0,[sp,#0]            ;422
00016a  f50470f0          ADD      r0,r4,#0x1e0          ;422
00016e  9001              STR      r0,[sp,#4]            ;423
000170  2010              MOVS     r0,#0x10              ;423
000172  9002              STR      r0,[sp,#8]            ;424
000174  2000              MOVS     r0,#0                 ;424
000176  e9cd0104          STRD     r0,r1,[sp,#0x10]
00017a  9003              STR      r0,[sp,#0xc]
;;;427    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//peripheral data unit: Byte
;;;428    	DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;	 //memory data unit: Byte
00017c  9006              STR      r0,[sp,#0x18]
;;;429    	DMA_InitStructure.DMA_Mode               = DMA_Mode_Normal ;         //DMA mode: normal (not loop)
00017e  9007              STR      r0,[sp,#0x1c]
;;;430    	DMA_InitStructure.DMA_Priority           = DMA_Priority_Low;         //DMA priority: low
000180  9008              STR      r0,[sp,#0x20]
;;;431    	DMA_InitStructure.DMA_M2M                = DMA_M2M_Disable;          //disable memory to memory
000182  9009              STR      r0,[sp,#0x24]
;;;432    	
;;;433    	DMA_Init(mDMATxCh, &DMA_InitStructure);                              //config DMA	   
000184  900a              STR      r0,[sp,#0x28]
000186  4669              MOV      r1,sp
000188  f8d401d4          LDR      r0,[r4,#0x1d4]
00018c  f7fffffe          BL       DMA_Init
;;;434    	
;;;435    	DMA_ITConfig(mDMATxCh, DMA_IT_TC, ENABLE); 
000190  2201              MOVS     r2,#1
000192  2102              MOVS     r1,#2
000194  f8d401d4          LDR      r0,[r4,#0x1d4]
000198  f7fffffe          BL       DMA_ITConfig
;;;436    	DMA_ITConfig(mDMATxCh, DMA_IT_TE, ENABLE); 
00019c  2201              MOVS     r2,#1
00019e  2108              MOVS     r1,#8
0001a0  f8d401d4          LDR      r0,[r4,#0x1d4]
0001a4  f7fffffe          BL       DMA_ITConfig
;;;437    	
;;;438    	USART_DMACmd(mUSARTx, USART_DMAReq_Tx, ENABLE);                      //enable DMA Tx of USART
0001a8  2201              MOVS     r2,#1
0001aa  2180              MOVS     r1,#0x80
0001ac  69e0              LDR      r0,[r4,#0x1c]
0001ae  f7fffffe          BL       USART_DMACmd
;;;439    	DMA_Cmd (mDMATxCh,DISABLE);		                                       //disable DMA			
0001b2  2100              MOVS     r1,#0
0001b4  f8d401d4          LDR      r0,[r4,#0x1d4]
0001b8  f7fffffe          BL       DMA_Cmd
;;;440    }
0001bc  b00c              ADD      sp,sp,#0x30
0001be  bd10              POP      {r4,pc}
;;;441    
                          ENDP

                  _ZN5USART10InitializeEv PROC ; USART::Initialize()
;;;94     
;;;95     void USART::Initialize()
0001c0  b530              PUSH     {r4,r5,lr}
;;;96     {
0001c2  4604              MOV      r4,r0
0001c4  6a00              LDR      r0,[r0,#0x20]
0001c6  b08b              SUB      sp,sp,#0x2c
0001c8  f0400001          ORR      r0,r0,#1
0001cc  2101              MOVS     r1,#1
0001ce  f7fffffe          BL       RCC_APB2PeriphClockCmd
0001d2  4d8e              LDR      r5,|L1.1036|
0001d4  69e0              LDR      r0,[r4,#0x1c]
0001d6  f04f0101          MOV      r1,#1
0001da  42a8              CMP      r0,r5
0001dc  6a60              LDR      r0,[r4,#0x24]
0001de  d102              BNE      |L1.486|
0001e0  f7fffffe          BL       RCC_APB2PeriphClockCmd
0001e4  e001              B        |L1.490|
                  |L1.486|
0001e6  f7fffffe          BL       RCC_APB1PeriphClockCmd
                  |L1.490|
0001ea  f8940028          LDRB     r0,[r4,#0x28]
0001ee  b1d0              CBZ      r0,|L1.550|
0001f0  69e0              LDR      r0,[r4,#0x1c]
0001f2  42a8              CMP      r0,r5
0001f4  d103              BNE      |L1.510|
0001f6  2101              MOVS     r1,#1
0001f8  2004              MOVS     r0,#4
0001fa  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.510|
0001fe  69e0              LDR      r0,[r4,#0x1c]
000200  f1a04180          SUB      r1,r0,#0x40000000
000204  f5b14188          SUBS     r1,r1,#0x4400
000208  d103              BNE      |L1.530|
00020a  2101              MOVS     r1,#1
00020c  2008              MOVS     r0,#8
00020e  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.530|
000212  69e0              LDR      r0,[r4,#0x1c]
000214  f1a04180          SUB      r1,r0,#0x40000000
000218  f5b14190          SUBS     r1,r1,#0x4800
00021c  d103              BNE      |L1.550|
00021e  2101              MOVS     r1,#1
000220  487b              LDR      r0,|L1.1040|
000222  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.550|
000226  2003              MOVS     r0,#3
000228  f88d0002          STRB     r0,[sp,#2]
00022c  2018              MOVS     r0,#0x18
00022e  f88d0003          STRB     r0,[sp,#3]
000232  8a60              LDRH     r0,[r4,#0x12]
000234  f8ad0000          STRH     r0,[sp,#0]
000238  4669              MOV      r1,sp
00023a  69a0              LDR      r0,[r4,#0x18]
00023c  f7fffffe          BL       GPIO_Init
000240  2004              MOVS     r0,#4
000242  f88d0003          STRB     r0,[sp,#3]
000246  8aa0              LDRH     r0,[r4,#0x14]
000248  f8ad0000          STRH     r0,[sp,#0]
00024c  4669              MOV      r1,sp
00024e  69a0              LDR      r0,[r4,#0x18]
000250  f7fffffe          BL       GPIO_Init
000254  f894002b          LDRB     r0,[r4,#0x2b]
000258  2805              CMP      r0,#5
00025a  d27c              BCS      |L1.854|
00025c  e8dff000          TBB      [pc,r0]
000260  03067c7f          DCB      0x03,0x06,0x7c,0x7f
000264  8200              DCB      0x82,0x00
000266  f44f60e0          MOV      r0,#0x700
00026a  e001              B        |L1.624|
00026c  f44f60c0          MOV      r0,#0x600
                  |L1.624|
000270  f7fffffe          BL       NVIC_PriorityGroupConfig
000274  7da0              LDRB     r0,[r4,#0x16]
000276  f88d0000          STRB     r0,[sp,#0]
00027a  f8940029          LDRB     r0,[r4,#0x29]
00027e  f88d0001          STRB     r0,[sp,#1]
000282  f894002a          LDRB     r0,[r4,#0x2a]
000286  f88d0002          STRB     r0,[sp,#2]
00028a  2001              MOVS     r0,#1
00028c  f88d0003          STRB     r0,[sp,#3]
000290  4668              MOV      r0,sp
000292  f7fffffe          BL       NVIC_Init
000296  f89401d2          LDRB     r0,[r4,#0x1d2]
00029a  f88d0000          STRB     r0,[sp,#0]
00029e  4668              MOV      r0,sp
0002a0  f7fffffe          BL       NVIC_Init
0002a4  68a0              LDR      r0,[r4,#8]
0002a6  9000              STR      r0,[sp,#0]
0002a8  89e0              LDRH     r0,[r4,#0xe]
0002aa  f8ad0004          STRH     r0,[sp,#4]
0002ae  8a20              LDRH     r0,[r4,#0x10]
0002b0  f8ad0006          STRH     r0,[sp,#6]
0002b4  89a0              LDRH     r0,[r4,#0xc]
0002b6  f8ad0008          STRH     r0,[sp,#8]
0002ba  2500              MOVS     r5,#0
0002bc  200c              MOVS     r0,#0xc
0002be  f8ad500c          STRH     r5,[sp,#0xc]
0002c2  f8ad000a          STRH     r0,[sp,#0xa]
0002c6  4669              MOV      r1,sp
0002c8  69e0              LDR      r0,[r4,#0x1c]
0002ca  f7fffffe          BL       USART_Init
0002ce  2101              MOVS     r1,#1
0002d0  69e0              LDR      r0,[r4,#0x1c]
0002d2  f7fffffe          BL       USART_Cmd
0002d6  2201              MOVS     r2,#1
0002d8  f2405125          MOV      r1,#0x525
0002dc  69e0              LDR      r0,[r4,#0x1c]
0002de  f7fffffe          BL       USART_ITConfig
0002e2  2140              MOVS     r1,#0x40
0002e4  69e0              LDR      r0,[r4,#0x1c]
0002e6  f7fffffe          BL       USART_ClearFlag
0002ea  2101              MOVS     r1,#1
0002ec  4608              MOV      r0,r1
0002ee  f7fffffe          BL       RCC_AHBPeriphClockCmd
0002f2  f8d401d4          LDR      r0,[r4,#0x1d4]
0002f6  f7fffffe          BL       DMA_DeInit
0002fa  69e0              LDR      r0,[r4,#0x1c]
0002fc  4669              MOV      r1,sp
0002fe  1d00              ADDS     r0,r0,#4
000300  9000              STR      r0,[sp,#0]
000302  f50470f0          ADD      r0,r4,#0x1e0
000306  9001              STR      r0,[sp,#4]
000308  2010              MOVS     r0,#0x10
00030a  e9cd0502          STRD     r0,r5,[sp,#8]
00030e  2080              MOVS     r0,#0x80
000310  e9cd5004          STRD     r5,r0,[sp,#0x10]
000314  9506              STR      r5,[sp,#0x18]
000316  9507              STR      r5,[sp,#0x1c]
000318  9508              STR      r5,[sp,#0x20]
00031a  9509              STR      r5,[sp,#0x24]
00031c  950a              STR      r5,[sp,#0x28]
00031e  f8d401d4          LDR      r0,[r4,#0x1d4]
000322  f7fffffe          BL       DMA_Init
000326  2201              MOVS     r2,#1
000328  2102              MOVS     r1,#2
00032a  f8d401d4          LDR      r0,[r4,#0x1d4]
00032e  f7fffffe          BL       DMA_ITConfig
000332  2201              MOVS     r2,#1
000334  2108              MOVS     r1,#8
000336  f8d401d4          LDR      r0,[r4,#0x1d4]
00033a  f7fffffe          BL       DMA_ITConfig
00033e  2201              MOVS     r2,#1
000340  2180              MOVS     r1,#0x80
000342  69e0              LDR      r0,[r4,#0x1c]
000344  f7fffffe          BL       USART_DMACmd
000348  2100              MOVS     r1,#0
00034a  f8d401d4          LDR      r0,[r4,#0x1d4]
00034e  f7fffffe          BL       DMA_Cmd
;;;97     	InitGPIO();
;;;98     	InitNVIC();
;;;99     	InitUSART();
;;;100    #ifdef USE_USART_DMA
;;;101    	InitDMA();
;;;102    #endif
;;;103    }
000352  b00b              ADD      sp,sp,#0x2c
000354  bd30              POP      {r4,r5,pc}
                  |L1.854|
000356  e002              B        |L1.862|
000358  f44f60a0          MOV      r0,#0x500
00035c  e788              B        |L1.624|
                  |L1.862|
00035e  f44f6080          MOV      r0,#0x400
000362  e785              B        |L1.624|
000364  f44f7040          MOV      r0,#0x300
000368  e782              B        |L1.624|
;;;104    
                          ENDP

                  _ZN5USARTC2EP13USART_TypeDefjhhhbttt                  ; Alternate entry point ; USART::USART__sub_object(USART_TypeDef*, unsigned, unsigned char, unsigned char, unsigned char, bool, unsigned short, unsigned short, unsigned short)
                  _ZN5USARTC1EP13USART_TypeDefjhhhbttt PROC ; USART::USART(USART_TypeDef*, unsigned, unsigned char, unsigned char, unsigned char, bool, unsigned short, unsigned short, unsigned short)
;;;14     
;;;15     USART::USART(USART_TypeDef* USARTx,u32 baud,u8 priGroup, u8 prePri, u8 subPri,bool remap,u16 parity, u16 wordLen, u16 stopBits)
;;;16     {
;;;17     	mUSARTx   = USARTx;   //USARTx
;;;18     	mBaudrate = baud;     //baudrate of usart
;;;19     	mPriGroup = priGroup; //priority group
;;;20     	mPrePri   = prePri;   //preemption priority
;;;21     	mSubPri   = subPri;   //sub priority
;;;22     	mRemap    = remap;    //gpio remap flag
;;;23     	mParity   = parity;   //parity of usart
;;;24       mWordLen  = wordLen;  //world length of usart
;;;25       mStopBits = stopBits; //stop bits of usart
;;;26     	mPrecision = 3;
;;;27     	mTxOverflow = 0;
;;;28     	mRxOverflow = 0;
;;;29     	
;;;30     	if(mUSARTx==USART1)
;;;31     	{
;;;32     		mIRQn      = USART1_IRQn;//USART1_IRQn=37,/*!< USART1 global Interrupt  //USART IRQn
;;;33     		mUSARTRcc  = RCC_APB2Periph_USART1;	                                //USARTx Clock
;;;34     		mPort    = (mRemap? GPIOB                : GPIOA               );   //GPIO Port
;;;35     		mTxPin   = (mRemap? GPIO_Pin_6           : GPIO_Pin_9          );   //Tx Pin
;;;36     		mRxPin   = (mRemap? GPIO_Pin_7           : GPIO_Pin_10         );   //Rx Pin
;;;37     		mGPIORcc = (mRemap? RCC_APB2Periph_GPIOB : RCC_APB2Periph_GPIOA);   //GPIO Clock
;;;38     		
;;;39     	#ifdef USE_USART1_DMA
;;;40     		mDMATxCh   = DMA1_Channel4;       //DMA Tx Channel
;;;41     		mDMAIRQn   = DMA1_Channel4_IRQn;  //DMA IRQn
;;;42     		mDMATCFlag = DMA1_FLAG_TC4;       //DMA TC Mask
;;;43     		mDMAGLFlag = DMA1_IT_GL4;         //DMA IT GL mask
;;;44     		pCOM1 = this;
;;;45     	#endif
;;;46     		
;;;47     	#ifdef USE_USART1
;;;48     		pCOM1 = this;
;;;49     	#endif
;;;50     		
;;;51     	}
;;;52     	else if(mUSARTx==USART2)
;;;53     	{
;;;54     		mIRQn      = USART2_IRQn;                                           //USART IRQn
;;;55     		mUSARTRcc  = RCC_APB1Periph_USART2;	                                //USARTx Clock
;;;56     		mPort    = (mRemap? GPIOD                : GPIOA               );   //GPIO Port
;;;57     		mTxPin   = (mRemap? GPIO_Pin_5           : GPIO_Pin_2          );   //Tx Pin
;;;58     		mRxPin   = (mRemap? GPIO_Pin_6           : GPIO_Pin_3         );    //Rx Pin
;;;59     		mGPIORcc = (mRemap? RCC_APB2Periph_GPIOD : RCC_APB2Periph_GPIOA);   //GPIO Clock
;;;60     	#ifdef USE_USART2_DMA
;;;61     		mDMATxCh   = DMA1_Channel7;       //DMA Tx Channel
;;;62     		mDMAIRQn   = DMA1_Channel7_IRQn;  //DMA IRQn
;;;63     		mDMATCFlag = DMA1_FLAG_TC7;       //DMA TC Mask
;;;64     		mDMAGLFlag = DMA1_IT_GL7;         //DMA IT GL mask
;;;65     		pCOM2 = this;
;;;66     	#endif
;;;67     	#ifdef USE_USART2
;;;68     		pCOM2 = this;
;;;69     	#endif
;;;70     	}
;;;71     	else if(mUSARTx==USART3)
;;;72     	{
;;;73     		mIRQn      = USART3_IRQn;                                           //USART IRQn
;;;74     		mUSARTRcc  = RCC_APB1Periph_USART3;	                                //USARTx Clock
;;;75     		mPort    = (mRemap? GPIOC                : GPIOB               );   //GPIO Port
;;;76     		mTxPin   = (mRemap? GPIO_Pin_10          : GPIO_Pin_10         );   //Tx Pin
;;;77     		mRxPin   = (mRemap? GPIO_Pin_11          : GPIO_Pin_11         );   //Rx Pin
;;;78     		mGPIORcc = (mRemap? RCC_APB2Periph_GPIOC : RCC_APB2Periph_GPIOB);   //GPIO Clock
;;;79     	#ifdef USE_USART3_DMA
;;;80     		mDMATxCh   = DMA1_Channel2;       //DMA Tx Channel
;;;81     		mDMAIRQn   = DMA1_Channel2_IRQn;  //DMA IRQn
;;;82     		mDMATCFlag = DMA1_FLAG_TC2;       //DMA TC Mask
;;;83     		mDMAGLFlag = DMA1_IT_GL2;         //DMA IT GL mask
;;;84     		pCOM3 = this;
;;;85     	#endif
;;;86     	#ifdef USE_USART3
;;;87     		pCOM3 = this;
;;;88     	#endif
;;;89     	}
;;;90     	
;;;91     	Initialize();
;;;92     	
;;;93     }
;;;94     
00036a  e92d5ff0          PUSH     {r4-r12,lr}
00036e  4604              MOV      r4,r0
000370  e9dd760e          LDRD     r7,r6,[sp,#0x38]
000374  e9ddc80c          LDRD     r12,r8,[sp,#0x30]
000378  e9dda90a          LDRD     r10,r9,[sp,#0x28]
00037c  4825              LDR      r0,|L1.1044|
00037e  6020              STR      r0,[r4,#0]
000380  f04f0bc8          MOV      r11,#0xc8
000384  f8a4b0f4          STRH     r11,[r4,#0xf4]
000388  2000              MOVS     r0,#0
00038a  f8a400f6          STRH     r0,[r4,#0xf6]
00038e  f8a400f8          STRH     r0,[r4,#0xf8]
000392  f8a400fa          STRH     r0,[r4,#0xfa]
000396  f8a4b1c4          STRH     r11,[r4,#0x1c4]
00039a  f8a401c6          STRH     r0,[r4,#0x1c6]
00039e  f8a401c8          STRH     r0,[r4,#0x1c8]
0003a2  f8a401ca          STRH     r0,[r4,#0x1ca]
0003a6  60a2              STR      r2,[r4,#8]
0003a8  61e1              STR      r1,[r4,#0x1c]
0003aa  f884302b          STRB     r3,[r4,#0x2b]
0003ae  f884a029          STRB     r10,[r4,#0x29]
0003b2  f884902a          STRB     r9,[r4,#0x2a]
0003b6  f884c028          STRB     r12,[r4,#0x28]
0003ba  f8a4800c          STRH     r8,[r4,#0xc]
0003be  81e7              STRH     r7,[r4,#0xe]
0003c0  8226              STRH     r6,[r4,#0x10]
0003c2  2203              MOVS     r2,#3
0003c4  f88421cc          STRB     r2,[r4,#0x1cc]
0003c8  f8a401ce          STRH     r0,[r4,#0x1ce]
0003cc  f8a401d0          STRH     r0,[r4,#0x1d0]
0003d0  4811              LDR      r0,|L1.1048|
0003d2  4a12              LDR      r2,|L1.1052|
0003d4  f1a14380          SUB      r3,r1,#0x40000000
0003d8  f5b3339c          SUBS     r3,r3,#0x13800
0003dc  d006              BEQ      |L1.1004|
0003de  f5134374          ADDS     r3,r3,#0xf400
0003e2  d037              BEQ      |L1.1108|
0003e4  f5b36280          SUBS     r2,r3,#0x400
0003e8  d05d              BEQ      |L1.1190|
0003ea  e071              B        |L1.1232|
                  |L1.1004|
0003ec  2125              MOVS     r1,#0x25
0003ee  75a1              STRB     r1,[r4,#0x16]
0003f0  f44f4180          MOV      r1,#0x4000
0003f4  6261              STR      r1,[r4,#0x24]
0003f6  f1bc0f00          CMP      r12,#0
0003fa  bf08              IT       EQ
0003fc  4610              MOVEQ    r0,r2
0003fe  61a0              STR      r0,[r4,#0x18]
000400  bf14              ITE      NE
000402  2040              MOVNE    r0,#0x40
000404  f44f7000          MOVEQ    r0,#0x200
000408  8260              STRH     r0,[r4,#0x12]
00040a  e009              B        |L1.1056|
                  |L1.1036|
                          DCD      0x40013800
                  |L1.1040|
                          DCD      0x00140010
                  |L1.1044|
                          DCD      _ZTV5USART+0x8 ; vtable for USART
                  |L1.1048|
                          DCD      0x40010c00
                  |L1.1052|
                          DCD      0x40010800
                  |L1.1056|
000420  bf14              ITE      NE
000422  2080              MOVNE    r0,#0x80
000424  f44f6080          MOVEQ    r0,#0x400
000428  82a0              STRH     r0,[r4,#0x14]
00042a  bf14              ITE      NE
00042c  2008              MOVNE    r0,#8
00042e  2004              MOVEQ    r0,#4
000430  6220              STR      r0,[r4,#0x20]
000432  48fe              LDR      r0,|L1.2092|
000434  f8c401d4          STR      r0,[r4,#0x1d4]
000438  f04f000e          MOV      r0,#0xe
00043c  f88401d2          STRB     r0,[r4,#0x1d2]
000440  f44f5000          MOV      r0,#0x2000
000444  f8c401d8          STR      r0,[r4,#0x1d8]
000448  f44f5080          MOV      r0,#0x1000
00044c  f8c401dc          STR      r0,[r4,#0x1dc]
000450  48f7              LDR      r0,|L1.2096|
000452  e026              B        |L1.1186|
                  |L1.1108|
000454  f04f0026          MOV      r0,#0x26
000458  75a0              STRB     r0,[r4,#0x16]
00045a  f44f3000          MOV      r0,#0x20000
00045e  6260              STR      r0,[r4,#0x24]
000460  f1bc0f00          CMP      r12,#0
000464  bf18              IT       NE
000466  4af3              LDRNE    r2,|L1.2100|
000468  61a2              STR      r2,[r4,#0x18]
00046a  bf14              ITE      NE
00046c  2020              MOVNE    r0,#0x20
00046e  2004              MOVEQ    r0,#4
000470  8260              STRH     r0,[r4,#0x12]
000472  bf14              ITE      NE
000474  2040              MOVNE    r0,#0x40
000476  2008              MOVEQ    r0,#8
000478  82a0              STRH     r0,[r4,#0x14]
00047a  bf14              ITE      NE
00047c  2020              MOVNE    r0,#0x20
00047e  2004              MOVEQ    r0,#4
000480  6220              STR      r0,[r4,#0x20]
000482  48ed              LDR      r0,|L1.2104|
000484  f8c401d4          STR      r0,[r4,#0x1d4]
000488  f04f0011          MOV      r0,#0x11
00048c  f88401d2          STRB     r0,[r4,#0x1d2]
000490  f04f7000          MOV      r0,#0x2000000
000494  f8c401d8          STR      r0,[r4,#0x1d8]
000498  f04f7080          MOV      r0,#0x1000000
00049c  f8c401dc          STR      r0,[r4,#0x1dc]
0004a0  48e6              LDR      r0,|L1.2108|
                  |L1.1186|
0004a2  6004              STR      r4,[r0,#0]  ; pCOM2
0004a4  e014              B        |L1.1232|
                  |L1.1190|
0004a6  f04f0127          MOV      r1,#0x27
0004aa  75a1              STRB     r1,[r4,#0x16]
0004ac  f44f2180          MOV      r1,#0x40000
0004b0  6261              STR      r1,[r4,#0x24]
0004b2  f1bc0f00          CMP      r12,#0
0004b6  bf18              IT       NE
0004b8  48e1              LDRNE    r0,|L1.2112|
0004ba  61a0              STR      r0,[r4,#0x18]
0004bc  f44f6080          MOV      r0,#0x400
0004c0  8260              STRH     r0,[r4,#0x12]
0004c2  f44f6000          MOV      r0,#0x800
0004c6  82a0              STRH     r0,[r4,#0x14]
0004c8  bf14              ITE      NE
0004ca  2010              MOVNE    r0,#0x10
0004cc  2008              MOVEQ    r0,#8
0004ce  6220              STR      r0,[r4,#0x20]
                  |L1.1232|
0004d0  4620              MOV      r0,r4
0004d2  f7fffffe          BL       _ZN5USART10InitializeEv ; USART::Initialize()
0004d6  4620              MOV      r0,r4
0004d8  e8bd9ff0          POP      {r4-r12,pc}
                          ENDP

                  _ZN5USART11SetBaudRateEj PROC ; USART::SetBaudRate(unsigned)
;;;210    
;;;211    void USART::SetBaudRate(uint32_t baudRate)
0004dc  b570              PUSH     {r4-r6,lr}
;;;212    {
0004de  b086              SUB      sp,sp,#0x18
0004e0  4605              MOV      r5,r0
;;;213    //	assert_param(IS_USART_BAUDRATE(baudRate));
;;;214    	uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;215    	uint32_t integerdivider = 0x00;
;;;216    	uint32_t fractionaldivider = 0x00;
;;;217    	uint32_t usartxbase = 0;
;;;218    	RCC_ClocksTypeDef RCC_ClocksStatus;
;;;219    
;;;220    	usartxbase = (uint32_t)mUSARTx;
;;;221    
;;;222    	/*---------------------------- USART BRR Configuration -----------------------*/
;;;223    	/* Configure the USART Baud Rate -------------------------------------------*/
;;;224    	RCC_GetClocksFreq(&RCC_ClocksStatus);
0004e2  69c6              LDR      r6,[r0,#0x1c]
0004e4  460c              MOV      r4,r1                 ;212
0004e6  4668              MOV      r0,sp
0004e8  f7fffffe          BL       RCC_GetClocksFreq
;;;225    	if (usartxbase == USART1_BASE)
0004ec  f1a64080          SUB      r0,r6,#0x40000000
0004f0  f5b0309c          SUBS     r0,r0,#0x13800
;;;226    	{
;;;227    	apbclock = RCC_ClocksStatus.PCLK2_Frequency;
0004f4  bf0c              ITE      EQ
0004f6  9a03              LDREQ    r2,[sp,#0xc]
;;;228    	}
;;;229    	else
;;;230    	{
;;;231    	apbclock = RCC_ClocksStatus.PCLK1_Frequency;
0004f8  9a02              LDRNE    r2,[sp,#8]
;;;232    	}
;;;233    
;;;234    	/* Determine the integer part */
;;;235    	if ((mUSARTx->CR1 & ((u16)0x8000)) != 0)//CR1_OVER8_Set=((u16)0x8000)
0004fa  69eb              LDR      r3,[r5,#0x1c]
0004fc  8998              LDRH     r0,[r3,#0xc]
0004fe  f4104f00          TST      r0,#0x8000
;;;236    	{
;;;237    	/* Integer part computing in case Oversampling mode is 8 Samples */
;;;238    	integerdivider = ((25 * apbclock) / (2 * (baudRate)));    
;;;239    	}
;;;240    	else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;241    	{
;;;242    	/* Integer part computing in case Oversampling mode is 16 Samples */
;;;243    	integerdivider = ((25 * apbclock) / (4 * (baudRate)));    
000502  eb0200c2          ADD      r0,r2,r2,LSL #3
000506  eb001002          ADD      r0,r0,r2,LSL #4
00050a  bf14              ITE      NE                    ;238
00050c  0061              LSLNE    r1,r4,#1              ;238
00050e  00a1              LSLEQ    r1,r4,#2
000510  fbb0f0f1          UDIV     r0,r0,r1
;;;244    	}
;;;245    	tmpreg = (integerdivider / 100) << 4;
000514  4acb              LDR      r2,|L1.2116|
;;;246    
;;;247    	/* Determine the fractional part */
;;;248    	fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000516  f06f0418          MVN      r4,#0x18
00051a  fba2c100          UMULL    r12,r1,r2,r0          ;245
00051e  0949              LSRS     r1,r1,#5              ;245
000520  0109              LSLS     r1,r1,#4              ;245
000522  ea4f1c11          LSR      r12,r1,#4
000526  fb0cfc04          MUL      r12,r12,r4
00052a  eb00008c          ADD      r0,r0,r12,LSL #2
;;;249    
;;;250    	/* Implement the fractional part in the register */
;;;251    	if ((mUSARTx->CR1 & ((u16)0x8000)) != 0)
00052e  f8b3c00c          LDRH     r12,[r3,#0xc]
000532  f41c4f00          TST      r12,#0x8000
;;;252    	{
;;;253    	tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000536  f04f0c32          MOV      r12,#0x32
00053a  bf14              ITE      NE
00053c  eb0c00c0          ADDNE    r0,r12,r0,LSL #3
;;;254    	}
;;;255    	else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;256    	{
;;;257    	tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
000540  eb0c1000          ADDEQ    r0,r12,r0,LSL #4
000544  fba22000          UMULL    r2,r0,r2,r0
000548  ea4f1050          LSR      r0,r0,#5
00054c  bf14              ITE      NE                    ;253
00054e  f0000007          ANDNE    r0,r0,#7              ;253
000552  f000000f          ANDEQ    r0,r0,#0xf
000556  4308              ORRS     r0,r0,r1
;;;258    	}
;;;259    
;;;260    	/* Write to USART BRR */
;;;261    	mUSARTx->BRR = (uint16_t)tmpreg;
000558  8118              STRH     r0,[r3,#8]
;;;262    }
00055a  b006              ADD      sp,sp,#0x18
00055c  bd70              POP      {r4-r6,pc}
;;;263    
                          ENDP

                  _ZN5USART9SendBytesEPht PROC ; USART::SendBytes(unsigned char*, unsigned short)
;;;172    
;;;173    bool USART::SendBytes(u8 txData[], u16 size)
00055e  b570              PUSH     {r4-r6,lr}
;;;174    {
;;;175    	if(mTxBuf.ResSize()<size)      //compare the unused bytes and sending bytes
000560  f8b030f4          LDRH     r3,[r0,#0xf4]
000564  f8b0c0f6          LDRH     r12,[r0,#0xf6]
000568  4604              MOV      r4,r0                 ;174
00056a  eba3000c          SUB      r0,r3,r12
00056e  b280              UXTH     r0,r0
000570  4290              CMP      r0,r2
000572  d206              BCS      |L1.1410|
;;;176    	{
;;;177    		mTxOverflow += size;         //flash Tx overflow bytes
000574  f8b401ce          LDRH     r0,[r4,#0x1ce]
000578  4410              ADD      r0,r0,r2
00057a  f8a401ce          STRH     r0,[r4,#0x1ce]
;;;178    		return false;
00057e  2000              MOVS     r0,#0
;;;179    	}
;;;180    	mTxBuf.Puts(txData,size);                        //add data to Tx buffer, if overflow, return false
;;;181    	if(isBusySend)                return true;       //USARTx is busy send data, return
;;;182    	if(mTxBuf.Size() <= 0)        return true;       //have no data to send, return
;;;183    	isBusySend = true;                               //set busy state, going to send data
;;;184    #ifdef USE_USART_DMA
;;;185    	if(mTxBuf.Size() <= USART_DMA_TX_BUFFER_SIZE)  //rest data bytes less than DMA buffer size
;;;186    	{
;;;187    		mDMATxCh->CNDTR = (u32)mTxBuf.Size();        //send all data to DMA buffer
;;;188    		mTxBuf.Gets(mDMATxBuf,mTxBuf.Size());
;;;189    	}
;;;190    	else                                           //rest data bytes more than DMA buffer size
;;;191    	{
;;;192    		mDMATxCh->CNDTR = USART_DMA_TX_BUFFER_SIZE;  //send max DMA buffer size data to DMA buffer
;;;193    		mTxBuf.Gets(mDMATxBuf,USART_DMA_TX_BUFFER_SIZE);
;;;194    	}
;;;195    	DMA_Cmd(mDMATxCh,ENABLE); 	                   //enable DMA to send data
;;;196    #else	
;;;197    	USART_ClearITPendingBit(mUSARTx, USART_IT_TC); //Clear TC, otherwise the first byte may not able to send out
;;;198    	USART_ClearITPendingBit(mUSARTx, USART_IT_TXE); //Clear TC, otherwise the first byte may not able to send out
;;;199    	USART_ITConfig(mUSARTx, USART_IT_TC, ENABLE);  //Enable TC, going to send data
;;;200    	//USART_ITConfig(mUSARTx, USART_IT_TXE, ENABLE);  //Enable TC, going to send data
;;;201    	USART_GetFlagStatus(mUSARTx, USART_FLAG_TC);   //read SR to clear flag, otherwise the first byte may not able to send out
;;;202    	//USART_GetFlagStatus(mUSARTx, USART_FLAG_TXE);   //read SR to clear flag, otherwise the first byte may not able to send out
;;;203    	static u8 data=0;
;;;204    	mTxBuf.Get(data);                              //get one byte data from tx buffer
;;;205    	USART_SendData(mUSARTx,data);                  //send one byte data
;;;206    #endif	
;;;207    	return true;
;;;208    }
000580  bd70              POP      {r4-r6,pc}
                  |L1.1410|
000582  4494              ADD      r12,r12,r2
000584  f104002c          ADD      r0,r4,#0x2c           ;180
000588  459c              CMP      r12,r3                ;180
00058a  d822              BHI      |L1.1490|
00058c  2300              MOVS     r3,#0                 ;180
00058e  2a00              CMP      r2,#0                 ;180
000590  bf88              IT       HI                    ;180
000592  2500              MOVHI    r5,#0                 ;180
000594  d918              BLS      |L1.1480|
000596  bf00              NOP                            ;180
                  |L1.1432|
000598  f8b060ce          LDRH     r6,[r0,#0xce]         ;180
00059c  f811c003          LDRB     r12,[r1,r3]           ;180
0005a0  f800c006          STRB     r12,[r0,r6]           ;180
0005a4  f8b0c0ce          LDRH     r12,[r0,#0xce]        ;180
0005a8  f10c0c01          ADD      r12,r12,#1            ;180
0005ac  fa1ffc8c          UXTH     r12,r12               ;180
0005b0  f8a0c0ce          STRH     r12,[r0,#0xce]        ;180
0005b4  f8b060c8          LDRH     r6,[r0,#0xc8]         ;180
0005b8  45b4              CMP      r12,r6                ;180
0005ba  bf28              IT       CS                    ;180
0005bc  f8a050ce          STRHCS   r5,[r0,#0xce]         ;180
0005c0  1c5b              ADDS     r3,r3,#1              ;180
0005c2  b29b              UXTH     r3,r3                 ;180
0005c4  4293              CMP      r3,r2                 ;180
0005c6  d3e7              BCC      |L1.1432|
                  |L1.1480|
0005c8  f8b010ca          LDRH     r1,[r0,#0xca]         ;180
0005cc  4411              ADD      r1,r1,r2              ;180
0005ce  f8a010ca          STRH     r1,[r0,#0xca]         ;180
                  |L1.1490|
0005d2  7920              LDRB     r0,[r4,#4]            ;181
0005d4  b990              CBNZ     r0,|L1.1532|
0005d6  f8b400f6          LDRH     r0,[r4,#0xf6]         ;182
0005da  b178              CBZ      r0,|L1.1532|
0005dc  2101              MOVS     r1,#1                 ;183
0005de  7121              STRB     r1,[r4,#4]            ;183
0005e0  28c8              CMP      r0,#0xc8              ;185
0005e2  d80d              BHI      |L1.1536|
0005e4  f8d411d4          LDR      r1,[r4,#0x1d4]        ;187
0005e8  6048              STR      r0,[r1,#4]            ;187
0005ea  f8b420f6          LDRH     r2,[r4,#0xf6]         ;187
0005ee  f50471f0          ADD      r1,r4,#0x1e0          ;188
0005f2  f104002c          ADD      r0,r4,#0x2c           ;188
0005f6  f7fffffe          BL       _ZN10FIFOBufferIhLt200EE4GetsEPht ; FIFOBuffer<unsigned char, (unsigned short)200>::Gets(unsigned char*, unsigned short)
0005fa  e00c              B        |L1.1558|
                  |L1.1532|
0005fc  2001              MOVS     r0,#1                 ;182
0005fe  bd70              POP      {r4-r6,pc}
                  |L1.1536|
000600  f8d411d4          LDR      r1,[r4,#0x1d4]        ;192
000604  20c8              MOVS     r0,#0xc8              ;192
000606  6048              STR      r0,[r1,#4]            ;192
000608  4602              MOV      r2,r0                 ;193
00060a  f50471f0          ADD      r1,r4,#0x1e0          ;193
00060e  f104002c          ADD      r0,r4,#0x2c           ;193
000612  f7fffffe          BL       _ZN10FIFOBufferIhLt200EE4GetsEPht ; FIFOBuffer<unsigned char, (unsigned short)200>::Gets(unsigned char*, unsigned short)
                  |L1.1558|
000616  2101              MOVS     r1,#1                 ;195
000618  f8d401d4          LDR      r0,[r4,#0x1d4]        ;195
00061c  f7fffffe          BL       DMA_Cmd
000620  2001              MOVS     r0,#1                 ;207
000622  bd70              POP      {r4-r6,pc}
;;;209    
                          ENDP

                  _ZN5USART8SendByteEh PROC ; USART::SendByte(unsigned char)
;;;263    
;;;264    bool USART::SendByte(u8 data)
000624  b410              PUSH     {r4}
000626  f8b0c0f6          LDRH     r12,[r0,#0xf6]
00062a  f8b040f4          LDRH     r4,[r0,#0xf4]
00062e  2300              MOVS     r3,#0
;;;265    {
;;;266    	if(mTxBuf.Put(data))
000630  f100022c          ADD      r2,r0,#0x2c
000634  45a4              CMP      r12,r4
000636  d307              BCC      |L1.1608|
;;;267    		return true;
;;;268    	mTxOverflow++;
000638  f8b011ce          LDRH     r1,[r0,#0x1ce]
00063c  1c49              ADDS     r1,r1,#1
00063e  f8a011ce          STRH     r1,[r0,#0x1ce]
;;;269    	return false;
;;;270    }
000642  bc10              POP      {r4}
000644  2000              MOVS     r0,#0                 ;269
000646  4770              BX       lr
                  |L1.1608|
000648  f8b200ce          LDRH     r0,[r2,#0xce]
00064c  f1000c01          ADD      r12,r0,#1
000650  f8a2c0ce          STRH     r12,[r2,#0xce]
000654  5411              STRB     r1,[r2,r0]
000656  f8b200ce          LDRH     r0,[r2,#0xce]
00065a  f8b210c8          LDRH     r1,[r2,#0xc8]
00065e  4288              CMP      r0,r1
000660  bf28              IT       CS
000662  f8a230ce          STRHCS   r3,[r2,#0xce]
000666  f8b200ca          LDRH     r0,[r2,#0xca]
00066a  1c40              ADDS     r0,r0,#1
00066c  f8a200ca          STRH     r0,[r2,#0xca]
000670  bc10              POP      {r4}
000672  2001              MOVS     r0,#1                 ;267
000674  4770              BX       lr
;;;271    bool USART::GetBytes(u8 data[],u16 num)
                          ENDP

                  _ZN5USART8GetBytesEPht PROC ; USART::GetBytes(unsigned char*, unsigned short)
000676  30fc              ADDS     r0,r0,#0xfc
;;;272    {
;;;273    		return mRxBuf.Gets(data,num);
000678  f7ffbffe          B.W      _ZN10FIFOBufferIhLt200EE4GetsEPht ; FIFOBuffer<unsigned char, (unsigned short)200>::Gets(unsigned char*, unsigned short)
;;;274    }
;;;275    bool USART::GetByte(u8 &data)
                          ENDP

                  _ZN5USART7GetByteERh PROC ; USART::GetByte(unsigned char&)
00067c  30fc              ADDS     r0,r0,#0xfc
;;;276    {
;;;277    	return mRxBuf.Get(data);
00067e  f7ffbffe          B.W      _ZN10FIFOBufferIhLt200EE3GetERh ; FIFOBuffer<unsigned char, (unsigned short)200>::Get(unsigned char&)
;;;278    }
;;;279    
                          ENDP

                  _ZN5USART6TxSizeEv PROC ; USART::TxSize()
;;;285    
;;;286    u16 USART::TxSize()
000682  f8b000f6          LDRH     r0,[r0,#0xf6]
;;;287    {
;;;288    	return mTxBuf.Size();
;;;289    }
000686  4770              BX       lr
;;;290    
                          ENDP

                  _ZN5USART6RxSizeEv PROC ; USART::RxSize()
;;;280    
;;;281    u16 USART::RxSize()
000688  f8b001c6          LDRH     r0,[r0,#0x1c6]
;;;282    {
;;;283    	return mRxBuf.Size();
;;;284    }
00068c  4770              BX       lr
;;;285    
                          ENDP

                  _ZN5USART14TxOverflowSizeEv PROC ; USART::TxOverflowSize()
;;;290    
;;;291    u16 USART::TxOverflowSize()
00068e  f8b001ce          LDRH     r0,[r0,#0x1ce]
;;;292    {
;;;293    	return mTxOverflow;
;;;294    }
000692  4770              BX       lr
;;;295    
                          ENDP

                  _ZN5USART14RxOverflowSizeEv PROC ; USART::RxOverflowSize()
;;;296    u16 USART::RxOverflowSize()
000694  f8b001d0          LDRH     r0,[r0,#0x1d0]
;;;297    {
;;;298    	return mRxOverflow;
;;;299    }
000698  4770              BX       lr
;;;300    
                          ENDP

                  _ZN5USART10ClearRxBufEv PROC ; USART::ClearRxBuf()
;;;301    void USART::ClearRxBuf()
00069a  2100              MOVS     r1,#0
00069c  f8a011c6          STRH     r1,[r0,#0x1c6]
0006a0  f8a011c8          STRH     r1,[r0,#0x1c8]
0006a4  f8a011ca          STRH     r1,[r0,#0x1ca]
;;;302    {
;;;303    	mRxBuf.Clear();
;;;304    }
0006a8  4770              BX       lr
;;;305    
                          ENDP

                  _ZN5USART10ClearTxBufEv PROC ; USART::ClearTxBuf()
;;;306    void USART::ClearTxBuf()
0006aa  2100              MOVS     r1,#0
0006ac  f8a010f6          STRH     r1,[r0,#0xf6]
0006b0  f8a010f8          STRH     r1,[r0,#0xf8]
0006b4  f8a010fa          STRH     r1,[r0,#0xfa]
;;;307    {
;;;308    	mTxBuf.Clear();
;;;309    }
0006b8  4770              BX       lr
;;;310    
                          ENDP

                  _ZN5USART10CheckFrameER9DataFrame PROC ; USART::CheckFrame(DataFrame&)
;;;368    
;;;369    bool USART::CheckFrame(DataFrame &df)
0006ba  e92d5ff0          PUSH     {r4-r12,lr}
;;;370    {
;;;371    	
;;;372    	return mRxBuf.CheckFrame(df);;
0006be  f10004fc          ADD      r4,r0,#0xfc
0006c2  460e              MOV      r6,r1
0006c4  f05f0500          MOVS.W   r5,#0
                  |L1.1736|
0006c8  f8b470ca          LDRH     r7,[r4,#0xca]
0006cc  b1c7              CBZ      r7,|L1.1792|
0006ce  f8b490cc          LDRH     r9,[r4,#0xcc]
0006d2  7831              LDRB     r1,[r6,#0]
0006d4  f8140009          LDRB     r0,[r4,r9]
0006d8  4288              CMP      r0,r1
0006da  d00e              BEQ      |L1.1786|
0006dc  f1090001          ADD      r0,r9,#1
0006e0  b280              UXTH     r0,r0
0006e2  f8a400cc          STRH     r0,[r4,#0xcc]
0006e6  f8b410c8          LDRH     r1,[r4,#0xc8]
0006ea  4288              CMP      r0,r1
0006ec  bf28              IT       CS
0006ee  f8a450cc          STRHCS   r5,[r4,#0xcc]
0006f2  1e78              SUBS     r0,r7,#1
0006f4  f8a400ca          STRH     r0,[r4,#0xca]
0006f8  e7e6              B        |L1.1736|
                  |L1.1786|
0006fa  b2b8              UXTH     r0,r7
0006fc  2804              CMP      r0,#4
0006fe  d202              BCS      |L1.1798|
                  |L1.1792|
000700  4628              MOV      r0,r5
;;;373    }
000702  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1798|
000706  fa1ff089          UXTH     r0,r9
00070a  f1000c01          ADD      r12,r0,#1
00070e  f8b400c8          LDRH     r0,[r4,#0xc8]
000712  fa1ff18c          UXTH     r1,r12
000716  4281              CMP      r1,r0
000718  bf24              ITT      CS
00071a  1a09              SUBCS    r1,r1,r0
00071c  b289              UXTHCS   r1,r1
00071e  5c63              LDRB     r3,[r4,r1]
000720  2b0c              CMP      r3,#0xc
000722  d90f              BLS      |L1.1860|
000724  fa1ff08c          UXTH     r0,r12
000728  f8a400cc          STRH     r0,[r4,#0xcc]
00072c  f8b410c8          LDRH     r1,[r4,#0xc8]
000730  4281              CMP      r1,r0
000732  d91d              BLS      |L1.1904|
                  |L1.1844|
000734  f8b400ca          LDRH     r0,[r4,#0xca]
000738  1e40              SUBS     r0,r0,#1
00073a  f8a400ca          STRH     r0,[r4,#0xca]
00073e  4628              MOV      r0,r5
000740  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1860|
000744  f1090102          ADD      r1,r9,#2
000748  b289              UXTH     r1,r1
00074a  4288              CMP      r0,r1
00074c  bf9c              ITT      LS
00074e  1a09              SUBLS    r1,r1,r0
000750  b289              UXTHLS   r1,r1
000752  5c62              LDRB     r2,[r4,r1]
000754  493c              LDR      r1,|L1.2120|
000756  eb010143          ADD      r1,r1,r3,LSL #1
00075a  7849              LDRB     r1,[r1,#1]
00075c  4291              CMP      r1,r2
00075e  d00a              BEQ      |L1.1910|
000760  fa1ff08c          UXTH     r0,r12
000764  f8a400cc          STRH     r0,[r4,#0xcc]
000768  f8b410c8          LDRH     r1,[r4,#0xc8]
00076c  4288              CMP      r0,r1
00076e  d3e1              BCC      |L1.1844|
                  |L1.1904|
000770  f8a450cc          STRH     r5,[r4,#0xcc]
000774  e7de              B        |L1.1844|
                  |L1.1910|
000776  1d11              ADDS     r1,r2,#4
000778  428f              CMP      r7,r1
00077a  d3c1              BCC      |L1.1792|
00077c  f04f0800          MOV      r8,#0
000780  1cd1              ADDS     r1,r2,#3
000782  4643              MOV      r3,r8
000784  f0010aff          AND      r10,r1,#0xff
                  |L1.1928|
000788  eb090103          ADD      r1,r9,r3
00078c  b289              UXTH     r1,r1
00078e  4288              CMP      r0,r1
000790  bf9c              ITT      LS
000792  1a09              SUBLS    r1,r1,r0
000794  b289              UXTHLS   r1,r1
000796  f814b001          LDRB     r11,[r4,r1]
00079a  1c5b              ADDS     r3,r3,#1
00079c  44d8              ADD      r8,r8,r11
00079e  f1aa0a01          SUB      r10,r10,#1
0007a2  f00808ff          AND      r8,r8,#0xff
0007a6  f01a0aff          ANDS     r10,r10,#0xff
0007aa  d1ed              BNE      |L1.1928|
0007ac  1c49              ADDS     r1,r1,#1
0007ae  b289              UXTH     r1,r1
0007b0  4281              CMP      r1,r0
0007b2  bf24              ITT      CS
0007b4  1a08              SUBCS    r0,r1,r0
0007b6  b281              UXTHCS   r1,r0
0007b8  5c60              LDRB     r0,[r4,r1]
0007ba  4540              CMP      r0,r8
0007bc  d011              BEQ      |L1.2018|
0007be  2f00              CMP      r7,#0
0007c0  d09e              BEQ      |L1.1792|
0007c2  fa1ff08c          UXTH     r0,r12
0007c6  f8a400cc          STRH     r0,[r4,#0xcc]
0007ca  f8b410c8          LDRH     r1,[r4,#0xc8]
0007ce  4288              CMP      r0,r1
0007d0  bf28              IT       CS
0007d2  f8a450cc          STRHCS   r5,[r4,#0xcc]
0007d6  f8b400ca          LDRH     r0,[r4,#0xca]
0007da  1e40              SUBS     r0,r0,#1
0007dc  f8a400ca          STRH     r0,[r4,#0xca]
0007e0  e78e              B        |L1.1792|
                  |L1.2018|
0007e2  b177              CBZ      r7,|L1.2050|
0007e4  fa1ff08c          UXTH     r0,r12
0007e8  f8a400cc          STRH     r0,[r4,#0xcc]
0007ec  f8b410c8          LDRH     r1,[r4,#0xc8]
0007f0  4288              CMP      r0,r1
0007f2  bf28              IT       CS
0007f4  f8a450cc          STRHCS   r5,[r4,#0xcc]
0007f8  f8b400ca          LDRH     r0,[r4,#0xca]
0007fc  1e40              SUBS     r0,r0,#1
0007fe  f8a400ca          STRH     r0,[r4,#0xca]
                  |L1.2050|
000802  f8b400ca          LDRH     r0,[r4,#0xca]
000806  b320              CBZ      r0,|L1.2130|
000808  f8b410cc          LDRH     r1,[r4,#0xcc]
00080c  1c4b              ADDS     r3,r1,#1
00080e  f8a430cc          STRH     r3,[r4,#0xcc]
000812  5c60              LDRB     r0,[r4,r1]
000814  7070              STRB     r0,[r6,#1]
000816  f8b410cc          LDRH     r1,[r4,#0xcc]
00081a  f8b400c8          LDRH     r0,[r4,#0xc8]
00081e  4281              CMP      r1,r0
000820  bf28              IT       CS
000822  f8a450cc          STRHCS   r5,[r4,#0xcc]
000826  f8b400ca          LDRH     r0,[r4,#0xca]
00082a  e00f              B        |L1.2124|
                  |L1.2092|
                          DCD      0x40020044
                  |L1.2096|
                          DCD      pCOM1
                  |L1.2100|
                          DCD      0x40011400
                  |L1.2104|
                          DCD      0x40020080
                  |L1.2108|
                          DCD      pCOM2
                  |L1.2112|
                          DCD      0x40011000
                  |L1.2116|
                          DCD      0x51eb851f
                  |L1.2120|
                          DCD      ||.constdata||
                  |L1.2124|
00084c  1e40              SUBS     r0,r0,#1
00084e  f8a400ca          STRH     r0,[r4,#0xca]
                  |L1.2130|
000852  0400              LSLS     r0,r0,#16
000854  0c00              LSRS     r0,r0,#16
000856  d013              BEQ      |L1.2176|
000858  f8b410cc          LDRH     r1,[r4,#0xcc]
00085c  1c4b              ADDS     r3,r1,#1
00085e  f8a430cc          STRH     r3,[r4,#0xcc]
000862  5c60              LDRB     r0,[r4,r1]
000864  70b0              STRB     r0,[r6,#2]
000866  f8b410cc          LDRH     r1,[r4,#0xcc]
00086a  f8b400c8          LDRH     r0,[r4,#0xc8]
00086e  4288              CMP      r0,r1
000870  bf98              IT       LS
000872  f8a450cc          STRHLS   r5,[r4,#0xcc]
000876  f8b400ca          LDRH     r0,[r4,#0xca]
00087a  1e40              SUBS     r0,r0,#1
00087c  f8a400ca          STRH     r0,[r4,#0xca]
                  |L1.2176|
000880  1cf1              ADDS     r1,r6,#3
000882  4620              MOV      r0,r4
000884  f7fffffe          BL       _ZN10FIFOBufferIhLt200EE4GetsEPht ; FIFOBuffer<unsigned char, (unsigned short)200>::Gets(unsigned char*, unsigned short)
000888  f8b400ca          LDRH     r0,[r4,#0xca]
00088c  b1a0              CBZ      r0,|L1.2232|
00088e  f8b400cc          LDRH     r0,[r4,#0xcc]
000892  1c41              ADDS     r1,r0,#1
000894  f8a410cc          STRH     r1,[r4,#0xcc]
000898  5c20              LDRB     r0,[r4,r0]
00089a  f8860036          STRB     r0,[r6,#0x36]
00089e  f8b400cc          LDRH     r0,[r4,#0xcc]
0008a2  f8b410c8          LDRH     r1,[r4,#0xc8]
0008a6  4288              CMP      r0,r1
0008a8  bf28              IT       CS
0008aa  f8a450cc          STRHCS   r5,[r4,#0xcc]
0008ae  f8b400ca          LDRH     r0,[r4,#0xca]
0008b2  1e40              SUBS     r0,r0,#1
0008b4  f8a400ca          STRH     r0,[r4,#0xca]
                  |L1.2232|
0008b8  2001              MOVS     r0,#1
0008ba  f8860035          STRB     r0,[r6,#0x35]
0008be  e8bd9ff0          POP      {r4-r12,pc}
;;;374    
                          ENDP

                  _ZN5USART3IRQEv PROC ; USART::IRQ()
;;;375    
;;;376    void USART::IRQ()
0008c2  b570              PUSH     {r4-r6,lr}
;;;377    {	
0008c4  4605              MOV      r5,r0
;;;378    	if (USART_GetFlagStatus(mUSARTx, USART_FLAG_ORE) != RESET)
0008c6  69c0              LDR      r0,[r0,#0x1c]
0008c8  2108              MOVS     r1,#8
0008ca  f7fffffe          BL       USART_GetFlagStatus
0008ce  2800              CMP      r0,#0
;;;379    	{
;;;380    			USART_ReceiveData(mUSARTx);
0008d0  bf1c              ITT      NE
0008d2  69e8              LDRNE    r0,[r5,#0x1c]
0008d4  f7fffffe          BLNE     USART_ReceiveData
;;;381    	}
;;;382    	if(USART_GetITStatus(mUSARTx,USART_IT_RXNE)!=RESET)  //RxNE
0008d8  f2405125          MOV      r1,#0x525
0008dc  69e8              LDR      r0,[r5,#0x1c]
0008de  f7fffffe          BL       USART_GetITStatus
0008e2  2800              CMP      r0,#0                 ;378
;;;383    	{
;;;384    		USART_ClearITPendingBit(mUSARTx,USART_IT_RXNE);    //Clear RxNE
;;;385    		if(!mRxBuf.Put(USART_ReceiveData(mUSARTx)))        //receive byte
;;;386    		{
;;;387    			USART1->DR = mUSARTx->DR;
;;;388    			mRxOverflow++;
;;;389    		}
;;;390    	}
;;;391    	
;;;392    #ifndef USE_USART_DMA
;;;393    	
;;;394    	u8 data = 0;
;;;395    	if(USART_GetITStatus(mUSARTx,USART_IT_TXE)!=RESET || USART_GetITStatus(mUSARTx,USART_IT_TC)!=RESET)   //TxE and TC
;;;396    	{
;;;397    		if(mTxBuf.Size()>0)                                //still left some bytes of data
;;;398    		{
;;;399    			mTxBuf.Get(data);                                //get one byte data from buffer
;;;400    			mUSARTx->DR = (data & (u16)0x01FF);              //send one byte data
;;;401    		}
;;;402    	  else                                               //all data send complete
;;;403    		{
;;;404    			USART_ITConfig(mUSARTx, USART_IT_TXE, DISABLE);  //disable TxE
;;;405    			USART_ITConfig(mUSARTx, USART_IT_TC, DISABLE);   //disable TC
;;;406    			isBusySend = false;                              //set free state
;;;407    		}
;;;408    	}
;;;409    #endif
;;;410    }
0008e4  bf08              IT       EQ
0008e6  bd70              POPEQ    {r4-r6,pc}
0008e8  f2405125          MOV      r1,#0x525             ;384
0008ec  69e8              LDR      r0,[r5,#0x1c]         ;384
0008ee  f7fffffe          BL       USART_ClearITPendingBit
0008f2  f10504fc          ADD      r4,r5,#0xfc           ;385
0008f6  69e8              LDR      r0,[r5,#0x1c]         ;385
0008f8  f7fffffe          BL       USART_ReceiveData
0008fc  f8b410ca          LDRH     r1,[r4,#0xca]         ;385
000900  f8b430c8          LDRH     r3,[r4,#0xc8]         ;385
000904  2200              MOVS     r2,#0                 ;385
000906  b2c0              UXTB     r0,r0                 ;385
000908  4299              CMP      r1,r3                 ;385
00090a  d309              BCC      |L1.2336|
00090c  69e8              LDR      r0,[r5,#0x1c]         ;387
00090e  8880              LDRH     r0,[r0,#4]            ;387
000910  4981              LDR      r1,|L1.2840|
000912  8008              STRH     r0,[r1,#0]            ;387
000914  f8b501d0          LDRH     r0,[r5,#0x1d0]        ;388
000918  1c40              ADDS     r0,r0,#1              ;388
00091a  f8a501d0          STRH     r0,[r5,#0x1d0]        ;388
00091e  bd70              POP      {r4-r6,pc}
                  |L1.2336|
000920  f8b410ce          LDRH     r1,[r4,#0xce]
000924  1c4b              ADDS     r3,r1,#1
000926  f8a430ce          STRH     r3,[r4,#0xce]
00092a  5460              STRB     r0,[r4,r1]
00092c  f8b400ce          LDRH     r0,[r4,#0xce]
000930  f8b410c8          LDRH     r1,[r4,#0xc8]
000934  4288              CMP      r0,r1
000936  bf28              IT       CS
000938  f8a420ce          STRHCS   r2,[r4,#0xce]
00093c  f8b400ca          LDRH     r0,[r4,#0xca]
000940  1c40              ADDS     r0,r0,#1
000942  f8a400ca          STRH     r0,[r4,#0xca]
000946  bd70              POP      {r4-r6,pc}
;;;411    
                          ENDP

                  _ZN5USARTlsEi PROC ; USART::operator <<(int)
;;;310    
;;;311    USART& USART::operator<<(int val)
000948  b570              PUSH     {r4-r6,lr}
;;;312    {
00094a  4604              MOV      r4,r0
;;;313    	u8 sign = 0, len = 0,data[10];
00094c  2000              MOVS     r0,#0
00094e  b084              SUB      sp,sp,#0x10           ;312
000950  4602              MOV      r2,r0
;;;314    	if(val<0)
000952  2900              CMP      r1,#0
;;;315    	{
;;;316    		sign = 1;
000954  bfbc              ITT      LT
000956  2001              MOVLT    r0,#1
;;;317    		val = -val;
000958  4249              RSBLT    r1,r1,#0
;;;318    	}
;;;319    	do
;;;320    	{
;;;321    		len++;
;;;322    		data[10-len] = val%10 + '0';
00095a  4d70              LDR      r5,|L1.2844|
00095c  466b              MOV      r3,sp                 ;313
                  |L1.2398|
00095e  fb856c01          SMULL    r6,r12,r5,r1
000962  ea4f06ac          ASR      r6,r12,#2
000966  eba67cec          SUB      r12,r6,r12,ASR #31
00096a  f1cc0600          RSB      r6,r12,#0
00096e  1c52              ADDS     r2,r2,#1              ;313
000970  eb060686          ADD      r6,r6,r6,LSL #2
000974  b2d2              UXTB     r2,r2                 ;321
000976  eb010146          ADD      r1,r1,r6,LSL #1
00097a  f1c2060a          RSB      r6,r2,#0xa
00097e  3130              ADDS     r1,r1,#0x30
000980  5599              STRB     r1,[r3,r6]
;;;323    		val = val/10;
000982  ea5f010c          MOVS     r1,r12
000986  d1ea              BNE      |L1.2398|
;;;324    	}while(val);
;;;325    	if(sign==1)
000988  b128              CBZ      r0,|L1.2454|
;;;326    		data[10-(++len)] = '-';
00098a  202d              MOVS     r0,#0x2d
00098c  1c51              ADDS     r1,r2,#1
00098e  b2ca              UXTB     r2,r1
000990  f1c2010a          RSB      r1,r2,#0xa
000994  5458              STRB     r0,[r3,r1]
                  |L1.2454|
;;;327    	SendBytes(data+10-len,len);
000996  1a98              SUBS     r0,r3,r2
000998  f100010a          ADD      r1,r0,#0xa
00099c  6820              LDR      r0,[r4,#0]
00099e  6803              LDR      r3,[r0,#0]
0009a0  4620              MOV      r0,r4
0009a2  4798              BLX      r3
;;;328    	return *this;
;;;329    }
0009a4  b004              ADD      sp,sp,#0x10
0009a6  4620              MOV      r0,r4                 ;328
0009a8  bd70              POP      {r4-r6,pc}
;;;330    USART& USART::operator<<(double val)
                          ENDP

                  _ZN5USARTlsEd PROC ; USART::operator <<(double)
0009aa  e92d47f0          PUSH     {r4-r10,lr}
;;;331    {
;;;332    	u8 sign = 0, len = 0,data[20];
0009ae  f04f0900          MOV      r9,#0
0009b2  4615              MOV      r5,r2                 ;331
0009b4  461e              MOV      r6,r3                 ;331
0009b6  4607              MOV      r7,r0                 ;331
0009b8  b086              SUB      sp,sp,#0x18           ;331
0009ba  464c              MOV      r4,r9
;;;333    	if(val<0)
0009bc  464a              MOV      r2,r9
0009be  464b              MOV      r3,r9
0009c0  4628              MOV      r0,r5
0009c2  4631              MOV      r1,r6
0009c4  f7fffffe          BL       __aeabi_cdcmple
;;;334    	{
;;;335    		sign = 1;
0009c8  bf3c              ITT      CC
0009ca  f04f0901          MOVCC    r9,#1
0009ce  f0864600          EORCC    r6,r6,#0x80000000
;;;336    		val = -val;
;;;337    	}
;;;338    	u8 prec = mPrecision;
0009d2  f89701cc          LDRB     r0,[r7,#0x1cc]
;;;339    	while(prec--)
0009d6  f1a00801          SUB      r8,r0,#1
0009da  f1b83fff          CMP      r8,#0xffffffff
;;;340    		val *= 10;
0009de  bfc8              IT       GT
0009e0  f8dfa13c          LDRGT    r10,|L1.2848|
0009e4  dd0c              BLE      |L1.2560|
                  |L1.2534|
0009e6  2200              MOVS     r2,#0
0009e8  4653              MOV      r3,r10
0009ea  4628              MOV      r0,r5
0009ec  4631              MOV      r1,r6
0009ee  f7fffffe          BL       __aeabi_dmul
0009f2  f1a80801          SUB      r8,r8,#1
0009f6  4605              MOV      r5,r0
0009f8  460e              MOV      r6,r1
0009fa  f1b83fff          CMP      r8,#0xffffffff
0009fe  dcf2              BGT      |L1.2534|
                  |L1.2560|
;;;341    	u32 t = val;
000a00  4628              MOV      r0,r5
000a02  4631              MOV      r1,r6
000a04  f7fffffe          BL       __aeabi_d2uiz
;;;342    	do
;;;343    	{
;;;344    		if(++len==mPrecision+1) data[20-len] = '.';
;;;345    		else
;;;346    		{
;;;347    			data[20-len] = t%10 + '0';
000a08  4b46              LDR      r3,|L1.2852|
000a0a  f04f0c2e          MOV      r12,#0x2e             ;344
000a0e  4669              MOV      r1,sp                 ;332
                  |L1.2576|
000a10  1c62              ADDS     r2,r4,#1              ;344
000a12  b2d4              UXTB     r4,r2                 ;344
000a14  f89721cc          LDRB     r2,[r7,#0x1cc]        ;344
000a18  1c52              ADDS     r2,r2,#1              ;344
000a1a  4294              CMP      r4,r2                 ;344
000a1c  bf04              ITT      EQ                    ;344
000a1e  f1c40214          RSBEQ    r2,r4,#0x14           ;344
000a22  f801c002          STRBEQ   r12,[r1,r2]           ;344
000a26  d00c              BEQ      |L1.2626|
000a28  fba35200          UMULL    r5,r2,r3,r0
000a2c  08d2              LSRS     r2,r2,#3
000a2e  4255              RSBS     r5,r2,#0
000a30  eb050585          ADD      r5,r5,r5,LSL #2
000a34  eb000045          ADD      r0,r0,r5,LSL #1
000a38  f1c40514          RSB      r5,r4,#0x14
000a3c  3030              ADDS     r0,r0,#0x30
000a3e  5548              STRB     r0,[r1,r5]
;;;348    			t = t/10;
000a40  4610              MOV      r0,r2
                  |L1.2626|
000a42  2800              CMP      r0,#0
000a44  d1e4              BNE      |L1.2576|
000a46  f89721cc          LDRB     r2,[r7,#0x1cc]
000a4a  1c92              ADDS     r2,r2,#2
000a4c  42a2              CMP      r2,r4
000a4e  d8df              BHI      |L1.2576|
;;;349    		}
;;;350    	}while(t || len<mPrecision+2);
;;;351    	//if(len==3) data[20-(++len)] = '.';
;;;352    	//if(len==4) data[20-(++len)] = '0';
;;;353    	if(sign==1)
000a50  f1b90f00          CMP      r9,#0
000a54  d005              BEQ      |L1.2658|
;;;354    		data[20-(++len)] = '-';
000a56  202d              MOVS     r0,#0x2d
000a58  1c62              ADDS     r2,r4,#1
000a5a  b2d4              UXTB     r4,r2
000a5c  f1c40214          RSB      r2,r4,#0x14
000a60  5488              STRB     r0,[r1,r2]
                  |L1.2658|
;;;355    	SendBytes(data+20-len,len);
000a62  1b08              SUBS     r0,r1,r4
000a64  f1000114          ADD      r1,r0,#0x14
000a68  6838              LDR      r0,[r7,#0]
000a6a  4622              MOV      r2,r4
000a6c  6803              LDR      r3,[r0,#0]
000a6e  4638              MOV      r0,r7
000a70  4798              BLX      r3
;;;356    	return *this;
;;;357    }
000a72  b006              ADD      sp,sp,#0x18
000a74  4638              MOV      r0,r7                 ;356
000a76  e8bd87f0          POP      {r4-r10,pc}
;;;358    USART& USART::operator<<(const char* pStr)
                          ENDP

                  _ZN5USARTlsEPKc PROC ; USART::operator <<(const char*)
000a7a  b510              PUSH     {r4,lr}
;;;359    {
000a7c  4604              MOV      r4,r0
;;;360    	unsigned int length=0;
000a7e  2300              MOVS     r3,#0
;;;361    	for(int i=0;pStr[i]!='\0';++i)
000a80  7808              LDRB     r0,[r1,#0]
000a82  461a              MOV      r2,r3
000a84  b120              CBZ      r0,|L1.2704|
                  |L1.2694|
000a86  1c52              ADDS     r2,r2,#1              ;359
;;;362    	{
;;;363    		++length;
000a88  1c5b              ADDS     r3,r3,#1
000a8a  5c88              LDRB     r0,[r1,r2]
000a8c  2800              CMP      r0,#0
000a8e  d1fa              BNE      |L1.2694|
                  |L1.2704|
;;;364    	}
;;;365    	SendBytes((u8*)pStr,length);
000a90  6820              LDR      r0,[r4,#0]
000a92  b29a              UXTH     r2,r3
000a94  6803              LDR      r3,[r0,#0]
000a96  4620              MOV      r0,r4
000a98  4798              BLX      r3
;;;366    	return *this;
000a9a  4620              MOV      r0,r4
;;;367    }
000a9c  bd10              POP      {r4,pc}
;;;368    
                          ENDP

                  _ZN5USART6DMAIRQEv PROC ; USART::DMAIRQ()
;;;442    
;;;443    void USART::DMAIRQ()
000a9e  b510              PUSH     {r4,lr}
;;;444    {
000aa0  4604              MOV      r4,r0
;;;445    	if(DMA_GetFlagStatus(mDMATCFlag)==SET) //DMA Tx Complete
000aa2  f8d001d8          LDR      r0,[r0,#0x1d8]
000aa6  f7fffffe          BL       DMA_GetFlagStatus
000aaa  2801              CMP      r0,#1
;;;446    	{
;;;447    		DMA_ClearITPendingBit(mDMAGLFlag);   //Clear DMA global interrupt flag
;;;448    		DMA_ClearFlag(mDMATCFlag);           //Clear DMA Tx complete flag
;;;449    		DMA_Cmd(mDMATxCh,DISABLE);           //close dma
;;;450    		
;;;451    		if(mTxBuf.Size()>0)
;;;452    		{
;;;453    			if(mTxBuf.Size() <= USART_DMA_TX_BUFFER_SIZE)  //the rest data bytes less than DMA buffer size
;;;454    			{
;;;455    				mDMATxCh->CNDTR = mTxBuf.Size();             //send all rest data to DMA buffer 
;;;456    				mTxBuf.Gets(mDMATxBuf,mTxBuf.Size());		
;;;457    			}
;;;458    			else                                           //the rest data bytes more than DMA buffer size
;;;459    			{
;;;460    				mDMATxCh->CNDTR = USART_DMA_TX_BUFFER_SIZE;  //send max DMA buffer size data to DMA buffer
;;;461    				mTxBuf.Gets(mDMATxBuf,USART_DMA_TX_BUFFER_SIZE);
;;;462    			}
;;;463    			DMA_Cmd(mDMATxCh,ENABLE); 	                   //enable DMA
;;;464    		}
;;;465    		else
;;;466    			isBusySend = false;               //将忙标志
;;;467    	}
;;;468    }
000aac  bf18              IT       NE
000aae  bd10              POPNE    {r4,pc}
000ab0  f8d401dc          LDR      r0,[r4,#0x1dc]        ;447
000ab4  f7fffffe          BL       DMA_ClearITPendingBit
000ab8  f8d401d8          LDR      r0,[r4,#0x1d8]        ;448
000abc  f7fffffe          BL       DMA_ClearFlag
000ac0  2100              MOVS     r1,#0                 ;449
000ac2  f8d401d4          LDR      r0,[r4,#0x1d4]        ;449
000ac6  f7fffffe          BL       DMA_Cmd
000aca  f8b400f6          LDRH     r0,[r4,#0xf6]         ;451
000ace  2800              CMP      r0,#0                 ;451
000ad0  bf04              ITT      EQ                    ;466
000ad2  7120              STRBEQ   r0,[r4,#4]            ;466
000ad4  bd10              POPEQ    {r4,pc}
000ad6  28c8              CMP      r0,#0xc8              ;453
000ad8  d80b              BHI      |L1.2802|
000ada  f8d411d4          LDR      r1,[r4,#0x1d4]        ;455
000ade  6048              STR      r0,[r1,#4]            ;455
000ae0  f8b420f6          LDRH     r2,[r4,#0xf6]         ;455
000ae4  f50471f0          ADD      r1,r4,#0x1e0          ;456
000ae8  f104002c          ADD      r0,r4,#0x2c           ;456
000aec  f7fffffe          BL       _ZN10FIFOBufferIhLt200EE4GetsEPht ; FIFOBuffer<unsigned char, (unsigned short)200>::Gets(unsigned char*, unsigned short)
000af0  e00a              B        |L1.2824|
                  |L1.2802|
000af2  f8d411d4          LDR      r1,[r4,#0x1d4]        ;460
000af6  20c8              MOVS     r0,#0xc8              ;460
000af8  6048              STR      r0,[r1,#4]            ;460
000afa  4602              MOV      r2,r0                 ;461
000afc  f50471f0          ADD      r1,r4,#0x1e0          ;461
000b00  f104002c          ADD      r0,r4,#0x2c           ;461
000b04  f7fffffe          BL       _ZN10FIFOBufferIhLt200EE4GetsEPht ; FIFOBuffer<unsigned char, (unsigned short)200>::Gets(unsigned char*, unsigned short)
                  |L1.2824|
000b08  f8d401d4          LDR      r0,[r4,#0x1d4]        ;463
000b0c  e8bd4010          POP      {r4,lr}               ;463
000b10  2101              MOVS     r1,#1                 ;463
000b12  f7ffbffe          B.W      DMA_Cmd
;;;469    
                          ENDP

000b16  0000              DCW      0x0000
                  |L1.2840|
                          DCD      0x40013804
                  |L1.2844|
                          DCD      0x66666667
                  |L1.2848|
                          DCD      0x40240000
                  |L1.2852|
                          DCD      0xcccccccd

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  DATA_LENGTH
000000  03002400          DCB      0x03,0x00,0x24,0x00
000004  29001000          DCB      0x29,0x00,0x10,0x00
000008  29010132          DCB      0x29,0x01,0x01,0x32
00000c  0003000c          DCB      0x00,0x03,0x00,0x0c
000010  000c000c          DCB      0x00,0x0c,0x00,0x0c
000014  000c000c          DCB      0x00,0x0c,0x00,0x0c
000018  000c              DCB      0x00,0x0c

                          AREA ||.constdata__ZTV5USART||, COMGROUP=_ZTV5USART, DATA, READONLY, ALIGN=2

                  _ZTV5USART ; vtable for USART
                          DCD      0x00000000
                          DCD      _ZTI5USART ; typeinfo for USART
                          DCD      _ZN5USART9SendBytesEPht ; USART::SendBytes(unsigned char*, unsigned short)
                          DCD      _ZN5USART8SendByteEh ; USART::SendByte(unsigned char)
                          DCD      _ZN5USART8GetBytesEPht ; USART::GetBytes(unsigned char*, unsigned short)
                          DCD      _ZN5USART7GetByteERh ; USART::GetByte(unsigned char&)
                          DCD      _ZN5USART6TxSizeEv ; USART::TxSize()
                          DCD      _ZN5USART6RxSizeEv ; USART::RxSize()
                          DCD      _ZN5USART14TxOverflowSizeEv ; USART::TxOverflowSize()
                          DCD      _ZN5USART14RxOverflowSizeEv ; USART::RxOverflowSize()
                          DCD      _ZN5USART10ClearRxBufEv ; USART::ClearRxBuf()
                          DCD      _ZN5USART10ClearTxBufEv ; USART::ClearTxBuf()

                          AREA ||t._ZN10FIFOBufferIhLt200EE4GetsEPht||, COMGROUP=_ZN10FIFOBufferIhLt200EE4GetsEPht, CODE, READONLY, ALIGN=2

                  _ZN10FIFOBufferIhLt200EE4GetsEPht PROC ; FIFOBuffer<unsigned char, (unsigned short)200>::Gets(unsigned char*, unsigned short)
;;;93     template<typename T, u16 MAX_SIZE>
;;;94     bool FIFOBuffer<T,MAX_SIZE>::Gets(T *pData, u16 num) 
000000  b430              PUSH     {r4,r5}
;;;95     {
;;;96     	if(_size<num) return false;  //not enough data to get
000002  f8b030ca          LDRH     r3,[r0,#0xca]
000006  429a              CMP      r2,r3
000008  bf82              ITTT     HI
00000a  2000              MOVHI    r0,#0
;;;97     	
;;;98     	for(u16 i=0; i<num; i++)
;;;99     	{
;;;100    		pData[i] = _buf[_out_idx++]; //output data
;;;101    	
;;;102    		if(_out_idx>=_max_size)  //output index validate
;;;103    			_out_idx = 0;
;;;104    	}
;;;105    	_size -= num;//update buffer size
;;;106    	return true;
;;;107    }
00000c  bc30              POPHI    {r4,r5}
00000e  4770              BXHI     lr
000010  2300              MOVS     r3,#0                 ;98
000012  2a00              CMP      r2,#0                 ;98
000014  bf88              IT       HI                    ;98
000016  2400              MOVHI    r4,#0                 ;98
000018  d918              BLS      |L19.76|
00001a  bf00              NOP                            ;100
                  |L19.28|
00001c  f8b0c0cc          LDRH     r12,[r0,#0xcc]        ;100
000020  f810c00c          LDRB     r12,[r0,r12]          ;100
000024  f801c003          STRB     r12,[r1,r3]           ;100
000028  f8b0c0cc          LDRH     r12,[r0,#0xcc]        ;100
00002c  f10c0c01          ADD      r12,r12,#1            ;100
000030  fa1ffc8c          UXTH     r12,r12               ;100
000034  f8a0c0cc          STRH     r12,[r0,#0xcc]        ;100
000038  f8b050c8          LDRH     r5,[r0,#0xc8]         ;102
00003c  45ac              CMP      r12,r5                ;102
00003e  bf28              IT       CS                    ;103
000040  f8a040cc          STRHCS   r4,[r0,#0xcc]         ;103
000044  1c5b              ADDS     r3,r3,#1              ;103
000046  b29b              UXTH     r3,r3                 ;103
000048  4293              CMP      r3,r2                 ;103
00004a  d3e7              BCC      |L19.28|
                  |L19.76|
00004c  f8b010ca          LDRH     r1,[r0,#0xca]         ;105
000050  1a89              SUBS     r1,r1,r2              ;105
000052  f8a010ca          STRH     r1,[r0,#0xca]         ;105
000056  bc30              POP      {r4,r5}
000058  2001              MOVS     r0,#1                 ;106
00005a  4770              BX       lr
;;;108    
                          ENDP


                          AREA ||area_number.20||, COMGROUP=_ZN10FIFOBufferIhLt200EE4GetsEPht, LINKORDER=||t._ZN10FIFOBufferIhLt200EE4GetsEPht||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN10FIFOBufferIhLt200EE4GetsEPht||
                          DCD      0x00000001

                          AREA ||t._ZN10FIFOBufferIhLt200EE3GetERh||, COMGROUP=_ZN10FIFOBufferIhLt200EE3GetERh, CODE, READONLY, ALIGN=1

                  _ZN10FIFOBufferIhLt200EE3GetERh PROC ; FIFOBuffer<unsigned char, (unsigned short)200>::Get(unsigned char&)
;;;76     template<typename T, u16 MAX_SIZE>
;;;77     bool FIFOBuffer<T,MAX_SIZE>::Get(T &data) 
000000  f8b020ca          LDRH     r2,[r0,#0xca]
;;;78     {
;;;79     	if(_size<=0)    //no data to get
000004  2a00              CMP      r2,#0
;;;80     		return false;
000006  bf04              ITT      EQ
000008  2000              MOVEQ    r0,#0
;;;81     	
;;;82     	data = _buf[_out_idx++]; //output data
;;;83     	
;;;84     	if(_out_idx>=_max_size)  //output index validate
;;;85     		_out_idx = 0;
;;;86     	
;;;87     	_size--;//update buffer size
;;;88     	return true;
;;;89     }
00000a  4770              BXEQ     lr
00000c  f8b020cc          LDRH     r2,[r0,#0xcc]         ;82
000010  1c53              ADDS     r3,r2,#1              ;82
000012  f8a030cc          STRH     r3,[r0,#0xcc]         ;82
000016  5c82              LDRB     r2,[r0,r2]            ;82
000018  700a              STRB     r2,[r1,#0]            ;82
00001a  f8b010cc          LDRH     r1,[r0,#0xcc]         ;84
00001e  f8b020c8          LDRH     r2,[r0,#0xc8]         ;84
000022  4291              CMP      r1,r2                 ;84
000024  bf24              ITT      CS                    ;85
000026  2100              MOVCS    r1,#0                 ;85
000028  f8a010cc          STRHCS   r1,[r0,#0xcc]         ;85
00002c  f8b010ca          LDRH     r1,[r0,#0xca]         ;87
000030  1e49              SUBS     r1,r1,#1              ;87
000032  f8a010ca          STRH     r1,[r0,#0xca]         ;87
000036  2001              MOVS     r0,#1                 ;88
000038  4770              BX       lr
;;;90     
                          ENDP


                          AREA ||area_number.27||, COMGROUP=_ZN10FIFOBufferIhLt200EE3GetERh, LINKORDER=||t._ZN10FIFOBufferIhLt200EE3GetERh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN10FIFOBufferIhLt200EE3GetERh||
                          DCD      0x00000001

                          AREA ||.constdata__ZTI5USART||, COMGROUP=_ZTI5USART, DATA, READONLY, ALIGN=2

                  _ZTI5USART ; typeinfo for USART
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS5USART ; typeinfo name for USART

                          AREA ||.constdata__ZTS5USART||, COMGROUP=_ZTS5USART, DATA, READONLY, ALIGN=0

                  _ZTS5USART ; typeinfo name for USART
000000  35555341          DCB      0x35,0x55,0x53,0x41
000004  525400            DCB      0x52,0x54,0x00
