; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o..\obj\gpio.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\gpio.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime -I..\CORE -I..\STM32F10x_FWLIB\inc -I..\USER -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\C++LIB\OnChip\GPIO -I..\C++LIB\ToolBox\Buffer -I..\C++LIB\System -I..\C++LIB\OnChip\IIC -I..\C++LIB\OffChip -I..\C++LIB\System\TaskManager -I..\C++LIB\System\Interrupt -I..\C++LIB\OnChip\SerialPort -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -W --omf_browse=..\obj\gpio.crf ..\C++LIB\OnChip\GPIO\GPIO.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN4GPIO17RCC_ConfigurationEv PROC ; GPIO::RCC_Configuration()
;;;22     //The function to configure the RCC of GPIO
;;;23     void GPIO::RCC_Configuration()
000000  6840              LDR      r0,[r0,#4]
;;;24     {
;;;25     	//	SystemInit();	//系统设置初始化
;;;26     	if (mPort == GPIOA)
000002  f1a04180          SUB      r1,r0,#0x40000000
000006  f5b13184          SUBS     r1,r1,#0x10800
00000a  d016              BEQ      |L1.58|
;;;27     	{
;;;28     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
;;;29     	}
;;;30     	else if (mPort == GPIOB)
00000c  f5b16180          SUBS     r1,r1,#0x400
000010  d017              BEQ      |L1.66|
;;;31     	{
;;;32     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
;;;33     	}
;;;34     	else if (mPort == GPIOC)
000012  f5b16180          SUBS     r1,r1,#0x400
000016  d018              BEQ      |L1.74|
;;;35     	{
;;;36     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
;;;37     	}
;;;38     	else if (mPort == GPIOD)
000018  f5b16180          SUBS     r1,r1,#0x400
00001c  d019              BEQ      |L1.82|
;;;39     	{
;;;40     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
;;;41     	}
;;;42     	else if (mPort == GPIOE)
00001e  f5b16180          SUBS     r1,r1,#0x400
000022  d01a              BEQ      |L1.90|
;;;43     	{
;;;44     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);
;;;45     	}
;;;46     	else if (mPort == GPIOF)
000024  f5b16180          SUBS     r1,r1,#0x400
000028  d01b              BEQ      |L1.98|
;;;47     	{
;;;48     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);
;;;49     	}
;;;50     	else if (mPort == GPIOG)
00002a  f5b16180          SUBS     r1,r1,#0x400
;;;51     	{
;;;52     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG, ENABLE);
;;;53     	}
;;;54     }
00002e  bf18              IT       NE
000030  4770              BXNE     lr
000032  2101              MOVS     r1,#1                 ;52
000034  0208              LSLS     r0,r1,#8              ;52
000036  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
                  |L1.58|
00003a  2101              MOVS     r1,#1                 ;28
00003c  2004              MOVS     r0,#4                 ;28
00003e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
                  |L1.66|
000042  2101              MOVS     r1,#1                 ;32
000044  2008              MOVS     r0,#8                 ;32
000046  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
                  |L1.74|
00004a  2101              MOVS     r1,#1                 ;36
00004c  2010              MOVS     r0,#0x10              ;36
00004e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
                  |L1.82|
000052  2101              MOVS     r1,#1                 ;40
000054  2020              MOVS     r0,#0x20              ;40
000056  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
                  |L1.90|
00005a  2101              MOVS     r1,#1                 ;44
00005c  2040              MOVS     r0,#0x40              ;44
00005e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
                  |L1.98|
000062  2101              MOVS     r1,#1                 ;48
000064  2080              MOVS     r0,#0x80              ;48
000066  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;55     
                          ENDP

                  _ZN4GPIOC2EP12GPIO_TypeDeft16GPIOMode_TypeDef17GPIOSpeed_TypeDef                  ; Alternate entry point ; GPIO::GPIO__sub_object(GPIO_TypeDef*, unsigned short, GPIOMode_TypeDef, GPIOSpeed_TypeDef)
                  _ZN4GPIOC1EP12GPIO_TypeDeft16GPIOMode_TypeDef17GPIOSpeed_TypeDef PROC ; GPIO::GPIO(GPIO_TypeDef*, unsigned short, GPIOMode_TypeDef, GPIOSpeed_TypeDef)
;;;11     //The Constructor of the Class
;;;12     GPIO::GPIO(GPIO_TypeDef *port, uint16_t pin, GPIOMode_TypeDef mode, GPIOSpeed_TypeDef speed) :mMode(mode), mSpeed(speed), mPort(port), mSelectPin(pin)
;;;13     {
;;;14     	GPIO_InitTypeDef GPIO_InitStructure;
;;;15     	RCC_Configuration();
;;;16     	GPIO_InitStructure.GPIO_Pin = mPin[pin];
;;;17     	GPIO_InitStructure.GPIO_Speed = speed;
;;;18     	GPIO_InitStructure.GPIO_Mode = mode;
;;;19     	GPIO_Init(mPort, &GPIO_InitStructure);
;;;20     }
;;;21     
00006a  b5f8              PUSH     {r3-r7,lr}
00006c  4604              MOV      r4,r0
00006e  9f06              LDR      r7,[sp,#0x18]
000070  7003              STRB     r3,[r0,#0]
000072  7047              STRB     r7,[r0,#1]
000074  6041              STR      r1,[r0,#4]
000076  8102              STRH     r2,[r0,#8]
000078  f1a14080          SUB      r0,r1,#0x40000000
00007c  461d              MOV      r5,r3
00007e  4616              MOV      r6,r2
000080  f5b03084          SUBS     r0,r0,#0x10800
000084  d03c              BEQ      |L1.256|
000086  f5b06080          SUBS     r0,r0,#0x400
00008a  bf04              ITT      EQ
00008c  2101              MOVEQ    r1,#1
00008e  2008              MOVEQ    r0,#8
000090  d03b              BEQ      |L1.266|
000092  f1a14080          SUB      r0,r1,#0x40000000
000096  f5b03088          SUBS     r0,r0,#0x11000
00009a  bf04              ITT      EQ
00009c  2101              MOVEQ    r1,#1
00009e  2010              MOVEQ    r0,#0x10
0000a0  d033              BEQ      |L1.266|
0000a2  f1a14080          SUB      r0,r1,#0x40000000
0000a6  f5b0308a          SUBS     r0,r0,#0x11400
0000aa  bf04              ITT      EQ
0000ac  2101              MOVEQ    r1,#1
0000ae  2020              MOVEQ    r0,#0x20
0000b0  d02b              BEQ      |L1.266|
0000b2  f1a14080          SUB      r0,r1,#0x40000000
0000b6  f5b0308c          SUBS     r0,r0,#0x11800
0000ba  bf04              ITT      EQ
0000bc  2101              MOVEQ    r1,#1
0000be  2040              MOVEQ    r0,#0x40
0000c0  d023              BEQ      |L1.266|
0000c2  f1a14080          SUB      r0,r1,#0x40000000
0000c6  f5b0308e          SUBS     r0,r0,#0x11c00
0000ca  bf04              ITT      EQ
0000cc  2101              MOVEQ    r1,#1
0000ce  2080              MOVEQ    r0,#0x80
0000d0  d01b              BEQ      |L1.266|
0000d2  f1a14080          SUB      r0,r1,#0x40000000
0000d6  f5b03090          SUBS     r0,r0,#0x12000
0000da  bf04              ITT      EQ
0000dc  2101              MOVEQ    r1,#1
0000de  0208              LSLEQ    r0,r1,#8
0000e0  d013              BEQ      |L1.266|
                  |L1.226|
0000e2  483c              LDR      r0,|L1.468|
0000e4  4669              MOV      r1,sp
0000e6  f8300016          LDRH     r0,[r0,r6,LSL #1]
0000ea  f8ad0000          STRH     r0,[sp,#0]
0000ee  f88d7002          STRB     r7,[sp,#2]
0000f2  f88d5003          STRB     r5,[sp,#3]
0000f6  6860              LDR      r0,[r4,#4]
0000f8  f7fffffe          BL       GPIO_Init
0000fc  4620              MOV      r0,r4
0000fe  bdf8              POP      {r3-r7,pc}
                  |L1.256|
000100  2101              MOVS     r1,#1
000102  2004              MOVS     r0,#4
000104  f7fffffe          BL       RCC_APB2PeriphClockCmd
000108  e7eb              B        |L1.226|
                  |L1.266|
00010a  f7fffffe          BL       RCC_APB2PeriphClockCmd
00010e  e7e8              B        |L1.226|
                          ENDP

                  _ZN4GPIO8SetLevelEh PROC ; GPIO::SetLevel(unsigned char)
;;;59     */
;;;60     void GPIO::SetLevel(u8 level)
000110  4b30              LDR      r3,|L1.468|
;;;61     {
;;;62     	if (level > 0)
;;;63     		GPIO_SetBits(mPort, mPin[mSelectPin]);
000112  8902              LDRH     r2,[r0,#8]
000114  6840              LDR      r0,[r0,#4]
000116  2900              CMP      r1,#0                 ;62
000118  f8332012          LDRH     r2,[r3,r2,LSL #1]
00011c  4611              MOV      r1,r2                 ;62
00011e  d001              BEQ      |L1.292|
000120  f7ffbffe          B.W      GPIO_SetBits
                  |L1.292|
;;;64     	else
;;;65     		GPIO_ResetBits(mPort, mPin[mSelectPin]);
000124  f7ffbffe          B.W      GPIO_ResetBits
;;;66     }
;;;67     
                          ENDP

                  _ZN4GPIO8GetLevelEv PROC ; GPIO::GetLevel()
;;;71     */
;;;72     bool GPIO::GetLevel()
000128  b510              PUSH     {r4,lr}
;;;73     {
;;;74     	if (!GPIO_ReadInputDataBit(mPort, mPin[mSelectPin]))
00012a  8901              LDRH     r1,[r0,#8]
00012c  4a29              LDR      r2,|L1.468|
00012e  6840              LDR      r0,[r0,#4]
000130  f8321011          LDRH     r1,[r2,r1,LSL #1]
000134  f7fffffe          BL       GPIO_ReadInputDataBit
000138  2800              CMP      r0,#0
;;;75     		return false;
;;;76     	else
;;;77     		return true;
00013a  bf18              IT       NE
00013c  2001              MOVNE    r0,#1
;;;78     }
00013e  bd10              POP      {r4,pc}
;;;79     
                          ENDP

                  _ZN4GPIO6ToggleEv PROC ; GPIO::Toggle()
;;;80     /***	Invert the level of the pin	***/
;;;81     void GPIO::Toggle()
000140  b570              PUSH     {r4-r6,lr}
;;;82     {
000142  4604              MOV      r4,r0
;;;83     	if (GPIO_ReadInputDataBit(mPort, mPin[mSelectPin]))
000144  8900              LDRH     r0,[r0,#8]
000146  4d23              LDR      r5,|L1.468|
000148  f8351010          LDRH     r1,[r5,r0,LSL #1]
00014c  6860              LDR      r0,[r4,#4]
00014e  f7fffffe          BL       GPIO_ReadInputDataBit
000152  2800              CMP      r0,#0
;;;84     		GPIO_ResetBits(mPort, mPin[mSelectPin]);
;;;85     	else
;;;86     		GPIO_SetBits(mPort, mPin[mSelectPin]);
000154  8920              LDRH     r0,[r4,#8]
000156  f8351010          LDRH     r1,[r5,r0,LSL #1]
00015a  6860              LDR      r0,[r4,#4]            ;83
00015c  d003              BEQ      |L1.358|
00015e  e8bd4070          POP      {r4-r6,lr}            ;84
000162  f7ffbffe          B.W      GPIO_ResetBits
                  |L1.358|
000166  e8bd4070          POP      {r4-r6,lr}
00016a  f7ffbffe          B.W      GPIO_SetBits
;;;87     }
;;;88     
                          ENDP

                  _ZN4GPIO10ChangeModeE16GPIOMode_TypeDef PROC ; GPIO::ChangeMode(GPIOMode_TypeDef)
;;;89     void GPIO::ChangeMode(GPIOMode_TypeDef mode)
00016e  b508              PUSH     {r3,lr}
;;;90     {
;;;91     	GPIO_InitTypeDef GPIO_InitStructure;
;;;92     
;;;93     	GPIO_InitStructure.GPIO_Pin = mPin[mSelectPin];
000170  8902              LDRH     r2,[r0,#8]
000172  4b18              LDR      r3,|L1.468|
000174  f8332012          LDRH     r2,[r3,r2,LSL #1]
000178  f8ad2000          STRH     r2,[sp,#0]
;;;94     	GPIO_InitStructure.GPIO_Speed = mSpeed;
00017c  7842              LDRB     r2,[r0,#1]
00017e  f88d2002          STRB     r2,[sp,#2]
;;;95     	GPIO_InitStructure.GPIO_Mode = mode;
000182  f88d1003          STRB     r1,[sp,#3]
;;;96     	GPIO_Init(mPort, &GPIO_InitStructure);
000186  6840              LDR      r0,[r0,#4]
000188  4669              MOV      r1,sp
00018a  f7fffffe          BL       GPIO_Init
;;;97     }
00018e  bd08              POP      {r3,pc}
;;;98     
                          ENDP

                  _ZN4GPIOlsEh PROC ; GPIO::operator <<(unsigned char)
;;;99     GPIO& GPIO::operator<<(unsigned char value)
000190  b510              PUSH     {r4,lr}
;;;100    {
;;;101    	if(value&0x01)
000192  f0110f01          TST      r1,#1
000196  4a0f              LDR      r2,|L1.468|
000198  8901              LDRH     r1,[r0,#8]
00019a  4604              MOV      r4,r0                 ;100
00019c  6840              LDR      r0,[r0,#4]            ;100
00019e  f8321011          LDRH     r1,[r2,r1,LSL #1]     ;100
0001a2  d002              BEQ      |L1.426|
0001a4  f7fffffe          BL       GPIO_SetBits
0001a8  e001              B        |L1.430|
                  |L1.426|
0001aa  f7fffffe          BL       GPIO_ResetBits
                  |L1.430|
;;;102    		this->SetLevel(1);
;;;103    	else
;;;104    		this->SetLevel(0);
;;;105    	return *this;
0001ae  4620              MOV      r0,r4
;;;106    }
0001b0  bd10              POP      {r4,pc}
;;;107    GPIO& GPIO::operator>>(unsigned char* value)
                          ENDP

                  _ZN4GPIOrsEPh PROC ; GPIO::operator >>(unsigned char*)
0001b2  b570              PUSH     {r4-r6,lr}
;;;108    {
0001b4  460c              MOV      r4,r1
0001b6  4605              MOV      r5,r0
0001b8  8900              LDRH     r0,[r0,#8]
0001ba  4906              LDR      r1,|L1.468|
0001bc  f8311010          LDRH     r1,[r1,r0,LSL #1]
0001c0  6868              LDR      r0,[r5,#4]
0001c2  f7fffffe          BL       GPIO_ReadInputDataBit
0001c6  2800              CMP      r0,#0
0001c8  bf18              IT       NE
0001ca  2001              MOVNE    r0,#1
;;;109    	if(this->GetLevel())
;;;110    		*value=0x01;
0001cc  7020              STRB     r0,[r4,#0]
;;;111    	else
;;;112    		*value=0x00;
;;;113    	return *this;
0001ce  4628              MOV      r0,r5
;;;114    }
0001d0  bd70              POP      {r4-r6,pc}
                          ENDP

0001d2  0000              DCW      0x0000
                  |L1.468|
                          DCD      ||.constdata||

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  _ZN4GPIO4mPinE ; GPIO::mPin
000000  00010002          DCW      0x0001,0x0002
000004  00040008          DCW      0x0004,0x0008
000008  00100020          DCW      0x0010,0x0020
00000c  00400080          DCW      0x0040,0x0080
000010  01000200          DCW      0x0100,0x0200
000014  04000800          DCW      0x0400,0x0800
000018  10002000          DCW      0x1000,0x2000
00001c  40008000          DCW      0x4000,0x8000
