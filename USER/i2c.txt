; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o..\obj\i2c.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\i2c.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime -I..\CORE -I..\STM32F10x_FWLIB\inc -I..\USER -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\C++LIB\OnChip\GPIO -I..\C++LIB\ToolBox\Buffer -I..\C++LIB\System -I..\C++LIB\OnChip\IIC -I..\C++LIB\OffChip -I..\C++LIB\System\TaskManager -I..\C++LIB\System\Interrupt -I..\C++LIB\OnChip\SerialPort -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -W --omf_browse=..\obj\i2c.crf ..\C++LIB\OnChip\IIC\I2C.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _ZN3I2C8InitGPIOE16GPIOMode_TypeDef PROC ; I2C::InitGPIO(GPIOMode_TypeDef)
;;;96     }
;;;97     void I2C::InitGPIO(GPIOMode_TypeDef gpioMode)
000000  b538              PUSH     {r3-r5,lr}
;;;98     {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;99     		
;;;100    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);     //GPIO Clock
000006  2101              MOVS     r1,#1
000008  2008              MOVS     r0,#8
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;101    	if(mI2C==I2C1 && mRemap && gpioMode==GPIO_Mode_AF_OD)
00000e  6820              LDR      r0,[r4,#0]
000010  f1a04180          SUB      r1,r0,#0x40000000
000014  f5b141a8          SUBS     r1,r1,#0x5400
000018  d10b              BNE      |L1.50|
00001a  7a20              LDRB     r0,[r4,#8]
00001c  b148              CBZ      r0,|L1.50|
00001e  2d1c              CMP      r5,#0x1c
000020  d107              BNE      |L1.50|
;;;102    	{
;;;103    		RCC_APB2PeriphClockCmd((RCC_APB2Periph_AFIO),ENABLE);  //Enable GPIO Alternative Functions
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;104    		GPIO_PinRemapConfig(GPIO_Remap_I2C1, ENABLE);          //Enable I2C1 pin Remap
00002a  2101              MOVS     r1,#1
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.50|
;;;105    	}
;;;106    	GPIO_InitTypeDef GPIO_InitStructure;
;;;107    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;         //Set GPIO frequency to 50MHz
000032  2003              MOVS     r0,#3
000034  f88d0002          STRB     r0,[sp,#2]
;;;108    	GPIO_InitStructure.GPIO_Mode = gpioMode;                  //I2C: GPIO_Mode_AF_OD; Analog: GPIO_Mode_IN_FLOATING; Detect: GPIO_Mode_Out_PP
000038  f88d5003          STRB     r5,[sp,#3]
;;;109    	GPIO_InitStructure.GPIO_Pin = mSCLPin | mSDAPin;          //Initialize I2Cx SCL Pin
00003c  89a0              LDRH     r0,[r4,#0xc]
00003e  8961              LDRH     r1,[r4,#0xa]
000040  4308              ORRS     r0,r0,r1
000042  f8ad0000          STRH     r0,[sp,#0]
;;;110    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000046  4669              MOV      r1,sp
000048  48f8              LDR      r0,|L1.1068|
00004a  f7fffffe          BL       GPIO_Init
;;;111    }
00004e  bd38              POP      {r3-r5,pc}
;;;112    void I2C::InitI2C()
                          ENDP

                  _ZN3I2C5ResetEv PROC ; I2C::Reset()
;;;65     }
;;;66     bool I2C::Reset()
000050  e92d4ff0          PUSH     {r4-r11,lr}
;;;67     {
000054  4604              MOV      r4,r0
;;;68     	mI2C->CR1 |= I2C_CR1_SWRST;   //Start reset I2C 
000056  6800              LDR      r0,[r0,#0]
000058  b083              SUB      sp,sp,#0xc            ;67
00005a  8801              LDRH     r1,[r0,#0]
00005c  f4414100          ORR      r1,r1,#0x8000
000060  8001              STRH     r1,[r0,#0]
;;;69     	mI2C->CR1 &= ~I2C_CR1_SWRST;  //Stop reset I2C
000062  6820              LDR      r0,[r4,#0]
000064  8801              LDRH     r1,[r0,#0]
000066  f4214100          BIC      r1,r1,#0x8000
00006a  8001              STRH     r1,[r0,#0]
;;;70     	mI2C->CR1 &= ~I2C_CR1_PE; 		//disable I2C		
00006c  6820              LDR      r0,[r4,#0]
00006e  8801              LDRH     r1,[r0,#0]
000070  f0210101          BIC      r1,r1,#1
000074  8001              STRH     r1,[r0,#0]
;;;71     	RCC->APB1RSTR |= mI2CRcc;     //start reset i2c clock
000076  f8dfb3b8          LDR      r11,|L1.1072|
00007a  f8db0010          LDR      r0,[r11,#0x10]
00007e  6921              LDR      r1,[r4,#0x10]
000080  4308              ORRS     r0,r0,r1
000082  f8cb0010          STR      r0,[r11,#0x10]
;;;72     	RCC->APB1RSTR &= ~mI2CRcc;    //end reset i2c clock
000086  f8db0010          LDR      r0,[r11,#0x10]
00008a  6921              LDR      r1,[r4,#0x10]
00008c  4388              BICS     r0,r0,r1
00008e  f8cb0010          STR      r0,[r11,#0x10]
;;;73     	RCC->APB1ENR |= mI2CRcc;      //enable i2c clock
000092  f8db001c          LDR      r0,[r11,#0x1c]
000096  6921              LDR      r1,[r4,#0x10]
000098  4308              ORRS     r0,r0,r1
00009a  f8cb001c          STR      r0,[r11,#0x1c]
;;;74     	
;;;75     	//Check and Fix I2C Bus Busy problem
;;;76     	u8 timeoutCnt = 0;
00009e  2500              MOVS     r5,#0
0000a0  f8dfa388          LDR      r10,|L1.1068|
0000a4  462f              MOV      r7,r5
0000a6  f04f0903          MOV      r9,#3
;;;77     	while(I2C_GetFlagStatus(mI2C, I2C_FLAG_BUSY) && timeoutCnt<20)
0000aa  bf00              NOP      
                  |L1.172|
0000ac  f44f3100          MOV      r1,#0x20000
0000b0  6820              LDR      r0,[r4,#0]
0000b2  f7fffffe          BL       I2C_GetFlagStatus
0000b6  2800              CMP      r0,#0
0000b8  d078              BEQ      |L1.428|
0000ba  2d14              CMP      r5,#0x14
0000bc  d27c              BCS      |L1.440|
;;;78     	{
;;;79     		RCC_APB1PeriphClockCmd(mI2CRcc,DISABLE);  //Close I2C Device
0000be  2100              MOVS     r1,#0
0000c0  6920              LDR      r0,[r4,#0x10]
0000c2  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;80     		InitGPIO(GPIO_Mode_Out_PP);               //Initialize GPIO for Software I2C
0000c6  2610              MOVS     r6,#0x10
0000c8  2101              MOVS     r1,#1
0000ca  2008              MOVS     r0,#8
0000cc  f7fffffe          BL       RCC_APB2PeriphClockCmd
0000d0  f88d9006          STRB     r9,[sp,#6]
0000d4  f88d6007          STRB     r6,[sp,#7]
0000d8  89a0              LDRH     r0,[r4,#0xc]
0000da  8961              LDRH     r1,[r4,#0xa]
0000dc  4656              MOV      r6,r10
0000de  4308              ORRS     r0,r0,r1
0000e0  f8ad0004          STRH     r0,[sp,#4]
0000e4  a901              ADD      r1,sp,#4
0000e6  4650              MOV      r0,r10
0000e8  f7fffffe          BL       GPIO_Init
;;;81     		GPIO_ResetBits(GPIOB, mSCLPin);           //
0000ec  89a1              LDRH     r1,[r4,#0xc]
0000ee  4630              MOV      r0,r6
0000f0  f7fffffe          BL       GPIO_ResetBits
;;;82     		GPIO_ResetBits(GPIOB, mSDAPin);           //To Generate Stop Signal by Pin simulation
0000f4  8961              LDRH     r1,[r4,#0xa]
0000f6  4630              MOV      r0,r6
0000f8  f7fffffe          BL       GPIO_ResetBits
;;;83     		for(volatile u16 i=0;i<100;i++);          //         _______
0000fc  f8ad7000          STRH     r7,[sp,#0]
000100  e005              B        |L1.270|
000102  bf00              NOP      
                  |L1.260|
000104  f8bd0000          LDRH     r0,[sp,#0]
000108  1c40              ADDS     r0,r0,#1
00010a  f8ad0000          STRH     r0,[sp,#0]
                  |L1.270|
00010e  f8bd0000          LDRH     r0,[sp,#0]
000112  2864              CMP      r0,#0x64
000114  d3f6              BCC      |L1.260|
;;;84     		GPIO_SetBits(GPIOB, mSCLPin);             //SCL: ___|
000116  89a1              LDRH     r1,[r4,#0xc]
000118  4630              MOV      r0,r6
00011a  f7fffffe          BL       GPIO_SetBits
;;;85     		for(volatile u16 i=0;i<100;i++);          //             ___
00011e  f8ad7004          STRH     r7,[sp,#4]
000122  e004              B        |L1.302|
                  |L1.292|
000124  f8bd0004          LDRH     r0,[sp,#4]
000128  1c40              ADDS     r0,r0,#1
00012a  f8ad0004          STRH     r0,[sp,#4]
                  |L1.302|
00012e  f8bd0004          LDRH     r0,[sp,#4]
000132  2864              CMP      r0,#0x64
000134  d3f6              BCC      |L1.292|
;;;86     		GPIO_SetBits(GPIOB, mSDAPin);             //SDA: _______|
000136  8961              LDRH     r1,[r4,#0xa]
000138  46b2              MOV      r10,r6
00013a  4630              MOV      r0,r6
00013c  f7fffffe          BL       GPIO_SetBits
;;;87     		for(volatile u16 i=0;i<100;i++);	        //
000140  f8ad7004          STRH     r7,[sp,#4]
000144  e005              B        |L1.338|
000146  bf00              NOP      
                  |L1.328|
000148  f8bd0004          LDRH     r0,[sp,#4]
00014c  1c40              ADDS     r0,r0,#1
00014e  f8ad0004          STRH     r0,[sp,#4]
                  |L1.338|
000152  f8bd0004          LDRH     r0,[sp,#4]
000156  2864              CMP      r0,#0x64
000158  d3f6              BCC      |L1.328|
;;;88     		InitGPIO(GPIO_Mode_IN_FLOATING);          //Initialize GPIO for I2C Busy detect
00015a  2604              MOVS     r6,#4
00015c  2101              MOVS     r1,#1
00015e  2008              MOVS     r0,#8
000160  f7fffffe          BL       RCC_APB2PeriphClockCmd
000164  f88d9006          STRB     r9,[sp,#6]
000168  f88d6007          STRB     r6,[sp,#7]
00016c  89a0              LDRH     r0,[r4,#0xc]
00016e  8961              LDRH     r1,[r4,#0xa]
000170  4308              ORRS     r0,r0,r1
000172  f8ad0004          STRH     r0,[sp,#4]
000176  a901              ADD      r1,sp,#4
000178  4650              MOV      r0,r10
00017a  f7fffffe          BL       GPIO_Init
;;;89     		RCC->APB1RSTR |= mI2CRcc;                 //start reset i2c clock
00017e  f8db0010          LDR      r0,[r11,#0x10]
000182  6921              LDR      r1,[r4,#0x10]
000184  4308              ORRS     r0,r0,r1
000186  f8cb0010          STR      r0,[r11,#0x10]
;;;90     		RCC->APB1RSTR &= ~mI2CRcc;                //end reset i2c clock
00018a  f8db0010          LDR      r0,[r11,#0x10]
00018e  6921              LDR      r1,[r4,#0x10]
000190  4388              BICS     r0,r0,r1
000192  f8cb0010          STR      r0,[r11,#0x10]
;;;91     		RCC->APB1ENR |= mI2CRcc;                  //enable i2c clock
000196  f8db001c          LDR      r0,[r11,#0x1c]
00019a  6921              LDR      r1,[r4,#0x10]
00019c  4308              ORRS     r0,r0,r1
00019e  f8cb001c          STR      r0,[r11,#0x1c]
;;;92     		++timeoutCnt;
0001a2  1c68              ADDS     r0,r5,#1
0001a4  b2c5              UXTB     r5,r0
0001a6  e781              B        |L1.172|
0001a8  e000              B        |L1.428|
0001aa  e005              B        |L1.440|
                  |L1.428|
;;;93     	}
;;;94     	if(timeoutCnt>=20) return false;
0001ac  2d14              CMP      r5,#0x14
;;;95     	return true;
0001ae  bf3e              ITTT     CC
0001b0  2001              MOVCC    r0,#1
;;;96     }
0001b2  b003              ADDCC    sp,sp,#0xc
0001b4  e8bd8ff0          POPCC    {r4-r11,pc}
                  |L1.440|
0001b8  2000              MOVS     r0,#0                 ;94
0001ba  b003              ADD      sp,sp,#0xc
0001bc  e8bd8ff0          POP      {r4-r11,pc}
;;;97     void I2C::InitGPIO(GPIOMode_TypeDef gpioMode)
                          ENDP

                  _ZN3I2C7InitI2CEv PROC ; I2C::InitI2C()
;;;111    }
;;;112    void I2C::InitI2C()
0001c0  b500              PUSH     {lr}
;;;113    {
0001c2  b085              SUB      sp,sp,#0x14
;;;114    	I2C_InitTypeDef I2C_InitStructure;
;;;115    	I2C_InitStructure.I2C_ClockSpeed          = mSpeed;                        //I2C_ClockSpeed
0001c4  6841              LDR      r1,[r0,#4]
;;;116    	I2C_InitStructure.I2C_Mode                = I2C_Mode_I2C;                  //I2C_Mode
0001c6  9100              STR      r1,[sp,#0]
0001c8  2100              MOVS     r1,#0
0001ca  f8ad1004          STRH     r1,[sp,#4]
;;;117    	I2C_InitStructure.I2C_DutyCycle           = I2C_DutyCycle_2;               //I2C_DutyCycle
;;;118    	I2C_InitStructure.I2C_OwnAddress1         = 0;                             //I2C_OwnAddress1
0001ce  f8ad1008          STRH     r1,[sp,#8]
;;;119    	I2C_InitStructure.I2C_Ack                 = I2C_Ack_Enable;                //I2C_Ack
0001d2  f44f6180          MOV      r1,#0x400
0001d6  f8ad100a          STRH     r1,[sp,#0xa]
;;;120    	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;  //I2C_AcknowledgedAddress
0001da  0109              LSLS     r1,r1,#4
0001dc  f64b72ff          MOV      r2,#0xbfff            ;117
0001e0  f8ad100c          STRH     r1,[sp,#0xc]
0001e4  f8ad2006          STRH     r2,[sp,#6]            ;117
;;;121    	I2C_Init(mI2C,&I2C_InitStructure);//iic
0001e8  6800              LDR      r0,[r0,#0]
0001ea  4669              MOV      r1,sp
0001ec  f7fffffe          BL       I2C_Init
;;;122    }
0001f0  b005              ADD      sp,sp,#0x14
0001f2  bd00              POP      {pc}
;;;123    void I2C::InitNVIC()
                          ENDP

                  _ZN3I2C8InitNVICEv PROC ; I2C::InitNVIC()
0001f4  b538              PUSH     {r3-r5,lr}
;;;124    {
0001f6  4604              MOV      r4,r0
;;;125    	NVIC_InitTypeDef NVIC_InitStructure; 
;;;126    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //Enable the IRQ channel
0001f8  2001              MOVS     r0,#1
0001fa  f88d0003          STRB     r0,[sp,#3]
;;;127    	NVIC_InitStructure.NVIC_IRQChannel = mEvtIRQ;                   //I2Cx EVT Interrupt 
0001fe  7e20              LDRB     r0,[r4,#0x18]
000200  f88d0000          STRB     r0,[sp,#0]
;;;128    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = mEvtPre; //Event Preemption Priority
000204  7ea0              LDRB     r0,[r4,#0x1a]
000206  f88d0001          STRB     r0,[sp,#1]
;;;129    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = mEvtSub;        //Event Sub Priority
00020a  7ee0              LDRB     r0,[r4,#0x1b]
00020c  f88d0002          STRB     r0,[sp,#2]
;;;130    	NVIC_Init(&NVIC_InitStructure);
000210  4668              MOV      r0,sp
000212  f7fffffe          BL       NVIC_Init
;;;131      NVIC_InitStructure.NVIC_IRQChannel = mErrIRQ;                   //I2Cx ERR Interrupt 
000216  7e60              LDRB     r0,[r4,#0x19]
000218  f88d0000          STRB     r0,[sp,#0]
;;;132    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = mErrPre; //Error Preemption Priority
00021c  7f20              LDRB     r0,[r4,#0x1c]
00021e  f88d0001          STRB     r0,[sp,#1]
;;;133      NVIC_InitStructure.NVIC_IRQChannelSubPriority = mErrSub;        //Error Sub Priority 
000222  7f60              LDRB     r0,[r4,#0x1d]
000224  f88d0002          STRB     r0,[sp,#2]
;;;134      NVIC_Init(&NVIC_InitStructure);
000228  4668              MOV      r0,sp
00022a  f7fffffe          BL       NVIC_Init
;;;135    	mI2C->CR2 |= (I2C_CR2_ITEVTEN | I2C_CR2_ITERREN | I2C_IT_BUF);  //Enable Event, Error, Buffer Interrupt
00022e  6820              LDR      r0,[r4,#0]
000230  8881              LDRH     r1,[r0,#4]
000232  f44161e0          ORR      r1,r1,#0x700
000236  8081              STRH     r1,[r0,#4]
;;;136    	NVIC_PriorityGroupConfig(mPriGroup);                            //Set Priority Group
000238  6960              LDR      r0,[r4,#0x14]
00023a  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;137    }
00023e  bd38              POP      {r3-r5,pc}
;;;138    bool I2C::Initialize()
                          ENDP

                  _ZN3I2C12StartNextCmdEv PROC ; I2C::StartNextCmd()
;;;169    
;;;170    bool I2C::StartNextCmd()
000240  e92d41f0          PUSH     {r4-r8,lr}
;;;171    {
000244  4604              MOV      r4,r0
;;;172    	if(mState==I2C_STATE_FREE || mState==I2C_STATE_STOP)
000246  7f80              LDRB     r0,[r0,#0x1e]
000248  2808              CMP      r0,#8
00024a  bf18              IT       NE
00024c  2807              CMPNE    r0,#7
00024e  d002              BEQ      |L1.598|
                  |L1.592|
;;;173    	{
;;;174    		if(mCmdBank.Get(mCurCmd))
;;;175    		{
;;;176    			mState = I2C_STATE_START;
;;;177    			mDataIdx = 0;
;;;178    			if(mCurCmd.outDataLen>0) mI2CDirection = I2C_Direction_Transmitter;
;;;179    			else                     mI2CDirection = I2C_Direction_Receiver;
;;;180    			I2C_AcknowledgeConfig(mI2C,ENABLE);
;;;181    			I2C_GenerateSTART(mI2C,ENABLE);
;;;182    			return true;
;;;183    		}
;;;184    		mState = I2C_STATE_FREE;
;;;185    	}
;;;186    	return false;
000250  2000              MOVS     r0,#0
;;;187    }
000252  e8bd81f0          POP      {r4-r8,pc}
                  |L1.598|
000256  f8b4240a          LDRH     r2,[r4,#0x40a]
00025a  2100              MOVS     r1,#0
00025c  f1040020          ADD      r0,r4,#0x20           ;174
000260  f2044314          ADD      r3,r4,#0x414          ;174
000264  2a00              CMP      r2,#0                 ;174
000266  bf04              ITT      EQ                    ;184
000268  2008              MOVEQ    r0,#8                 ;184
00026a  77a0              STRBEQ   r0,[r4,#0x1e]         ;184
00026c  d0f0              BEQ      |L1.592|
00026e  f8b023ec          LDRH     r2,[r0,#0x3ec]        ;184
000272  eb020c82          ADD      r12,r2,r2,LSL #2      ;184
000276  eb000c8c          ADD      r12,r0,r12,LSL #2     ;184
00027a  1c52              ADDS     r2,r2,#1              ;184
00027c  f8a023ec          STRH     r2,[r0,#0x3ec]        ;184
000280  e89c00e4          LDM      r12,{r2,r5-r7}        ;184
000284  e88300e4          STM      r3,{r2,r5-r7}         ;184
000288  f8dc2010          LDR      r2,[r12,#0x10]        ;184
00028c  611a              STR      r2,[r3,#0x10]         ;184
00028e  f8b023ec          LDRH     r2,[r0,#0x3ec]        ;184
000292  f8b033e8          LDRH     r3,[r0,#0x3e8]        ;184
000296  429a              CMP      r2,r3                 ;184
000298  bf28              IT       CS                    ;184
00029a  f8a013ec          STRHCS   r1,[r0,#0x3ec]        ;184
00029e  f8b023ea          LDRH     r2,[r0,#0x3ea]        ;184
0002a2  1e52              SUBS     r2,r2,#1              ;184
0002a4  f8a023ea          STRH     r2,[r0,#0x3ea]        ;184
0002a8  2001              MOVS     r0,#1                 ;184
0002aa  77a0              STRB     r0,[r4,#0x1e]         ;176
0002ac  f8841410          STRB     r1,[r4,#0x410]        ;177
0002b0  f894241a          LDRB     r2,[r4,#0x41a]        ;178
0002b4  2a00              CMP      r2,#0                 ;178
0002b6  bf14              ITE      NE                    ;178
0002b8  f8841411          STRBNE   r1,[r4,#0x411]        ;178
0002bc  f8840411          STRBEQ   r0,[r4,#0x411]        ;179
0002c0  2101              MOVS     r1,#1                 ;180
0002c2  6820              LDR      r0,[r4,#0]            ;180
0002c4  f7fffffe          BL       I2C_AcknowledgeConfig
0002c8  2101              MOVS     r1,#1                 ;181
0002ca  6820              LDR      r0,[r4,#0]            ;181
0002cc  f7fffffe          BL       I2C_GenerateSTART
0002d0  2001              MOVS     r0,#1                 ;182
0002d2  e8bd81f0          POP      {r4-r8,pc}
;;;188    bool I2C::Start()
                          ENDP

                  _ZN3I2C10InitializeEv PROC ; I2C::Initialize()
;;;137    }
;;;138    bool I2C::Initialize()
0002d6  b530              PUSH     {r4,r5,lr}
;;;139    {
0002d8  4604              MOV      r4,r0
;;;140    	mErrorCnt++;
0002da  f8d00428          LDR      r0,[r0,#0x428]
0002de  b085              SUB      sp,sp,#0x14           ;139
0002e0  1c40              ADDS     r0,r0,#1
;;;141    	if(!Reset()) 
0002e2  f8c40428          STR      r0,[r4,#0x428]
0002e6  4620              MOV      r0,r4
0002e8  f7fffffe          BL       _ZN3I2C5ResetEv ; I2C::Reset()
0002ec  2800              CMP      r0,#0
0002ee  d066              BEQ      |L1.958|
;;;142    	{
;;;143    		mState = I2C_STATE_ERROR;
;;;144    		return false; //Reset RCC,I2C, release I2C Bus
;;;145    	}
;;;146    	InitGPIO(GPIO_Mode_AF_OD); //GPIO
0002f0  251c              MOVS     r5,#0x1c
0002f2  2101              MOVS     r1,#1
0002f4  2008              MOVS     r0,#8
0002f6  f7fffffe          BL       RCC_APB2PeriphClockCmd
0002fa  6820              LDR      r0,[r4,#0]
0002fc  f1a04180          SUB      r1,r0,#0x40000000
000300  f5b141a8          SUBS     r1,r1,#0x5400
000304  d109              BNE      |L1.794|
000306  7a20              LDRB     r0,[r4,#8]
000308  b138              CBZ      r0,|L1.794|
00030a  2101              MOVS     r1,#1
00030c  4608              MOV      r0,r1
00030e  f7fffffe          BL       RCC_APB2PeriphClockCmd
000312  2101              MOVS     r1,#1
000314  2002              MOVS     r0,#2
000316  f7fffffe          BL       GPIO_PinRemapConfig
                  |L1.794|
00031a  2003              MOVS     r0,#3
00031c  f88d0002          STRB     r0,[sp,#2]
000320  f88d5003          STRB     r5,[sp,#3]
000324  89a0              LDRH     r0,[r4,#0xc]
000326  8961              LDRH     r1,[r4,#0xa]
000328  4308              ORRS     r0,r0,r1
00032a  f8ad0000          STRH     r0,[sp,#0]
00032e  4669              MOV      r1,sp
000330  483e              LDR      r0,|L1.1068|
000332  f7fffffe          BL       GPIO_Init
000336  6860              LDR      r0,[r4,#4]
000338  2500              MOVS     r5,#0
00033a  9000              STR      r0,[sp,#0]
00033c  f8ad5004          STRH     r5,[sp,#4]
000340  f64b70ff          MOV      r0,#0xbfff
000344  f8ad0006          STRH     r0,[sp,#6]
000348  f8ad5008          STRH     r5,[sp,#8]
00034c  f44f6080          MOV      r0,#0x400
000350  f8ad000a          STRH     r0,[sp,#0xa]
000354  0100              LSLS     r0,r0,#4
000356  f8ad000c          STRH     r0,[sp,#0xc]
00035a  4669              MOV      r1,sp
00035c  6820              LDR      r0,[r4,#0]
00035e  f7fffffe          BL       I2C_Init
000362  2001              MOVS     r0,#1
000364  f88d0003          STRB     r0,[sp,#3]
000368  7e20              LDRB     r0,[r4,#0x18]
00036a  f88d0000          STRB     r0,[sp,#0]
00036e  7ea0              LDRB     r0,[r4,#0x1a]
000370  f88d0001          STRB     r0,[sp,#1]
000374  7ee0              LDRB     r0,[r4,#0x1b]
000376  f88d0002          STRB     r0,[sp,#2]
00037a  4668              MOV      r0,sp
00037c  f7fffffe          BL       NVIC_Init
000380  7e60              LDRB     r0,[r4,#0x19]
000382  f88d0000          STRB     r0,[sp,#0]
000386  7f20              LDRB     r0,[r4,#0x1c]
000388  f88d0001          STRB     r0,[sp,#1]
00038c  7f60              LDRB     r0,[r4,#0x1d]
00038e  f88d0002          STRB     r0,[sp,#2]
000392  4668              MOV      r0,sp
000394  f7fffffe          BL       NVIC_Init
000398  6820              LDR      r0,[r4,#0]
00039a  8881              LDRH     r1,[r0,#4]
00039c  f44161e0          ORR      r1,r1,#0x700
0003a0  8081              STRH     r1,[r0,#4]
0003a2  6960              LDR      r0,[r4,#0x14]
0003a4  f7fffffe          BL       NVIC_PriorityGroupConfig
0003a8  f8a4540a          STRH     r5,[r4,#0x40a]
0003ac  f8a4540c          STRH     r5,[r4,#0x40c]
0003b0  f8a4540e          STRH     r5,[r4,#0x40e]
;;;147    	InitI2C();                 //I2C
;;;148    	InitNVIC();                //NVIC
;;;149    	mCmdBank.Clear();          //Clear Command
;;;150    	mState = I2C_STATE_FREE;   //I2C bus ready to use
0003b4  2008              MOVS     r0,#8
0003b6  77a0              STRB     r0,[r4,#0x1e]
;;;151    	return true;
;;;152    }
0003b8  b005              ADD      sp,sp,#0x14
0003ba  2001              MOVS     r0,#1                 ;151
0003bc  bd30              POP      {r4,r5,pc}
                  |L1.958|
0003be  2009              MOVS     r0,#9                 ;143
0003c0  77a0              STRB     r0,[r4,#0x1e]         ;143
0003c2  b005              ADD      sp,sp,#0x14
0003c4  2000              MOVS     r0,#0                 ;144
0003c6  bd30              POP      {r4,r5,pc}
;;;153    bool I2C::AddCommand(u8 slaveAddr,u8 txData[], u8 txNum, u8 rxData[], u8 rxNum,Sensor *pDevice, bool isTaskTail)
                          ENDP

                  _ZN3I2CC2EP11I2C_TypeDefjhhhhhh                  ; Alternate entry point ; I2C::I2C__sub_object(I2C_TypeDef*, unsigned, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
                  _ZN3I2CC1EP11I2C_TypeDefjhhhhhh PROC ; I2C::I2C(I2C_TypeDef*, unsigned, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
;;;8      
;;;9      I2C::I2C(I2C_TypeDef* i2c, u32 speed,u8 remap,u8 priGroup,u8 preEvt,u8 subEvt,u8 preErr,u8 subErr)
;;;10     {
;;;11       //record gpio, irq, rcc, etc.....
;;;12     	mI2C    = i2c;
;;;13     	mSpeed  = speed;          //i2c bus speed    
;;;14       mRemap  = remap;          //i2c gpio remap flag	
;;;15     	mEvtPre = preEvt;         //event preemption priority
;;;16     	mEvtSub = subEvt;         //event sub priority
;;;17     	mErrPre = preErr;         //error preemption priority
;;;18     	mErrSub = subErr;         //error sub priority
;;;19     	mState  = I2C_STATE_NULL; //I2C not initialized yet
;;;20     	mErrorCnt = -1;           //no i2c error
;;;21     	if(mI2C==I2C1)                    //I2C1
;;;22     	{
;;;23     		if(mRemap)                      //Remap IO
;;;24     		{	
;;;25     			mSCLPin = GPIO_Pin_8;		      //SCL Pin			=======================================================================
;;;26     			mSDAPin = GPIO_Pin_9;		      //SDA Pin			|  I2C | remap=false |  remap=true |       IRQ   |      RCC           |
;;;27     		}                               //						|------|-------------|-------------|-------------|--------------------|
;;;28     		else                            //Not Remap		|      |SCL | PB6    | SCL | PB8   |I2C1_EV_IRQn |                    |
;;;29     		{		                            //		        | I2C1 |-------------|-------------|             |RCC_APB1Periph_I2C1 |
;;;30     			mSCLPin = GPIO_Pin_6;		      //SCL Pin			|      |SDA | PB7    | SDA | PB9   |I2C1_ER_IRQn |                    |
;;;31     			mSDAPin = GPIO_Pin_7;		      //SDA Pin 		|------|-------------|-------------|-------------|--------------------|
;;;32     		}                               //						|      |SCL | PB10   |     xxx     |I2C2_EV_IRQn |                    |
;;;33     		mEvtIRQ = I2C1_EV_IRQn;         //Event IRQ 	| I2C2 |-------------|-------------|             |RCC_APB1Periph_I2C1 |
;;;34     		mErrIRQ = I2C1_ER_IRQn;         //Error IRQ 	|      |SDA | PB11   |     xxx     |I2C2_ER_IRQn |                    |
;;;35     		mI2CRcc = RCC_APB1Periph_I2C1;  //I2C Clock  	=======================================================================
;;;36     	#ifdef USE_I2C1
;;;37     		pI2C1 = this;
;;;38     	#endif
;;;39     	}
;;;40     	else if(mI2C==I2C2)               //I2C2
;;;41     	{
;;;42     		mSCLPin = GPIO_Pin_10;	        //SCL Pin	
;;;43     	  mSDAPin = GPIO_Pin_11;          //SDA Pin 	
;;;44     		mEvtIRQ = I2C2_EV_IRQn;         //Event IRQ
;;;45     		mErrIRQ = I2C2_ER_IRQn;         //Error IRQ
;;;46     		mI2CRcc = RCC_APB1Periph_I2C2;  //I2C Clock
;;;47     	#ifdef USE_I2C2
;;;48     		pI2C2 = this;
;;;49     	#endif
;;;50     	}	
;;;51     		//set prioirty group                              // =============================================================
;;;52     	                                                    // | NVIC_PriorityGroup   | PreemptionPriority |   SubPriority  | 
;;;53     	switch(priGroup)                                    // |------------------------------------------------------------|
;;;54     	{                                                   // | NVIC_PriorityGroup_0 | 0 bit   |   0      |  4 bit | 0~15  |
;;;55     		case 0: mPriGroup = NVIC_PriorityGroup_0; break;  // |----------------------|---------|----------|----------------|
;;;56     		case 1: mPriGroup = NVIC_PriorityGroup_1; break;  // | NVIC_PriorityGroup_1 | 1 bit   |   0~1    |  3 bit | 0~7   |
;;;57     		case 2: mPriGroup = NVIC_PriorityGroup_2; break;  // |----------------------|---------|----------|--------|-------|
;;;58     		case 3: mPriGroup = NVIC_PriorityGroup_3; break;  // | NVIC_PriorityGroup_2 | 2 bit   |   0~3    |  2 bit | 0~3   |
;;;59     		case 4: mPriGroup = NVIC_PriorityGroup_4; break;  // |------------------------------------------------------------|
;;;60     	  default:mPriGroup = NVIC_PriorityGroup_3; break;  // | NVIC_PriorityGroup_3 | 3 bit   |   0~7    |  1 bit | 0~1   |
;;;61     	}                                                   // |----------------------|---------|----------|----------------|    
;;;62     	                                                    // | NVIC_PriorityGroup_4 | 4 bit   |   0~15   |  0 bit | 0     |                                                              
;;;63     	//Initialize I2C, NVIC, etc.....                    // ==============================================================
;;;64     	Initialize();
;;;65     }
;;;66     bool I2C::Reset()
0003c8  e92d47f0          PUSH     {r4-r10,lr}
0003cc  4604              MOV      r4,r0
0003ce  e9dd5908          LDRD     r5,r9,[sp,#0x20]
0003d2  e9dd760b          LDRD     r7,r6,[sp,#0x2c]
0003d6  f1000c20          ADD      r12,r0,#0x20
0003da  2032              MOVS     r0,#0x32
0003dc  f8dd8028          LDR      r8,[sp,#0x28]
0003e0  f8ac03e8          STRH     r0,[r12,#0x3e8]
0003e4  2000              MOVS     r0,#0
0003e6  f8ac03ea          STRH     r0,[r12,#0x3ea]
0003ea  f8ac03ec          STRH     r0,[r12,#0x3ec]
0003ee  f8ac03ee          STRH     r0,[r12,#0x3ee]
0003f2  e9c41200          STRD     r1,r2,[r4,#0]
0003f6  2b00              CMP      r3,#0
0003f8  bf14              ITE      NE
0003fa  2201              MOVNE    r2,#1
0003fc  2200              MOVEQ    r2,#0
0003fe  7222              STRB     r2,[r4,#8]
000400  f884901a          STRB     r9,[r4,#0x1a]
000404  f884801b          STRB     r8,[r4,#0x1b]
000408  7727              STRB     r7,[r4,#0x1c]
00040a  7766              STRB     r6,[r4,#0x1d]
00040c  77a0              STRB     r0,[r4,#0x1e]
00040e  f04f30ff          MOV      r0,#0xffffffff
000412  f8c40428          STR      r0,[r4,#0x428]
000416  f1a14380          SUB      r3,r1,#0x40000000
00041a  f44f6080          MOV      r0,#0x400
00041e  f5b343a8          SUBS     r3,r3,#0x5400
000422  d007              BEQ      |L1.1076|
000424  f5b36280          SUBS     r2,r3,#0x400
000428  d018              BEQ      |L1.1116|
00042a  e022              B        |L1.1138|
                  |L1.1068|
                          DCD      0x40010c00
                  |L1.1072|
                          DCD      0x40021000
                  |L1.1076|
000434  2a00              CMP      r2,#0
000436  bf14              ITE      NE
000438  f44f7180          MOVNE    r1,#0x100
00043c  2140              MOVEQ    r1,#0x40
00043e  81a1              STRH     r1,[r4,#0xc]
000440  bf14              ITE      NE
000442  f44f7100          MOVNE    r1,#0x200
000446  2180              MOVEQ    r1,#0x80
000448  8161              STRH     r1,[r4,#0xa]
00044a  211f              MOVS     r1,#0x1f
00044c  7621              STRB     r1,[r4,#0x18]
00044e  2120              MOVS     r1,#0x20
000450  7661              STRB     r1,[r4,#0x19]
000452  0409              LSLS     r1,r1,#16
000454  6121              STR      r1,[r4,#0x10]
000456  49c4              LDR      r1,|L1.1896|
000458  600c              STR      r4,[r1,#0]  ; pI2C1
00045a  e00a              B        |L1.1138|
                  |L1.1116|
00045c  81a0              STRH     r0,[r4,#0xc]
00045e  f44f6100          MOV      r1,#0x800
000462  8161              STRH     r1,[r4,#0xa]
000464  2121              MOVS     r1,#0x21
000466  7621              STRB     r1,[r4,#0x18]
000468  2122              MOVS     r1,#0x22
00046a  7661              STRB     r1,[r4,#0x19]
00046c  f44f0180          MOV      r1,#0x400000
000470  6121              STR      r1,[r4,#0x10]
                  |L1.1138|
000472  2d05              CMP      r5,#5
000474  d20f              BCS      |L1.1174|
000476  e8dff005          TBB      [pc,r5]
00047a  0306              DCB      0x03,0x06
00047c  090e0c00          DCB      0x09,0x0e,0x0c,0x00
000480  f44f60e0          MOV      r0,#0x700
000484  e007              B        |L1.1174|
000486  f44f60c0          MOV      r0,#0x600
00048a  e004              B        |L1.1174|
00048c  f44f60a0          MOV      r0,#0x500
000490  e001              B        |L1.1174|
000492  f44f7040          MOV      r0,#0x300
                  |L1.1174|
000496  6160              STR      r0,[r4,#0x14]
000498  4620              MOV      r0,r4
00049a  f7fffffe          BL       _ZN3I2C10InitializeEv ; I2C::Initialize()
00049e  4620              MOV      r0,r4
0004a0  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

                  _ZN3I2C10AddCommandEhPhhS0_hP6Sensorb PROC ; I2C::AddCommand(unsigned char, unsigned char*, unsigned char, unsigned char*, unsigned char, Sensor*, bool)
;;;152    }
;;;153    bool I2C::AddCommand(u8 slaveAddr,u8 txData[], u8 txNum, u8 rxData[], u8 rxNum,Sensor *pDevice, bool isTaskTail)
0004a4  b4f0              PUSH     {r4-r7}
;;;154    {
0004a6  b085              SUB      sp,sp,#0x14
;;;155    	if(mCmdBank.Size()>=I2C_QUEUE_SIZE) 
0004a8  f8b0740a          LDRH     r7,[r0,#0x40a]
0004ac  e9dd540a          LDRD     r5,r4,[sp,#0x28]      ;154
0004b0  f8ddc030          LDR      r12,[sp,#0x30]
0004b4  9e09              LDR      r6,[sp,#0x24]
0004b6  2f32              CMP      r7,#0x32
;;;156    		return false;
0004b8  bf21              ITTTT    CS
0004ba  2000              MOVCS    r0,#0
;;;157    	I2C_Command i2cCmd;
;;;158    	i2cCmd.slaveAddr  = slaveAddr;
;;;159    	i2cCmd.outDataLen = txNum;
;;;160    	i2cCmd.inDataLen  = rxNum;
;;;161    	i2cCmd.pDataIn    = rxData;
;;;162    	i2cCmd.pDevice    = pDevice;
;;;163    	i2cCmd.isTaskTail = isTaskTail;
;;;164    	for(u8 i=0;i<txNum;i++)
;;;165    		i2cCmd.dataOut[i] = txData[i];
;;;166    	mCmdBank.Put(i2cCmd);
;;;167    	return true;
;;;168    }
0004bc  b005              ADDCS    sp,sp,#0x14
0004be  bcf0              POPCS    {r4-r7}
0004c0  4770              BXCS     lr
0004c2  f88d1000          STRB     r1,[sp,#0]            ;158
0004c6  9404              STR      r4,[sp,#0x10]         ;163
0004c8  f88d500c          STRB     r5,[sp,#0xc]          ;160
0004cc  1e5c              SUBS     r4,r3,#1              ;164
0004ce  f88d3006          STRB     r3,[sp,#6]            ;159
0004d2  9602              STR      r6,[sp,#8]            ;163
0004d4  f88dc00d          STRB     r12,[sp,#0xd]         ;163
0004d8  2c00              CMP      r4,#0                 ;164
0004da  dd16              BLE      |L1.1290|
0004dc  1e51              SUBS     r1,r2,#1              ;164
0004de  46ec              MOV      r12,sp                ;164
0004e0  f0130f01          TST      r3,#1
0004e4  d105              BNE      |L1.1266|
0004e6  f8115f01          LDRB     r5,[r1,#1]!           ;165
0004ea  f88d5001          STRB     r5,[sp,#1]            ;165
0004ee  f10c0c01          ADD      r12,r12,#1            ;165
                  |L1.1266|
0004f2  784d              LDRB     r5,[r1,#1]
0004f4  1064              ASRS     r4,r4,#1              ;164
0004f6  d008              BEQ      |L1.1290|
                  |L1.1272|
0004f8  f8116f02          LDRB     r6,[r1,#2]!
0004fc  f88c5001          STRB     r5,[r12,#1]           ;165
000500  784d              LDRB     r5,[r1,#1]            ;165
000502  f80c6f02          STRB     r6,[r12,#2]!          ;165
000506  1e64              SUBS     r4,r4,#1              ;165
000508  d1f6              BNE      |L1.1272|
                  |L1.1290|
00050a  1e59              SUBS     r1,r3,#1              ;165
00050c  d402              BMI      |L1.1300|
00050e  5c52              LDRB     r2,[r2,r1]            ;165
000510  4469              ADD      r1,r1,sp              ;165
000512  704a              STRB     r2,[r1,#1]            ;165
                  |L1.1300|
000514  f8b0140a          LDRH     r1,[r0,#0x40a]        ;165
000518  f8b02408          LDRH     r2,[r0,#0x408]        ;165
00051c  3020              ADDS     r0,r0,#0x20           ;165
00051e  4291              CMP      r1,r2                 ;165
000520  d21c              BCS      |L1.1372|
000522  f8b013ee          LDRH     r1,[r0,#0x3ee]        ;165
000526  eb010281          ADD      r2,r1,r1,LSL #2       ;165
00052a  1c49              ADDS     r1,r1,#1              ;165
00052c  f8a013ee          STRH     r1,[r0,#0x3ee]        ;165
000530  e89d101a          LDM      sp,{r1,r3,r4,r12}     ;165
000534  eb000282          ADD      r2,r0,r2,LSL #2       ;165
000538  e882101a          STM      r2,{r1,r3,r4,r12}     ;165
00053c  9904              LDR      r1,[sp,#0x10]         ;165
00053e  6111              STR      r1,[r2,#0x10]         ;165
000540  f8b013ee          LDRH     r1,[r0,#0x3ee]        ;165
000544  f8b023e8          LDRH     r2,[r0,#0x3e8]        ;165
000548  4291              CMP      r1,r2                 ;165
00054a  bf24              ITT      CS                    ;165
00054c  2100              MOVCS    r1,#0                 ;165
00054e  f8a013ee          STRHCS   r1,[r0,#0x3ee]        ;165
000552  f8b013ea          LDRH     r1,[r0,#0x3ea]        ;165
000556  1c49              ADDS     r1,r1,#1              ;165
000558  f8a013ea          STRH     r1,[r0,#0x3ea]        ;165
                  |L1.1372|
00055c  b005              ADD      sp,sp,#0x14
00055e  2001              MOVS     r0,#1                 ;167
000560  bcf0              POP      {r4-r7}
000562  4770              BX       lr
;;;169    
                          ENDP

                  _ZN3I2C5StartEv PROC ; I2C::Start()
;;;187    }
;;;188    bool I2C::Start()
000564  7f81              LDRB     r1,[r0,#0x1e]
;;;189    {
;;;190    	if(mState==I2C_STATE_FREE)
000566  2908              CMP      r1,#8
;;;191    		return StartNextCmd();
;;;192    	return false;
000568  bf1c              ITT      NE
00056a  2000              MOVNE    r0,#0
;;;193    }
00056c  4770              BXNE     lr
00056e  e7fe              B        _ZN3I2C12StartNextCmdEv ; I2C::StartNextCmd()
;;;194    bool I2C::IsHealthy()
                          ENDP

                  _ZN3I2C9IsHealthyEv PROC ; I2C::IsHealthy()
000570  7f80              LDRB     r0,[r0,#0x1e]
;;;195    {
;;;196    	if(mState==I2C_STATE_ERROR) 
000572  2809              CMP      r0,#9
;;;197    		return false;
000574  bf0c              ITE      EQ
000576  2000              MOVEQ    r0,#0
;;;198    	return true;
000578  2001              MOVNE    r0,#1
;;;199    }
00057a  4770              BX       lr
;;;200    bool I2C::IsFree()
                          ENDP

                  _ZN3I2C6IsFreeEv PROC ; I2C::IsFree()
00057c  7f80              LDRB     r0,[r0,#0x1e]
;;;201    {
;;;202    	if(mState==I2C_STATE_FREE) 
00057e  2808              CMP      r0,#8
;;;203    		return true;
000580  bf0c              ITE      EQ
000582  2001              MOVEQ    r0,#1
;;;204    	return false;
000584  2000              MOVNE    r0,#0
;;;205    }
000586  4770              BX       lr
;;;206    bool I2C::WaitFree(u16 ms)
                          ENDP

                  _ZN3I2C8WaitFreeEt PROC ; I2C::WaitFree(unsigned short)
000588  b081              SUB      sp,sp,#4
;;;207    {
;;;208    //	static volatile double newTime = 0, oldTime = 0;
;;;209    //	oldTime = newTime = TaskManager::Time();
;;;210    	volatile u32 cnt = 0;
00058a  2100              MOVS     r1,#0
;;;211    	while(mState!=I2C_STATE_FREE && ++cnt<10000/*(newTime-oldTime)*1000<ms*/)	
00058c  9100              STR      r1,[sp,#0]
00058e  7f80              LDRB     r0,[r0,#0x1e]
000590  f2427110          MOV      r1,#0x2710
                  |L1.1428|
000594  2808              CMP      r0,#8
000596  d007              BEQ      |L1.1448|
000598  9a00              LDR      r2,[sp,#0]
00059a  1c52              ADDS     r2,r2,#1
00059c  9200              STR      r2,[sp,#0]
00059e  428a              CMP      r2,r1
0005a0  d3f8              BCC      |L1.1428|
;;;212    		/*newTime=TaskManager::Time()*/;
;;;213    	
;;;214    	//com<<newTime<<oldTime<<"\n";
;;;215    	
;;;216    	if(mState==I2C_STATE_FREE) return true;
;;;217    	return false;		
0005a2  2000              MOVS     r0,#0
;;;218    }
0005a4  b001              ADD      sp,sp,#4
0005a6  4770              BX       lr
                  |L1.1448|
0005a8  2001              MOVS     r0,#1                 ;216
0005aa  b001              ADD      sp,sp,#4
0005ac  4770              BX       lr
;;;219    void I2C::EventIRQ()
                          ENDP

                  _ZN3I2C8EventIRQEv PROC ; I2C::EventIRQ()
0005ae  e92d41f0          PUSH     {r4-r8,lr}
;;;220    {
;;;221    	static u8 resetCount = 0;
;;;222    	
;;;223    	if(++resetCount>100)
0005b2  4d6e              LDR      r5,|L1.1900|
0005b4  4604              MOV      r4,r0                 ;220
0005b6  2700              MOVS     r7,#0
0005b8  7828              LDRB     r0,[r5,#0]  ; resetCount
0005ba  1c40              ADDS     r0,r0,#1
0005bc  b2c0              UXTB     r0,r0
0005be  7028              STRB     r0,[r5,#0]
0005c0  2864              CMP      r0,#0x64
0005c2  d90c              BLS      |L1.1502|
;;;224    	{
;;;225    		mState = I2C_STATE_ERROR;
0005c4  2009              MOVS     r0,#9
0005c6  77a0              STRB     r0,[r4,#0x1e]
;;;226    		mI2C->CR1 |= I2C_CR1_SWRST; 
0005c8  6820              LDR      r0,[r4,#0]
0005ca  8801              LDRH     r1,[r0,#0]
0005cc  f4414100          ORR      r1,r1,#0x8000
0005d0  8001              STRH     r1,[r0,#0]
;;;227    		mI2C->CR1 &= ~I2C_CR1_SWRST;
0005d2  6820              LDR      r0,[r4,#0]
0005d4  8801              LDRH     r1,[r0,#0]
0005d6  f4214100          BIC      r1,r1,#0x8000
0005da  8001              STRH     r1,[r0,#0]
;;;228    		resetCount = 0;
0005dc  702f              STRB     r7,[r5,#0]
                  |L1.1502|
;;;229    	}
;;;230    	
;;;231    	switch(I2C_GetLastEvent(mI2C))
0005de  6820              LDR      r0,[r4,#0]
0005e0  f7fffffe          BL       I2C_GetLastEvent
0005e4  4a62              LDR      r2,|L1.1904|
;;;232    	{
;;;233    		case I2C_EVENT_MASTER_MODE_SELECT:               //EV5:SB + BUSY + MSL
;;;234    			mState = I2C_STATE_ADDR;
;;;235    			mDataIdx = 0;
;;;236    			I2C_Send7bitAddress(mI2C, mCurCmd.slaveAddr, mI2CDirection);
;;;237    			break;
;;;238    		case I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: //EV6: after I2C_Send7bitAddress(W), should I2C_SendData()
;;;239    			mState = I2C_STATE_TXMOD;
;;;240    			I2C_SendData(mI2C, mCurCmd.dataOut[mDataIdx++]);
;;;241    			break;
;;;242    		case I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED:    //EV6:	after I2C_Send7bitAddress(R)	
;;;243    			mState = I2C_STATE_RXMOD;
;;;244    			if(mCurCmd.inDataLen<=1)
;;;245    			{
;;;246    				I2C_AcknowledgeConfig(mI2C,DISABLE);
;;;247    				I2C_GenerateSTOP(mI2C,ENABLE);
0005e6  2601              MOVS     r6,#1
0005e8  1a81              SUBS     r1,r0,r2              ;231
;;;248    			}
;;;249    			break;
;;;250    		case I2C_EVENT_MASTER_BYTE_RECEIVED:             //EV7:  data arrived, should receive data
;;;251    			mState = I2C_STATE_RX;
;;;252    			mCurCmd.pDataIn[mDataIdx++] = I2C_ReceiveData(mI2C);
;;;253    			if(mCurCmd.inDataLen - mDataIdx == 1)
;;;254    			{
;;;255    				I2C_AcknowledgeConfig(mI2C,DISABLE);
;;;256    				I2C_GenerateSTOP(mI2C,ENABLE);
;;;257    			}
;;;258    			else if(mCurCmd.inDataLen == mDataIdx)
;;;259    			{
;;;260    				mState = I2C_STATE_STOP;
0005ea  f04f0807          MOV      r8,#7
0005ee  4290              CMP      r0,r2                 ;231
0005f0  d046              BEQ      |L1.1664|
0005f2  dc10              BGT      |L1.1558|
0005f4  f46f3140          MVN      r1,#0x30000           ;231
0005f8  1840              ADDS     r0,r0,r1              ;231
0005fa  d027              BEQ      |L1.1612|
0005fc  2801              CMP      r0,#1                 ;231
;;;261    				resetCount = 0;
;;;262    				if(mCurCmd.isTaskTail) mCurCmd.pDevice->Updated();
;;;263    				StartNextCmd();
;;;264    			}
;;;265    			break;
;;;266    		case I2C_EVENT_MASTER_BYTE_TRANSMITTED:	         //EV8_2:after I2C_SendData()	
;;;267    			if(mDataIdx < mCurCmd.outDataLen)
;;;268    			{
;;;269    				mState = I2C_STATE_TX;
;;;270    				I2C_SendData(mI2C,mCurCmd.dataOut[mDataIdx++]);
;;;271    			}
;;;272    			else
;;;273    			{
;;;274    				if(mCurCmd.inDataLen>0)
;;;275    				{
;;;276    					mState = I2C_STATE_START;
;;;277    					mDataIdx = 0;
;;;278    					mI2CDirection = I2C_Direction_Receiver;
;;;279    					I2C_GenerateSTART(mI2C,ENABLE);
;;;280    				}
;;;281    				else
;;;282    				{
;;;283    					mState = I2C_STATE_STOP;
;;;284    					I2C_GenerateSTOP(mI2C,ENABLE);
;;;285    					resetCount = 0;
;;;286    					if(mCurCmd.isTaskTail) mCurCmd.pDevice->Updated();
;;;287    					StartNextCmd();
;;;288    				}
;;;289    			}
;;;290    			break;
;;;291    	}
;;;292    }
0005fe  bf18              IT       NE
000600  e8bd81f0          POPNE    {r4-r8,pc}
000604  2004              MOVS     r0,#4                 ;243
000606  77a0              STRB     r0,[r4,#0x1e]         ;243
000608  f8940420          LDRB     r0,[r4,#0x420]        ;244
00060c  2801              CMP      r0,#1                 ;244
00060e  bf88              IT       HI
000610  e8bd81f0          POPHI    {r4-r8,pc}
000614  e063              B        |L1.1758|
                  |L1.1558|
000616  f5a12080          SUB      r0,r1,#0x40000        ;231
00061a  3842              SUBS     r0,r0,#0x42           ;231
00061c  f2044115          ADD      r1,r4,#0x415          ;240
000620  d021              BEQ      |L1.1638|
000622  2802              CMP      r0,#2                 ;231
000624  bf18              IT       NE
000626  e8bd81f0          POPNE    {r4-r8,pc}
00062a  f8940410          LDRB     r0,[r4,#0x410]        ;267
00062e  f894241a          LDRB     r2,[r4,#0x41a]        ;267
000632  4290              CMP      r0,r2                 ;267
000634  d25d              BCS      |L1.1778|
000636  2205              MOVS     r2,#5                 ;269
000638  77a2              STRB     r2,[r4,#0x1e]         ;269
00063a  1c42              ADDS     r2,r0,#1              ;270
00063c  f8842410          STRB     r2,[r4,#0x410]        ;270
000640  5c41              LDRB     r1,[r0,r1]            ;270
000642  6820              LDR      r0,[r4,#0]            ;270
000644  e8bd41f0          POP      {r4-r8,lr}            ;270
000648  f7ffbffe          B.W      I2C_SendData
                  |L1.1612|
00064c  2002              MOVS     r0,#2                 ;234
00064e  77a0              STRB     r0,[r4,#0x1e]         ;234
000650  f8847410          STRB     r7,[r4,#0x410]        ;235
000654  f8942411          LDRB     r2,[r4,#0x411]        ;236
000658  f8941414          LDRB     r1,[r4,#0x414]        ;236
00065c  6820              LDR      r0,[r4,#0]            ;236
00065e  e8bd41f0          POP      {r4-r8,lr}            ;236
000662  f7ffbffe          B.W      I2C_Send7bitAddress
                  |L1.1638|
000666  2003              MOVS     r0,#3                 ;239
000668  77a0              STRB     r0,[r4,#0x1e]         ;239
00066a  f8940410          LDRB     r0,[r4,#0x410]        ;240
00066e  1c42              ADDS     r2,r0,#1              ;240
000670  f8842410          STRB     r2,[r4,#0x410]        ;240
000674  5c41              LDRB     r1,[r0,r1]            ;240
000676  6820              LDR      r0,[r4,#0]            ;240
000678  e8bd41f0          POP      {r4-r8,lr}            ;240
00067c  f7ffbffe          B.W      I2C_SendData
                  |L1.1664|
000680  2006              MOVS     r0,#6                 ;251
000682  77a0              STRB     r0,[r4,#0x1e]         ;251
000684  6820              LDR      r0,[r4,#0]            ;252
000686  f7fffffe          BL       I2C_ReceiveData
00068a  4601              MOV      r1,r0                 ;252
00068c  f8940410          LDRB     r0,[r4,#0x410]        ;252
000690  f8d4341c          LDR      r3,[r4,#0x41c]        ;252
000694  1c42              ADDS     r2,r0,#1              ;252
000696  f8842410          STRB     r2,[r4,#0x410]        ;252
00069a  5419              STRB     r1,[r3,r0]            ;252
00069c  f8941420          LDRB     r1,[r4,#0x420]        ;253
0006a0  f8940410          LDRB     r0,[r4,#0x410]        ;253
0006a4  1a0a              SUBS     r2,r1,r0              ;253
0006a6  2a01              CMP      r2,#1                 ;253
0006a8  d019              BEQ      |L1.1758|
0006aa  4281              CMP      r1,r0                 ;258
0006ac  bf18              IT       NE
0006ae  e8bd81f0          POPNE    {r4-r8,pc}
0006b2  f884801e          STRB     r8,[r4,#0x1e]         ;260
0006b6  702f              STRB     r7,[r5,#0]            ;261
0006b8  f8940421          LDRB     r0,[r4,#0x421]        ;262
0006bc  b3e8              CBZ      r0,|L1.1850|
0006be  f8d45424          LDR      r5,[r4,#0x424]        ;262
0006c2  706e              STRB     r6,[r5,#1]            ;262
0006c4  f7fffffe          BL       _ZN11TaskManager4TimeEv ; TaskManager::Time()
0006c8  e9d52302          LDRD     r2,r3,[r5,#8]         ;262
0006cc  4607              MOV      r7,r0                 ;262
0006ce  460e              MOV      r6,r1                 ;262
0006d0  f7fffffe          BL       __aeabi_dsub
0006d4  e9c50104          STRD     r0,r1,[r5,#0x10]      ;262
0006d8  e9c57602          STRD     r7,r6,[r5,#8]         ;262
0006dc  e032              B        |L1.1860|
                  |L1.1758|
0006de  2100              MOVS     r1,#0                 ;255
0006e0  6820              LDR      r0,[r4,#0]            ;255
0006e2  f7fffffe          BL       I2C_AcknowledgeConfig
0006e6  6820              LDR      r0,[r4,#0]            ;256
0006e8  e8bd41f0          POP      {r4-r8,lr}            ;256
0006ec  2101              MOVS     r1,#1                 ;256
0006ee  f7ffbffe          B.W      I2C_GenerateSTOP
                  |L1.1778|
0006f2  f8940420          LDRB     r0,[r4,#0x420]        ;274
0006f6  b150              CBZ      r0,|L1.1806|
0006f8  77a6              STRB     r6,[r4,#0x1e]         ;276
0006fa  f8847410          STRB     r7,[r4,#0x410]        ;277
0006fe  f8846411          STRB     r6,[r4,#0x411]        ;278
000702  6820              LDR      r0,[r4,#0]            ;279
000704  e8bd41f0          POP      {r4-r8,lr}            ;279
000708  2101              MOVS     r1,#1                 ;279
00070a  f7ffbffe          B.W      I2C_GenerateSTART
                  |L1.1806|
00070e  f884801e          STRB     r8,[r4,#0x1e]         ;283
000712  2101              MOVS     r1,#1                 ;284
000714  6820              LDR      r0,[r4,#0]            ;284
000716  f7fffffe          BL       I2C_GenerateSTOP
00071a  702f              STRB     r7,[r5,#0]            ;285
00071c  f8940421          LDRB     r0,[r4,#0x421]        ;286
000720  b158              CBZ      r0,|L1.1850|
000722  f8d45424          LDR      r5,[r4,#0x424]        ;286
000726  706e              STRB     r6,[r5,#1]            ;286
000728  f7fffffe          BL       _ZN11TaskManager4TimeEv ; TaskManager::Time()
00072c  e9d52302          LDRD     r2,r3,[r5,#8]         ;286
000730  4606              MOV      r6,r0                 ;286
000732  460f              MOV      r7,r1                 ;286
000734  f7fffffe          BL       __aeabi_dsub
000738  e000              B        |L1.1852|
                  |L1.1850|
00073a  e003              B        |L1.1860|
                  |L1.1852|
00073c  e9c50104          STRD     r0,r1,[r5,#0x10]      ;286
000740  e9c56702          STRD     r6,r7,[r5,#8]         ;286
                  |L1.1860|
000744  4620              MOV      r0,r4                 ;287
000746  e8bd41f0          POP      {r4-r8,lr}            ;287
00074a  e7fe              B        _ZN3I2C12StartNextCmdEv ; I2C::StartNextCmd()
;;;293    void I2C::ErrorIRQ()
                          ENDP

                  _ZN3I2C8ErrorIRQEv PROC ; I2C::ErrorIRQ()
00074c  6801              LDR      r1,[r0,#0]
;;;294    {
;;;295    	mI2C->CR1 |= I2C_CR1_SWRST; 
00074e  880a              LDRH     r2,[r1,#0]
000750  f4424200          ORR      r2,r2,#0x8000
000754  800a              STRH     r2,[r1,#0]
;;;296    	mI2C->CR1 &= ~I2C_CR1_SWRST;
000756  6801              LDR      r1,[r0,#0]
000758  880a              LDRH     r2,[r1,#0]
00075a  f4224200          BIC      r2,r2,#0x8000
00075e  800a              STRH     r2,[r1,#0]
;;;297    	mState = I2C_STATE_ERROR;
000760  2109              MOVS     r1,#9
000762  7781              STRB     r1,[r0,#0x1e]
;;;298    }
000764  4770              BX       lr
;;;299    
                          ENDP

000766  0000              DCW      0x0000
                  |L1.1896|
                          DCD      pI2C1
                  |L1.1900|
                          DCD      ||.data||
                  |L1.1904|
                          DCD      0x00030040

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=0

                  resetCount
000000  00                DCB      0x00
